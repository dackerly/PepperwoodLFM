---
title: "Additional analysis"
author: "Indra Boving"
date: "2024-04-03"
output: html_document
---

#Setup
```{r setup, include=FALSE}
rm(list = ls())
library(tidyverse)
library(here)
library(janitor)
source(here("scripts", "figure_info.R"))
library(ggpmisc)
```

```{r}
color_species <- scale_color_manual(
  values = c(
    ABICON = "#17154f",
    ADEFAS = "#2f357c",
    ARBMEN = "#6c5d9e",
    
    ARCGLA = "#9d9cd5",
    ARCPAT = "#b0799a",
    CALDEC = "#59385c",
    CEACUN = "#f6b3b0",
    
    CEAPAR = "#b38711",
    CEASPI = "#e48171",
    CERBET = "#d8b847",
    
    ERIFAS = "#bf3729",
    HETARB = "#e69b00",
    
    MALLAU = "#f5bb50",
    PINJEF = "#ada43b",
    PSEMEN = "#355828",
    
    QUEAGR = "#5b859e",
    QUEBER = "#1e395f",
    QUEDOU = "#75884b",
    
    QUEDUR = "#1e5a46",
    QUEGAR = "#df8d71",
    QUEKEL = "#af4f2f",
    
    SALLEU = "#d48f90",
    SALMEL = "#732f30",
    UMBCAL = "#d8b847"
  ),
  drop = FALSE
)


color_genus_species <- scale_color_manual(
  values = c(
    "Abies concolor"              = "#17154f",
    "Adenostoma fasciculatum"     = "#2f357c",
    "Arbutus menziesii"           = "#6c5d9e",
    
    "Arctostaphylos glandulosa"   = "#9d9cd5",
    "Arctostaphylos patula"       = "#b0799a",
    "Calocedrus decurrens"        = "#59385c",
    "Ceanothus cordulatus"        = "#f6b3b0",
    
    "Ceanothus cuneatus"          = "#f6b3b0",  # same genus color
    "Ceanothus parryi"            = "#b38711",
    "Ceanothus spinosus"          = "#e48171",
    
    "Cercocarpus betuloides"      = "#d8b847",
    "Eriogonum fasciculatum"      = "#bf3729",
    "Heteromeles arbutifolia"     = "#e69b00",
    
    "Malosma laurina"             = "#f5bb50",
    "Pinus jeffreyi"              = "#ada43b",
    "Pseudotsuga menziesii"       = "#355828",
    
    "Quercus agrifolia"           = "#5b859e",
    "Quercus berberidifolia"      = "#1e395f",
    "Quercus douglasii"           = "#75884b",
    
    "Quercus durata"              = "#1e5a46",
    "Quercus garryana"            = "#df8d71",
    "Quercus kelloggii"           = "#af4f2f",
    
    "Salvia leucophylla"          = "#d48f90",
    "Salvia mellifera"            = "#732f30",
    "Umbellularia californica"    = "#d8b847"
  ),
  drop = FALSE
)


```

#Data wrangling: 

#####Read in: 

Description of datasets: 

```{r}
df <- read_csv(here::here("data", "all-data-combined.csv")) %>% 
  clean_names() %>% 
  mutate(ilfm = 1/lfm) %>% 
  mutate(tissue_age = case_when(
  tissue_age %in% c(NA, NaN) ~ "both",
  TRUE ~ as.character(tissue_age)
  )) %>% 
  filter(!(sp_site %in% c(#"ABICON_SEKI", 
                          #"PINJEF_SEKI", 
                         # "CALDEC_SEKI" 
                          #"PSEMEN_Pepperwood"
                          ))) #these act really odd, dont include
  # filter(!(sp_site %in% c("ABICON_SEKI", "PINJEF_SEKI") & tissue_age %in% c("old")))

```

#####Outliers? 

```{r}
df %>% 
  filter(study == "SEKI") %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = tissue_age)) + 
  geom_hline(yintercept = 70, linetype = "dotted") +
    geom_point(alpha = .4) +
  labs(x = "Midday Water Poential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Study", 
       shape = "Study") +
  color +
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  facet_wrap(~species, scales = "free")

df %>% 
  filter(study == "Sedgwick") %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = tissue_age)) + 
  geom_hline(yintercept = 70, linetype = "dotted") +
    geom_point(alpha = .4) +
  labs(x = "Midday Water Poential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Study", 
       shape = "Study") +
  color +
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  facet_wrap(~species, scales = "free")


df %>% 
  filter(study == "Pepperwood") %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = tissue_age)) + 
  geom_hline(yintercept = 70, linetype = "dotted") +
    geom_point(alpha = .4) +
  labs(x = "Midday Water Poential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Study", 
       shape = "Study") +
  color +
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  facet_wrap(~species, scales = "free")

df %>% 
  filter(study == "StuntRanch") %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = tissue_age)) + 
  geom_hline(yintercept = 70, linetype = "dotted") +
    geom_point(alpha = .4) +
  labs(x = "Midday Water Poential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Study", 
       shape = "Study") +
  color +
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  facet_wrap(~species, scales = "free")

unique(df$study)
```
model and look for outliers for each site:

```{r}
#SEKI outliers:
df_seki  <- df %>% 
  clean_names() %>% 
  mutate(ilfm = 1/lfm) %>% 
  filter(study == "SEKI")

#model with untransformed LFM: 
mod <- glm(mwp ~ lfm, data = df_seki)
mod
summary(mod)
plot(mod)

#model with transformed LFM: 
mod_inv <- glm(mwp ~ ilfm, data = df_seki)
mod_inv
summary(mod_inv)
plot(mod_inv)
#resid(mod_inv)

AIC(mod_inv)
AIC(mod)

#SEKI shows this the least

df[168,]

mod2 <- glm(mwp ~ lfm, data = df_seki[-168,])
mod2
summary(mod2)
plot(mod2)

AIC(mod, mod2)

coef(mod)
coef(mod2)

#Sedgwick outliers:
df_sedge  <- df %>% 
  clean_names() %>% 
  mutate(ilfm = 1/lfm) %>% 
  filter(study == "Sedgwick")

#model with untransformed LFM: 
mod <- glm(mwp ~ lfm, data = df_sedge)
mod
summary(mod)
plot(mod)

#model with untransformed LFM: 
mod2 <- glm(mwp ~ lfm, data = df_sedge[-231,])
mod2
summary(mod2)
plot(mod2)

AIC(mod, mod2)
coef(mod)
coef(mod2)

df_sedge[231,]

#model with transformed LFM: 
mod_inv <- glm(mwp ~ ilfm, data = df_sedge)
mod_inv
summary(mod_inv)
plot(mod_inv)
#resid(mod_inv)

AIC(mod_inv)
AIC(mod)

#Pepperwood outliers
df_pep  <- df %>% 
  clean_names() %>% 
  mutate(ilfm = 1/lfm) %>% 
  filter(!(study == "Pepperwood"))

#model with untransformed LFM: 
mod <- glm(mwp ~ lfm, data = df_pep)
mod
summary(mod)
plot(mod)

#model with transformed LFM: 
mod_inv <- glm(mwp ~ ilfm, data = df_pep)
mod_inv
summary(mod_inv)
plot(mod_inv)
#resid(mod_inv)

AIC(mod_inv)
AIC(mod)
```

Remove outliers, now this is the dataset we want to use: 
```{r}
df1 <- df %>% 
  filter(!(species %in% c("QUEAGR") & date %in% c("2022-04-27") & study %in% c("Sedgwick"))) %>% 
  mutate(study_nice = case_when(
    study %in% c("Pepperwood") ~ "PwD",
    study %in% c("Sedgwick") ~ "SeR",
    study %in% c("SEKI") ~ "PrC",
    study %in% c("StuntRanch") ~ "StR"
  ))

unique(df1$study)
```



"To estimate species-specific minimum water potential (Ψmin), we used a hybrid extreme-value framework following Martínez-Vilalta et al. (2021). For each species (binning site and year to increase sample sizes), we implemented a peaks-over-threshold (POT) approach in which the upper tail of the Ψ distribution was defined using a species-specific threshold corresponding to a high quantile of the data. The threshold probability (pu) was selected adaptively to ensure adequate sampling of the tail, with pu constrained between 0.80 and 0.90 and chosen such that the expected number of exceedances above the threshold was at least 15 observations whenever possible. Exceedances above this threshold were modeled using a generalized Pareto distribution (GPD), fitted by probability-weighted moments. When the fitted GPD was well defined (positive scale parameter) and the number of exceedances met the minimum tail size criterion (≥ 10), Ψmin was estimated as the 99th percentile of the fitted POT-GPD distribution, representing an extreme but statistically estimable lower bound of water potential. For species that did not meet these criteria due to limited sample size or unstable tail fits, Ψmin was instead defined as the most negative observed water potential (Ackerly et al, 2006? check this). This hybrid approach balances statistical robustness and biological realism by using EVT-based extrapolation only where the data support it, while avoiding excessive extrapolation for sparsely sampled species."

```{r}
# ============================================================
# Hybrid Psi-min per species:
#   - EVT POT-GPD Psi-min when tail sample large enough
#   - Observed minimum otherwise
# ============================================================

library(dplyr)
library(purrr)
library(fExtremes)

# --- Load ---
dat <- df1 %>%
  mutate(
    mwp = as.numeric(mwp),
    psi_abs = abs(mwp)
  ) %>%
  filter(is.finite(mwp), is.finite(psi_abs), !is.na(species))

# --- Settings you can tune ---
psi_min_p <- 0.999      # extreme quantile for Psi-min (0.99 more stable than 0.999)
min_tail  <- 5        # minimum tail points required to use EVT
pu_max    <- 0.95      # highest threshold prob
pu_min    <- 0.80      # lowest threshold prob (drop if needed for more tail points)

# --- Vector-safe POT quantile (no qgpd arg issues) ---
pot_quantile <- function(p, u, p_u, xi, beta) {
  if (p <= p_u) return(NA_real_)
  q <- (p - p_u) / (1 - p_u)
  q <- min(max(q, 0), 0.999999)

  if (!is.finite(xi) || !is.finite(beta) || beta <= 0) return(NA_real_)

  # GPD exceedance quantile y
  if (abs(xi) < 1e-12) {
    yq <- -beta * log(1 - q)               # xi -> 0 limit
  } else {
    yq <- (beta/xi) * ((1 - q)^(-xi) - 1)  # general case
  }
  u + yq
}

# --- 1) Adaptive threshold per species to try to reach min_tail ---
u_tbl <- dat %>%
  count(species, name = "n") %>%
  mutate(
    pu = pmin(pu_max, pmax(pu_min, 1 - (min_tail / n)))
  ) %>%
  left_join(dat %>% select(species, psi_abs), by = "species") %>%
  group_by(species, n, pu) %>%
  summarise(
    u = as.numeric(quantile(psi_abs, probs = unique(pu), na.rm = TRUE)),
    .groups = "drop"
  )

# --- 2) Tail extraction + EVT fit (POT-GPD) ---
fits <- u_tbl %>%
  left_join(dat %>% select(species, psi_abs, mwp), by = "species") %>%
  group_by(species, n, pu, u) %>%
  summarise(
    x_tail = list(sort(psi_abs[psi_abs >= u])),
    k_tail = sum(psi_abs >= u),
    psi_min_obs = min(mwp, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    # EVT fit only if enough tail points
    gpd_fit = map2(x_tail, u, ~{
      x <- unlist(.x)
      if (length(x) < min_tail) return(NULL)
      tryCatch(
        fExtremes::gpdFit(x, u = .y, type = "pwm"),
        error = function(e) NULL
      )
    }),
    xi = map_dbl(gpd_fit, ~ if (is.null(.x)) NA_real_ else unname(.x@fit$par.ests["xi"])),
    beta = map_dbl(gpd_fit, ~ if (is.null(.x)) NA_real_ else unname(.x@fit$par.ests["beta"])),

    psi_min_evt_abs = pmap_dbl(list(u, pu, xi, beta), ~{
      if (any(!is.finite(c(..1, ..2, ..3, ..4))) || ..4 <= 0) return(NA_real_)
      pot_quantile(p = psi_min_p, u = ..1, p_u = ..2, xi = ..3, beta = ..4)
    }),
    psi_min_evt = -psi_min_evt_abs,  # back to negative MPa

    # Hybrid decision rule:
    use_evt = is.finite(psi_min_evt) & (k_tail >= min_tail),
    psi_min_hybrid = if_else(use_evt, psi_min_evt, psi_min_obs),
    psi_min_method = if_else(use_evt, "EVT_POT_GPD", "Observed_min_lowN")) %>%
  select(species, n, pu, u, k_tail, xi, beta,
         psi_min_obs, psi_min_evt, psi_min_hybrid, psi_min_method)

# --- 3) Output table ---
print(fits %>% arrange(psi_min_method, k_tail))

write.csv(fits, "psi_min_by_species_hybrid.csv", row.names = FALSE)

# build x range for the plot
figSX_evt_ests <- ggplot() +
  geom_point(data = fits,aes(y = psi_min_hybrid, 
           x = psi_min_obs,
           shape = psi_min_method,
           color = species, 
           )) +
  coord_equal() +
  geom_abline()

figSX_evt_ests

ggsave(plot = figSX_evt_ests, here::here("figures", "figSX_evt_ests.jpg"), dpi = 600, 
       height = 6, 
       width = 6, units = "in")
```


Generally sample sizes and groupings are too low to perform EVT, so we should probably just stick with minimum observed. 

#Table 1(dataset summary)

Table 1. Species names and characteristics and sample sizes across the four studies. Sites: PeW = Pepperwood, StR = Stunt Ranch (Pivovaroff et al. 2019), SeR = Sedgwick Reserve, PrC = Providence Creek Watershed; Dec/Ever = deciduous/evergreen; Growth form = tree or shrub. Sample sizes indicate individual observations (LFM and MPa from a single individual on a single date).

```{r}
#devtools::install_github("ecoinfor/U.Taxonstand")
#install.packages("U.Taxonstand")
#library(Taxonstand)
library(U.Taxonstand)  # If you're using U.Taxonstand instead

SpCodes <- read_csv(here("data", "SpCodes.csv")) %>%
  mutate(species = SpCode6) %>% 
  mutate(family = familyMatch(splist = c(Genus), taxon = "plant")$family)

traits_df <- read_csv(here("data", "traits_rd_20250327.csv")) %>% 
  clean_names() %>% 
  mutate(species = sp_code) %>% 
  select(species, functional_type, growth_form)

sp_info <- merge(traits_df, SpCodes) %>% 
  mutate(sp_code = SpCode6) %>% 
  mutate(dec_ever = case_when(
    species %in% c("QUEDOU",
                   "QUEGAR",
                   "QUEKEL",
                   "SALLEU",
                   "SALMEL") ~ "Dec",
    species %in% c("ERIFAS") ~ "Semi-Dec",
    TRUE ~ as.character("Ever")
  )) %>% 
  mutate(growth_form = case_when(
    species %in% c("CERBET") ~ "tree/shrub",
    TRUE ~ as.character(growth_form)
  ))


sp_info %>% write_csv(here("data", "sp_info.csv"))
```


```{r}
table1_df <- merge(df1, sp_info, by = c("species")) %>% 
  group_by(study, species, Genus_species, functional_type, growth_form, family, dec_ever) %>% 
  summarise(n = n()) %>% 
  pivot_wider(names_from = c(study), 
              values_from = n)  %>% 
  mutate(common_name = case_when(
    species %in% c("ADEFAS") ~ "Chamise",
    species %in% c("ARBMEN") ~ "Madrone",
    species %in% c("CEACUN") ~ "Bickbush",
    species %in% c("CEAPAR") ~ "Parry ceanothus",
    species %in% c("HETARB") ~ "Toyon",
    species %in% c("PSEMEN") ~ "Douglas-fir",
    
    species %in% c("ABICON") ~ "Abies concolor",
    species %in% c("PINJEF") ~ "Pinus Jeffreyii",
    species %in% c("CALCED") ~ "Calocedrus decurrens",
    
    species %in% c("QUEAGR") ~ "Live oak",
    species %in% c("QUEDOU") ~ "Blue oak",
    species %in% c("QUEDUR") ~ "Leather oak",
    species %in% c("QUEGAR") ~ "Oregon white oak",
    species %in% c("QUEKEL") ~ "California black oak",
    species %in% c("UMBCAL") ~ "California bay",
    species %in% c("ARCPAT") ~ "Greenleaf manzanita",
    species %in% c("CEACOR") ~ "Whitethorn ceanothus",
    species %in% c("ARCGLA") ~ "Eastwood manzanita",
    species %in% c("CEASPI") ~ "Greenbark ceanothus",
    species %in% c("CERBET") ~ "Mountain mahogany",
    species %in% c("ERIFAS") ~ "California buckwheat",
    species %in% c("MALLAU") ~ "Laurel sumac",
    species %in% c("QUEBER") ~ "Scrub oak",
    species %in% c("SALLEU") ~ "Purple sage",
    species %in% c("SALMEL") ~ "Black sage")) %>% 
  ungroup() %>% 
  dplyr::select(species, Genus_species, common_name, family, growth_form, dec_ever, Pepperwood, SEKI, Sedgwick, StuntRanch) %>% 
  rename(PeW = Pepperwood, 
         PrC = SEKI, 
         StR = StuntRanch, 
         SeR = Sedgwick) %>% 
  arrange(species, Genus_species, common_name, family, growth_form, dec_ever, PeW, PrC, StR, SeR) %>%
  adorn_totals("row") %>% 
  ungroup()
# table1_df  %>% 
#   kable(format = "pipe")
write_csv(table1_df, here("results", "figures", "table1.csv"))
```

####Figure 1: (datasets)

```{r}
color_genus_species

fig1 <- df1 %>% 
  merge(table1_df %>% select(species, Genus_species), by = c("species")) %>% 
  mutate(study_fullname = case_when(
    study_nice %in% c("PrC") ~ "Providence Creek",
    study_nice %in% c("PwD") ~ "Pepperwood",
    study_nice %in% c("SeR") ~ "Sedgwick Reserve",
    study_nice %in% c("StR") ~ "Stunt Ranch",
    TRUE ~ as.character(study_nice)
  )) %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = Genus_species)) + 
  geom_hline(yintercept = 60, linetype = "dotted") +
    geom_point(alpha = .8) +
  labs(x = "Midday Water Potential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Species", 
       shape = "Study") +
    #scale_color_manual(values = cal_palette("sierra1", n = 22, type = "discrete")) +
  color_genus_species + 
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  theme(
    legend.key = element_blank(),
    legend.background = element_blank()
) +
  facet_wrap(~study_fullname, nrow = 2)
fig1

ggsave(plot = fig1, here::here("figures", "fig2.jpg"), dpi = 600, 
       height = 4, 
       width = 8, units = "in")
```

```{r, eval = F}
#David's code
## Preliminary analysis of 2021 Live Fuel Moisture (LFM) data

library(ggplot2)  # Load ggplot2 package for advanced plotting capabilities
source(here('scripts', 'lfm_functions.R'))
# Source custom functions from external script

# Read in the combined dataset; 'as.is = TRUE' prevents strings from converting to factors
# 'row.names = 1' uses the first column as row names
lwa <- df1

# Calculate the inverse of LFM for modeling purposes
lwa$ilfm <- 1 / lwa$lfm

# Display the first few rows of the data to check if it's loaded correctly
head(lwa)

# Create a frequency table of the 'study' variable
table(lwa$study)

# Get a sorted list of unique study sites
sites <- sort(unique(lwa$study))

# Verify the number of observations per study
table(lwa$study)

# Check the total number of observations
nrow(lwa)

### Plotting by Site

# Define colors for each site for consistent plotting
scolors <- c("#B9C7E2", "#ECAB99",  "#5B6530", "#9484B1",  "#F1C100")  # Added color for SEKI

# Assign colors to each observation based on the study site
lwa$scolors <- scolors[match(lwa$study, sites)]

# Confirm that colors are assigned correctly
table(lwa$scolors)

# Randomly sample 1000 observations for plotting to avoid overplotting
rsamp <- sample(1:nrow(lwa), 1000)  # Sample from the full dataset

# Set up an empty plot with defined axes and limits
plot(lfm ~ mwp, data = lwa, type = 'n',
     xlab = 'Midday water potential (MPa)',
     ylab = 'Live fuel moisture',
     xlim = c(-8, 0), ylim = c(0, 3.5))

# Include SEKI in the points plotting
points(lfm ~ mwp, data = lwa[lwa$study == 'SEKI', ],
       pch = 17, cex = 1.2, col = lwa$scolors[lwa$study == 'SEKI'])  # Different symbol for SEKI

# Plot data points for each study site with different symbols and colors
points(lfm ~ mwp, data = lwa[lwa$study == 'Sedgwick', ],
       pch = 5, cex = 1, col = lwa$scolors[lwa$study == 'Sedgwick'])

points(lfm ~ mwp, data = lwa[lwa$study == 'StuntRanch', ],
       pch = 15, cex = 1, col = lwa$scolors[lwa$study == 'StuntRanch'])

points(lfm ~ mwp, data = lwa[lwa$study == 'Pepperwood', ],
       pch = 19, cex = 1.2, col = lwa$scolors[lwa$study == 'Pepperwood'])


# Add a legend to the plot
legend(-7, 3, sites, fill = NULL, border = 'white')

# Add custom legend symbols corresponding to each site
points(rep(-6.7, length(sites)), seq(2.84, 2.64 - 0.2 * (length(sites) - 1), length.out = length(sites)),
       pch = c(19, 5, 15, 17), col = scolors, cex = 2)  # Added SEKI symbol
```

#Q0: Conceptual Model:

#####Figure 2: (color)
```{r}
## conceptual model
source(here("scripts", "lfm_functions.R"))
spres <- read.csv(here("results", "species-results.csv"))
head(spres)
slp <- -0.198

#MWPvec <- seq(-6,0,length.out=25)
ilfm.sat.vec <- seq(0.25,1.25,length.out=25)
MWPcrit <- c()
for (i in 1:length(ilfm.sat.vec)) MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i],slp),1/0.7)
lfm.sat.vec <- 1/ilfm.sat.vec
plot(MWPcrit,lfm.sat.vec,xlim=c(-8,0),ylim=c(0,4),type='l',lwd=2,xlab='Minimum MWP (MPa)',ylab='LFM @ MWP=0')

for (i in 1:length(ilfm.sat.vec)) MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i],slp),1/0.5)
lfm.sat.vec <- 1/ilfm.sat.vec
lines(MWPcrit,lfm.sat.vec,xlim=c(-8,0),ylim=c(0,4),lwd=1)

for (i in 1:length(ilfm.sat.vec)) MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i],slp),1/1)
lfm.sat.vec <- 1/ilfm.sat.vec
lines(MWPcrit,lfm.sat.vec,xlim=c(-8,0),ylim=c(0,4),lwd=1)

#points(I(1/model1.int)~minWP,data=spres[which(spres$study=='Coastal'),],pch=19)
text(I(1/model1.int)~minWP,data=spres[which(spres$study=='Coastal'),],labels=letters)

# conceptual figure, in inverted space - need to flip to LFM# conceptual figulettersre, in inverted space - need to flip to LFM
lfm.sat <- c(0.9,0.5)
slp <- -0.2
min.MWP <- c(-6,-3)

xy <- inversePlotData(c(min.MWP[1],0),c(lfm.sat[1],slp))
head(xy)
plot(xy$MWP,xy$LFM)

(MWPcrit <- solveForX(c(lfm.sat[2],slp),1/0.7))
#------
(max.iLFM <- lfm.sat + min.MWP*slp)
(min.LFM <- 1/max.iLFM)

op=par(mfrow=c(1,2))
plot(c(-7,0),c(0,3),type='n',xlab='MWP',ylab='1/LFM')
x <- list()
y <- list()
for (i in 1:2) {
  x[[i]] <- c(0,min.MWP[i])
  y[[i]] <- c(lfm.sat[i],max.iLFM[i])
  lines(x[[i]],y[[i]],type='b',cex=2,pch=c(1,19))
}

xy1 <- inversePlotData(c(0,min.MWP[1]),c(lfm.sat[1],slp))
xy2 <- inversePlotData(c(0,min.MWP[2]),c(lfm.sat[2],slp))
plot(c(-7,0),c(0,3),type='n',xlab='MWP',ylab='LFM')
lines(xy1$MWP,xy1$LFM,type='l')
head(xy1)
points(xy1[c(1,100),c('MWP','LFM')],cex=2,pch=c(1,19))
lines(xy2$MWP,xy2$LFM,type='l')
points(xy2[c(1,100),c('MWP','LFM')],cex=2,pch=c(1,19))
par(op)

#-----
# Choose distinct colors for each line
cols <- c("steelblue3", "tomato3")  # i=1 -> cols[1], i=2 -> cols[2]

xy <- inversePlotData(c(min.MWP[1], 0), c(lfm.sat[1], slp))
plot(xy$MWP, xy$LFM)

(MWPcrit <- solveForX(c(lfm.sat[2], slp), 1/0.7))

(max.iLFM <- lfm.sat + min.MWP * slp)
(min.LFM  <- 1 / max.iLFM)

op <- par(mfrow = c(1, 2))

## Panel 1: 1/LFM vs MWP
plot(c(-7, 0), c(0, 3), type = "n", xlab = "MWP", ylab = "1/LFM")
mtext("A", side = 3, adj = 0, line = 1.2, font = 2, cex = 1.2)  # Panel label
x <- vector("list", 2)
y <- vector("list", 2)
for (i in 1:2) {
  x[[i]] <- c(0, min.MWP[i])
  y[[i]] <- c(lfm.sat[i], max.iLFM[i])
  # open circle for first point, filled circle for second
  lines(x[[i]], y[[i]], col = cols[i], lwd = 2)
  points(x[[i]][1], y[[i]][1], pch = 21, bg = "white", col = cols[i], cex = 2, lwd = 2)
  points(x[[i]][2], y[[i]][2], pch = 19, col = cols[i], cex = 2)
}

## Panel 2: LFM vs MWP
xy1 <- inversePlotData(c(0, min.MWP[1]), c(lfm.sat[1], slp))
xy2 <- inversePlotData(c(0, min.MWP[2]), c(lfm.sat[2], slp))
plot(c(-7, 0), c(0, 3), type = "n", xlab = "MWP", ylab = "LFM")
mtext("B", side = 3, adj = 0, line = 1.2, font = 2, cex = 1.2)  # Panel label

lines(xy1$MWP, xy1$LFM, col = cols[1], lwd = 2)
points(xy1[1, c("MWP", "LFM")], pch = 21, bg = "white", col = cols[1], cex = 2, lwd = 2)
points(xy1[100, c("MWP", "LFM")], pch = 19, col = cols[1], cex = 2)

lines(xy2$MWP, xy2$LFM, col = cols[2], lwd = 2)
points(xy2[1, c("MWP", "LFM")], pch = 21, bg = "white", col = cols[2], cex = 2, lwd = 2)
points(xy2[100, c("MWP", "LFM")], pch = 19, col = cols[2], cex = 2)

par(op)

#----
library(dplyr)
library(ggplot2)
library(patchwork)

# Colors mapped consistently across both panels
cols <- c("steelblue3", "tomato3")
names(cols) <- c("1","2")  # map to id "1" and "2"

# --- Data prep ---------------------------------------------------------------

# Panel A (1/LFM vs MWP): two straight line segments with endpoints
max.iLFM <- lfm.sat + min.MWP * slp

dfA_lines <- tibble(
  id = factor(c(1,1, 2,2)),
  MWP = c(0, min.MWP[1], 0, min.MWP[2]),
  invLFM = c(lfm.sat[1], max.iLFM[1], lfm.sat[2], max.iLFM[2])
)

dfA_open <- dfA_lines %>%
  group_by(id) %>%
  slice_head(n = 1) %>%
  ungroup()

dfA_filled <- dfA_lines %>%
  group_by(id) %>%
  slice_tail(n = 1) %>%
  ungroup()

# Panel B (LFM vs MWP): two curves from inversePlotData
xy1 <- inversePlotData(c(0, min.MWP[1]), c(lfm.sat[1], slp)) %>% mutate(id = factor(1))
xy2 <- inversePlotData(c(0, min.MWP[2]), c(lfm.sat[2], slp)) %>% mutate(id = factor(2))
dfB_curve <- bind_rows(xy1, xy2)

dfB_open <- dfB_curve %>%
  group_by(id) %>%
  slice_head(n = 1) %>%
  ungroup()

dfB_filled <- dfB_curve %>%
  group_by(id) %>%
  slice_tail(n = 1) %>%
  ungroup()

# --- Plots -------------------------------------------------------------------

# Panel A: LFM vs MWP
pA <- ggplot(dfB_curve, aes(x = MWP, y = LFM, color = id)) +
  geom_line(linewidth = 1) +
  geom_vline(xintercept = 0, linetype="dotted") +
  geom_point(data = dfB_open,
             aes(x = MWP, y = LFM),
             shape = 21, fill = "white", size = 3.5, stroke = 1.2) +
  geom_point(data = dfB_filled,
             aes(x = MWP, y = LFM),
             shape = 19, size = 3.5) +
  annotate("text", x = -7, y = 3, label = "A", fontface = "bold",
           hjust = 0, vjust = 1, size = 5) +
  coord_cartesian(xlim = c(-7, 0), ylim = c(0, 3)) +
  scale_color_manual(values = cols, guide = "none") +
  labs(x = "Midday Water Potential (MPa)", y = "LFM (%)")

# Panel B: 1/LFM vs MWP
pB <- ggplot() +
  geom_line(data = dfA_lines,
            aes(x = MWP, y = invLFM, group = id, color = id), linewidth = 1) +
  geom_vline(xintercept = 0, linetype="dotted") +
  geom_point(data = dfA_open,
             aes(x = MWP, y = invLFM, color = id),
             shape = 21, fill = "white", size = 3.5, stroke = 1.2) +
  geom_point(data = dfA_filled,
             aes(x = MWP, y = invLFM, color = id),
             shape = 19, size = 3.5) +
  annotate("text", x = -7, y = 3, label = "B", fontface = "bold",
           hjust = 0, vjust = 1, size = 5) +
  coord_cartesian(xlim = c(-7, 0), ylim = c(0, 3)) +
  scale_color_manual(values = cols, guide = "none") +
  labs(x = "Midday Water Potential (MPa)", y = "1/LFM (%)")

# Side-by-side layout (no legend)
pA + pB + plot_layout(ncol = 2)

# Create the combined plot
final_plot <- pA + pB + plot_layout(ncol = 2, 
                                    axis_titles = "collect")
final_plot

# Save it
ggsave(
  filename = here("figures", "Figure2_color.png"),  # or .pdf, .jpg, etc.
  plot     = final_plot,
  width    = 8,     # inches
  height   = 4,     # inches
  dpi      = 300    # high resolution
)
#----
```


#Q1: Slopes and models

Intro/discussion:

1) What are the aggregate and species-level relationships between leaf water potential and live fuel moisture, and how do they compare across studies? We predict that initial LFM and minimum WP will explain variation in minimum LFM observed at the end of the dry season (following the conceptual model in Figure 2), and that these will be largely consistent across species.  


#####Figure SX. (linear fits, 1/lfm vs lfm)
Linear relationship between iLFM and middays: 

```{r}
# Model with untransformed LFM
mod <- glm(mwp ~ lfm, data = df1)
mod_summary <- summary(mod)

# Model with transformed LFM (inverse LFM)
mod_inv <- glm(mwp ~ ilfm, data = df1)
mod_inv_summary <- summary(mod_inv)

# Compare AIC and BIC
aic_values <- c(AIC(mod), AIC(mod_inv))
bic_values <- c(BIC(mod), BIC(mod_inv))
model_names <- c("Untransformed LFM", "Transformed LFM (iLFM)")

# Compute Pseudo R-squared (McFadden's R²)
pseudo_r2 <- function(model) {
  1 - (model$deviance / model$null.deviance)
}

r2_values <- c(pseudo_r2(mod), pseudo_r2(mod_inv))

# Compare residuals
par(mfrow = c(2, 2))  # Set plotting layout for residual diagnostics
plot(mod, main = "Untransformed LFM Model")
plot(mod_inv, main = "Transformed LFM Model")

# Create a summary table for comparison
model_comparison <- data.frame(
  Model = model_names,
  AIC = aic_values,
  BIC = bic_values,
  Pseudo_R2 = r2_values
)

print(model_comparison)

# Determine the better model based on AIC
best_model <- ifelse(AIC(mod_inv) < AIC(mod), "Transformed LFM (iLFM)", "Untransformed LFM")
cat("Best model based on AIC:", best_model, "\n")
```

#Table SX 
slope coefs, with cons
```{r, models}
#With conifers included: 
library(lme4)

mod_spp_int <- glm(ilfm ~ mwp*species, data = df1, family = gaussian)
#mod_spp_int_lmer <- lmer(ilfm ~ mwp*species + species|study, data = df1, REML = T)
mod_spp_noint <- glm(ilfm ~ mwp + species, data = df1, family = gaussian)
#mod_spp_lmer <- lmer(ilfm ~ mwp + species + 1|study, data = df1)

car::vif(mod_spp_noint)

aic <- AIC(mod_spp_int, mod_spp_noint)
aic
BIC(mod_spp_int, mod_spp_noint)

anova(mod_spp_int, mod_spp_noint)

# AIC(mod_spp_lmer, mod_spp_noint_lmer)
# BIC(mod_spp_lmer, mod_spp_noint_lmer)
# anova(mod_spp_lmer, mod_spp_noint_lmer)

plot(mod_spp_noint)

plot(mod_spp_int)

#r2: 
R2_spp_int <- performance::r2(mod_spp_int)
R2_spp_int

R2_spp_noint <- performance::r2(mod_spp_noint)
R2_spp_noint

#model details: 
coef(summary(mod_spp_int))
summary(mod_spp_int)

summary(mod_spp_noint)

tablesx_coefs <- broom::tidy(mod_spp_noint) %>% 
    dplyr::mutate(across(where(is.numeric), round, 4)) %>% 
  mutate(p.value.stars = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01 & p.value < 0.001 ~ "**",
    p.value < 0.05 & p.value > 0.01 ~ "*", 
    TRUE ~ as.character(" ")
  ))

write_csv(tablesx_coefs, here("results", "figures", "tableSX_coefs.csv"))

tablesx_ints_coefs <- broom::tidy(mod_spp_int) %>% 
    dplyr::mutate(across(where(is.numeric), round, 4)) %>% 
  mutate(p.value.stars = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01 & p.value < 0.001 ~ "**",
    p.value < 0.05 & p.value > 0.01 ~ "*", 
    TRUE ~ as.character(" ")
  ))
tablesx_ints_coefs

write_csv(tablesx_ints_coefs, here("results", "figures", "tableSX_ints_coefs_conifers.csv"))
```

####Use lmer: 
```{r}
# With conifers included (mixed-effects): random intercept for study
library(lme4)
library(dplyr)
library(readr)
library(here)
library(broom.mixed)
library(performance)

# ----------------------------
# Fit models (REML = FALSE for AIC/BIC + model comparison)
# ----------------------------
mod_spp_int  <- lmer(ilfm ~ mwp * species + (1 | study),
                    data = df1, REML = FALSE)

mod_spp_noint <- lmer(ilfm ~ mwp + species + (1 | study),
                     data = df1, REML = FALSE)

# ----------------------------
# Model comparison
# ----------------------------
AIC(mod_spp_int, mod_spp_noint)
BIC(mod_spp_int, mod_spp_noint)

anova(mod_spp_noint, mod_spp_int)   # LRT (nested models)

# ----------------------------
# Diagnostics / quick checks
# ----------------------------
plot(mod_spp_noint)
plot(mod_spp_int)

# (Optional) check singular fit
lme4::isSingular(mod_spp_int, tol = 1e-5)

# ----------------------------
# R2 (marginal/conditional)
# ----------------------------
R2_spp_int   <- performance::r2(mod_spp_int)
R2_spp_int

R2_spp_noint <- performance::r2(mod_spp_noint)
R2_spp_noint

# ----------------------------
# Model details
# ----------------------------
summary(mod_spp_int)
summary(mod_spp_noint)

# ----------------------------
# Tables: fixed effects (use broom.mixed)
# NOTE: lmer() summary p-values depend on method; broom.mixed defaults
#       to Wald-style unless you add lmerTest. If you want Satterthwaite
#       p-values, load lmerTest before fitting.
# ----------------------------
# tablesx_coefs <- broom.mixed::tidy(mod_spp_noint, effects = "fixed") %>%
#   mutate(across(where(is.numeric), round, 4)) %>%
#   mutate(p.value.stars = case_when(
#     is.na(p.value) ~ "",
#     p.value < 0.001 ~ "***",
#     p.value < 0.01  ~ "**",
#     
#     p.value < 0.05  ~ "*",
#     TRUE ~ ""
#   ))
# 
# write_csv(tablesx_coefs, here("results", "figures", "tableSX_coefs_lmer.csv"))
# 
# tablesx_ints_coefs <- broom.mixed::tidy(mod_spp_int, effects = "fixed") %>%
#   mutate(across(where(is.numeric), round, 4)) %>%
#   mutate(p.value.stars = case_when(
#     is.na(p.value) ~ "",
#     p.value < 0.001 ~ "***",
#     p.value < 0.01  ~ "**",
#     p.value < 0.05  ~ "*",
#     TRUE ~ ""
#   ))

write_csv(tablesx_ints_coefs, here("results", "figures", "tableSX_ints_coefs_conifers_lmer.csv"))
```


```{r}
#Do we need a random effect? YES
m_re <- lmer(ilfm ~ mwp * species + (1 | study), data = df1, REML = FALSE)
m_fe <- lm(  ilfm ~ mwp * species,               data = df1)

# Likelihood ratio test: does adding (1|study) improve fit?
#lme4::anova(m_fe, m_re)

# AIC/BIC comparison
aic <- AIC(m_fe, m_re)
aic
BIC(m_fe, m_re)

# How big is the study variance?
VarCorr(m_re)
lme4::isSingular(m_re, tol = 1e-5)

vc <- as.data.frame(VarCorr(m_re))
vc

performance::icc(m_re)  

summary(m_re)

write_csv(df1, here::here("temp_datasets", "df1.csv"))
```

Chats prescription for looking at study effect: 

```{r}
# ============================================================
# Sensitivity test: Do species-level INTERCEPTS / SLOPES change
# with vs. without a study random intercept?
#
# What this does:
#   1) reads df1.csv
#   2) checks how many studies per species (and obs per species×study)
#   3) fits two comparable models (both ML):
#        m_fe_lmer: ilfm ~ mwp_c * species
#        m_re:      ilfm ~ mwp_c * species + (1|study)
#   4) tests study RE via LRT + compares AIC/BIC
#   5) extracts species-specific intercepts (at mean mwp) + slopes
#      for BOTH models using emmeans/emtrends
#   6) makes a paired “with vs without” figure for intercepts + slopes
# ============================================================

# ---- packages ----
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(forcats)

library(lme4)
library(emmeans)
library(performance)

# ---- 0) load data ----

# ---- 1) basic prep ----
df1 <- df1 %>%
  mutate(
    species = as.factor(species),
    study   = as.factor(study),
    mwp     = as.numeric(mwp),
    ilfm    = as.numeric(ilfm)
  ) %>%
  filter(is.finite(mwp), is.finite(ilfm)) %>%
  mutate(
    mwp_c = mwp - mean(mwp, na.rm = TRUE)   # center so intercepts are at mean mwp
  )

# ---- 2) How much cross-study overlap do you actually have? ----
# (a) studies per species
studies_per_species <- df1 %>%
  distinct(species, study) %>%
  count(species, name = "n_studies") %>%
  arrange(desc(n_studies))

print(studies_per_species)

# (b) sample size per species x study (helps interpret identifiability)
n_by_species_study <- df1 %>%
  count(species, study, name = "n_obs") %>%
  arrange(desc(n_obs))

print(n_by_species_study)

# (c) quick summary: how many species have >1 study?
cat("\nSpecies with >1 study:",
    sum(studies_per_species$n_studies > 1),
    "out of", nrow(studies_per_species), "\n\n")

# ---- 3) Fit comparable models (both ML; required for LRT) ----
# IMPORTANT: Fit the "no random effect" model using lmer() too,
# so the likelihood ratio test is valid (nested models, same likelihood family).
m_fe_lmer <- lmer(ilfm ~ mwp_c * species, data = df1, REML = FALSE)
m_re      <- lmer(ilfm ~ mwp_c * species + (1 | study), data = df1, REML = FALSE)

# ---- 4) Compare models: LRT + AIC/BIC ----
# Likelihood ratio test for adding (1|study)
lrt <- anova(m_fe_lmer, m_re)
print(lrt)

# AIC / BIC comparison
aic_tab <- AIC(m_fe_lmer, m_re)
bic_tab <- BIC(m_fe_lmer, m_re)
print(aic_tab)
print(bic_tab)

delta_aic <- aic_tab$AIC[1] - aic_tab$AIC[2]
cat("\nDelta AIC (no RE minus RE) =", round(delta_aic, 2), "\n")

# Random-effect size + ICC
cat("\nVarCorr(m_re):\n")
print(VarCorr(m_re))
cat("\nIs singular?\n")
print(isSingular(m_re, tol = 1e-5))
cat("\nICC:\n")
print(performance::icc(m_re))

# ---- 5) Extract species-specific INTERCEPTS and SLOPES from both models ----
# We’ll use:
#   - emmeans(..., ~species, at = mwp_c = 0) for intercepts at mean mwp
#   - emtrends(..., ~species, var="mwp_c")   for slopes

get_species_effects <- function(model, model_label) {

  # intercepts at mean mwp (mwp_c = 0)
  ints <- emmeans(model, ~ species, at = list(mwp_c = 0)) %>%
    as.data.frame() %>%
    transmute(
      species,
      component = "Intercept (at mean mwp)",
      estimate = emmean,
      se = SE,
      lo = lower.CL,
      hi = upper.CL,
      model = model_label
    )

  # slopes w.r.t mwp_c
  slps <- emtrends(model, ~ species, var = "mwp_c") %>%
    as.data.frame() %>%
    transmute(
      species,
      component = "Slope (d ilfm / d mwp)",
      estimate = mwp_c.trend,
      se = SE,
      lo = lower.CL,
      hi = upper.CL,
      model = model_label
    )

  bind_rows(ints, slps)
}

effects_fe <- get_species_effects(m_fe_lmer, "No study RE")
effects_re <- get_species_effects(m_re,      "With study RE")

effects_all <- bind_rows(effects_fe, effects_re)

# ---- 6) Quantify “how different” the slopes/intercepts are ----
# Wide format to compare directly
effects_wide <- effects_all %>%
  select(species, component, model, estimate) %>%
  pivot_wider(names_from = model, values_from = estimate) %>%
  mutate(
    diff = `With study RE` - `No study RE`,
    abs_diff = abs(diff)
  )

print(effects_wide %>% arrange(component, desc(abs_diff)) %>% head(30))

# Correlation of estimates (robustness summary)
corr_slope <- effects_wide %>%
  filter(component == "Slope (d ilfm / d mwp)") %>%
  summarise(r = cor(`No study RE`, `With study RE`, use = "complete.obs")) %>%
  pull(r)

corr_int <- effects_wide %>%
  filter(component == "Intercept (at mean mwp)") %>%
  summarise(r = cor(`No study RE`, `With study RE`, use = "complete.obs")) %>%
  pull(r)

cat("\nCorrelation of species estimates (No RE vs With RE):\n",
    "  Intercepts r =", round(corr_int, 3), "\n",
    "  Slopes     r =", round(corr_slope, 3), "\n\n")

# ---- 7) Build the paired comparison figure ----
# Order species by the WITH-RE estimate (you can swap to No-RE if you prefer)
species_order <- effects_all %>%
  filter(component == "Slope (d ilfm / d mwp)", model == "With study RE") %>%
  arrange(estimate) %>%
  pull(species)

effects_plot <- effects_all %>%
  mutate(
    species = factor(as.character(species), levels = species_order),
    component = factor(component, levels = c("Intercept (at mean mwp)",
                                            "Slope (d ilfm / d mwp)")),
    model = factor(model, levels = c("No study RE", "With study RE"))
  )

p_compare <- ggplot(effects_plot,
                    aes(x = model, y = estimate, group = species)) +
  geom_line(alpha = 0.5) +
  geom_point(size = 1.9) +
  geom_errorbar(aes(ymin = lo, ymax = hi), width = 0.08, alpha = 0.35) +
  facet_wrap(~ component, scales = "free_y") +
  coord_flip() +
  labs(
    x = NULL,
    y = "Species-level estimate (± 95% CI)",
    title = "Sensitivity of species intercepts and slopes to adding a study random intercept"
  ) +
  theme_classic(base_size = 14) +
  theme(
    legend.position = "none",
    strip.background = element_blank()
  )

p_compare

# ---- 8) Save figure (edit path/name as desired) ----
# If you use here::here(), swap this for here("figures", ...)
ggsave(
  filename = "compare_species_intercepts_slopes_with_vs_without_studyRE.png",
  plot     = p_compare,
  width    = 8,
  height   = 7,
  units    = "in",
  dpi      = 300
)

```


######Use emmeans: 
```{r}
library(emmeans)
library(dplyr)
library(readr)
library(here)

# choose a meaningful reference mwp
mwp_ref <- mean(df1$mwp, na.rm = TRUE)

# ----------------------------
# Species-specific intercepts (iLFM)
# ----------------------------
emm_int <- emmeans(
  mod_spp_int,
  ~ species,
  at = list(mwp = mwp_ref)
) %>%
  as.data.frame() %>%
  rename(
    intercept_iLFM = emmean,
    intercept_iLFM_SE = SE,
    intercept_iLFM_lwr = lower.CL,
    intercept_iLFM_upr = upper.CL
  )

# ----------------------------
# Species-specific slopes (iLFM vs mwp)
# ----------------------------
emm_slp <- emtrends(
  mod_spp_int,
  ~ species,
  var = "mwp"
) %>%
  as.data.frame() %>%
  rename(
    slope_iLFM = mwp.trend,
    slope_iLFM_SE = SE,
    slope_iLFM_lwr = lower.CL,
    slope_iLFM_upr = upper.CL
  ) %>% 
  select(-df)

# ----------------------------
# Combine + convert to LFM space
# ----------------------------
table_species_params <- emm_int %>%
  left_join(emm_slp, by = "species") %>%
  mutate(
    # intercept conversion
    intercept_LFM = 100*(1 / intercept_iLFM),

    # slope conversion via delta method
    #slope_LFM = - 100*(slope_iLFM / (intercept_iLFM^2)),

    mwp_ref = mwp_ref
  ) %>%
  mutate(across(where(is.numeric), round, 4)) %>% 
  select(-df)

write_csv(
  table_species_params,
  here("results", "figures", "tableSX_species_intercept_slope_LFM.csv")
)

```


```{r}
library(lme4)
library(emmeans)
library(dplyr)
library(readr)
library(here)

# ============================
# Mixed-effects model (random intercept for study)
# ============================
mod_spp_int_re <- lmer(ilfm ~ mwp * species + (1 | study),
                      data = df1, REML = FALSE)

# choose a meaningful reference mwp
mwp_ref <- mean(df1$mwp, na.rm = TRUE)

# ----------------------------
# Species-specific intercepts (iLFM) at mwp_ref
#   (population-level; study random effect averaged over)
# ----------------------------
emm_int <- emmeans(
  mod_spp_int_re,
  ~ species,
  at = list(mwp = mwp_ref)
) %>%
  as.data.frame() %>%
  rename(
    intercept_iLFM     = emmean,
    intercept_iLFM_SE  = SE,
    intercept_iLFM_lwr = lower.CL,
    intercept_iLFM_upr = upper.CL
  ) %>%
  select(-df)

# ----------------------------
# Species-specific slopes (iLFM vs mwp)
# ----------------------------
emm_slp <- emtrends(
  mod_spp_int_re,
  ~ species,
  var = "mwp"
) %>%
  as.data.frame() %>%
  rename(
    slope_iLFM     = mwp.trend,
    slope_iLFM_SE  = SE,
    slope_iLFM_lwr = lower.CL,
    slope_iLFM_upr = upper.CL
  ) %>%
  select(-df)

# ----------------------------
# Combine + convert to LFM space
# ----------------------------
table_species_params <- emm_int %>%
  left_join(emm_slp, by = "species") %>%
  mutate(
    # intercept conversion: LFM (%) = 100 * (1 / iLFM)
    intercept_LFM = 100 * (1 / intercept_iLFM),

    # optional: slope conversion (local sensitivity at mwp_ref)
    # slope_LFM = -100 * slope_iLFM / (intercept_iLFM^2),

    mwp_ref = mwp_ref
  ) %>%
  mutate(across(where(is.numeric), round, 4))

write_csv(
  table_species_params,
  here("results", "figures", "tableSX_species_intercept_slope_LFM_mixed.csv")
)

```


######Bayesian forest plot: 
```{r}
# ============================================================
# Bayesian species-specific slopes + forest plot (credible intervals)
#   - Model estimates a separate slope for EACH species
#   - Optional random intercept for study
# ============================================================

#install.packages(c("brms", "tidybayes", "dplyr", "ggplot2", "readr", "forcats", "posterior"))
library(brms)
library(tidybayes)
library(dplyr)
library(ggplot2)
library(readr)
library(forcats)
library(posterior)

#install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
#cmdstanr::install_cmdstan()


# ---- load data ----

# ---- (recommended) scale mwp for stability/convergence ----
df1 <- df1 %>%
  mutate(
    species = as.factor(species),
    study   = as.factor(study),
    mwp_z   = as.numeric(scale(mwp))
  )

# ============================================================
# 1) Bayesian model: separate intercept AND slope per species
#    This parameterization avoids a reference species:
#      ilfm ~ 0 + species + 0 + mwp_z:species
#    Optional: + (1|study) for study-to-study shifts
# ============================================================

priors <- c(
  prior(normal(0, 1), class = "b"),          # slopes/intercepts on scaled mwp
  prior(student_t(3, 0, 1), class = "sigma") # residual SD
)

fit_spp_slopes <- brm(
  formula = ilfm ~ 0 + species + 0 + mwp_z:species + (1 | study),
  data    = df1,
  family  = gaussian(),
  prior   = priors,
  chains  = 4, cores = 4, iter = 4000, warmup = 1000,
  seed    = 123,
  control = list(adapt_delta = 0.99, max_treedepth = 15)
)

# quick checks
pp_check(fit_spp_slopes)
summary(fit_spp_slopes)

# ============================================================
# 2) Extract posterior draws for EACH species slope
#    Coefficient names look like: "mwp_z:speciesABCO" etc.
# ============================================================

library(tidybayes)
library(dplyr)
library(ggplot2)

# posterior draws for each species slope
slope_draws <- fit_spp_slopes %>%
  gather_draws(`^b_species.*:mwp_z$`, regex = TRUE) %>%
  mutate(
    species = gsub("^b_species", "", .variable),
    species = gsub(":mwp_z$", "", species)
  )

# summarize to median + 95% credible interval
forest_df <- slope_draws %>%
  group_by(species) %>%
  summarise(
    slope_med = median(.value),
    slope_lo  = quantile(.value, 0.025),
    slope_hi  = quantile(.value, 0.975),
    .groups   = "drop"
  ) %>%
  arrange(slope_med) %>%
  mutate(species = factor(species, levels = species))

# forest plot
draws_long <- slope_draws %>%
  transmute(.draw, species, slope = .value)

# Rebuild wide posterior draws
draws_wide <- draws_long %>%
  select(.draw, species, slope) %>%
  tidyr::pivot_wider(names_from = species, values_from = slope) %>%
  arrange(.draw)


draws_wide <- draws_long %>%
  pivot_wider(names_from = species, values_from = slope) %>%
  arrange(.draw)

# Drop .draw and FORCE numeric matrix
slope_mat <- draws_wide %>%
  select(-.draw) %>%
  as.data.frame() %>%
  mutate(across(everything(), as.numeric)) %>%
  as.matrix()

# sanity check
stopifnot(is.numeric(slope_mat))

sp <- colnames(slope_mat)

# Count NA values per species slope
na_counts <- colSums(is.na(slope_mat))
summary(na_counts)


library(posterior)
library(dplyr)
library(tidyr)
library(stringr)

# 1) Get ALL draws as a draws_df
d <- as_draws_df(fit_spp_slopes)

# 2) Grab the slope columns you showed: b_speciesXXXX:mwp_z
slope_cols <- grep("^b_species.*:mwp_z$", variables(d), value = TRUE)

# 3) Build a clean draws table: rows = posterior draws, cols = species
slope_df <- d %>%
  as.data.frame() 
all_vars <- variables(d)

slope_cols <- grep("^b_species.*:mwp_z$", all_vars, value = TRUE)

slope_cols

slope_df <- d %>%
  as.data.frame() %>%
  select(all_of(slope_cols))

new_names <- gsub("^b_species", "", slope_cols)
new_names <- gsub(":mwp_z$", "", new_names)

colnames(slope_df) <- new_names

slope_mat <- as.matrix(slope_df)
```

Posterior distributions, do they overlap with the median of the grand slope? 


```{r}
# install.packages(c("tidybayes", "ggridges", "dplyr", "ggplot2", "forcats"))
library(tidybayes)
library(dplyr)
library(ggplot2)
library(ggridges)
library(forcats)

# ----------------------------
# 1) Extract posterior draws for species-specific slopes
# ----------------------------
slope_draws <- fit_spp_slopes %>%
  gather_draws(`^b_species.*:mwp_z$`, regex = TRUE) %>%
  mutate(
    species = gsub("^b_species", "", .variable),
    species = gsub(":mwp_z$", "", species)
  ) %>%
  transmute(.draw, species, slope = .value)

# ----------------------------
# 2) Define "grand slope" posterior
#    (mean slope across species, per draw)
# ----------------------------
grand_draws <- slope_draws %>%
  group_by(.draw) %>%
  summarise(
    grand_slope = mean(slope, na.rm = TRUE),
    .groups = "drop"
  )

grand_med <- median(grand_draws$grand_slope)

# ----------------------------
# 3) Inferential flag:
#    species is "Different from grand" if
#    95% CrI of (species_slope - grand_slope) excludes 0
# ----------------------------
diff_flag <- slope_draws %>%
  left_join(grand_draws, by = ".draw") %>%
  mutate(diff = slope - grand_slope) %>%
  group_by(species) %>%
  summarise(
    diff_lo = quantile(diff, 0.025),
    diff_hi = quantile(diff, 0.975),
    med     = median(slope),
    .groups = "drop"
  ) %>%
  mutate(diff_from_grand = !(diff_lo <= 0 & diff_hi >= 0))

# ----------------------------
# 4) Order species by median slope
# ----------------------------
species_order <- diff_flag %>%
  arrange(med) %>%
  pull(species)

plot_df <- slope_draws %>%
  left_join(diff_flag %>% select(species, diff_from_grand), by = "species") %>%
  mutate(
    species = factor(species, levels = species_order),
    diff_from_grand = factor(
      diff_from_grand,
      levels = c(FALSE, TRUE),
      labels = c("Not different from grand", "Different from grand")
    )
  )

# ----------------------------
# 5) Ridgeline posterior plot
# ----------------------------
ggplot(plot_df, aes(x = slope, y = species, fill = diff_from_grand)) +
  geom_vline(xintercept = 0, linetype = 2, linewidth = 0.4) +
  geom_vline(xintercept = grand_med, linewidth = 0.6) +
  geom_density_ridges(
    scale = 2.2,
    rel_min_height = 0.01,
    alpha = 0.85,
    color = NA
  ) +
  labs(
    x = "Posterior of species slope (ilfm ~ mwp_z)",
    y = NULL,
    fill = NULL
  ) +
  theme_classic(base_size = 14) + 
  scale_fill_manual(values = c("grey80","black"
  ))

```
###### Color by genus

```{r, eval = F}
library(tidybayes)
library(dplyr)
library(ggplot2)
library(ggridges)
library(forcats)
library(stringr)

# ----------------------------
# 0) Genus lookup from SpCodes
#    expects columns: species, Genus
# ----------------------------
genus_lookup <- SpCodes %>%
  select(species = SpCode6, Genus) %>%
  distinct() %>%
  mutate(
    Genus = trimws(as.character(Genus)),
    Genus = ifelse(is.na(Genus) | Genus == "", "Unknown", Genus)
  )

# ----------------------------
# 1) Extract posterior draws for species-specific slopes
# ----------------------------
slope_draws <- fit_spp_slopes %>%
  gather_draws(`^b_species.*:mwp_z$`, regex = TRUE) %>%
  mutate(
    species = gsub("^b_species", "", .variable),
    species = gsub(":mwp_z$", "", species)
  ) %>%
  transmute(.draw, species, slope = .value)

# ----------------------------
# 2) Define "grand slope" posterior
#    (mean slope across species, per draw)
# ----------------------------
grand_draws <- slope_draws %>%
  group_by(.draw) %>%
  summarise(grand_slope = mean(slope, na.rm = TRUE), .groups = "drop")

grand_med <- median(grand_draws$grand_slope)

# ----------------------------
# 3) Inferential flag:
#    species is "Different from grand" if
#    95% CrI of (species_slope - grand_slope) excludes 0
# ----------------------------
diff_flag <- slope_draws %>%
  left_join(grand_draws, by = ".draw") %>%
  mutate(diff = slope - grand_slope) %>%
  group_by(species) %>%
  summarise(
    diff_lo = quantile(diff, 0.025),
    diff_hi = quantile(diff, 0.975),
    med     = median(slope),
    .groups = "drop"
  ) %>%
  mutate(diff_from_grand = !(diff_lo <= 0 & diff_hi >= 0)) %>%
  left_join(genus_lookup, by = "species")

# ----------------------------
# 4) Ordering:
#    - priority genera at TOP
#    - species ordered by median slope WITHIN genus
# ----------------------------
genus_priority <- c("Abies", "Pinus", "Pseudotsuga", "Calocedrus")

genus_priority <- genus_priority[genus_priority %in% unique(diff_flag$Genus)]

genus_order <- c(
  genus_priority,
  sort(setdiff(unique(diff_flag$Genus), genus_priority))
)

species_order_top_to_bottom <- diff_flag %>%
  mutate(Genus = factor(Genus, levels = genus_order)) %>%
  arrange(Genus, med) %>%
  pull(species)

# ggplot puts last level at the top → reverse
species_levels_for_plot <- rev(species_order_top_to_bottom)

# ----------------------------
# 5) Build plotting df
# ----------------------------
plot_df <- slope_draws %>%
  left_join(diff_flag %>% select(species, diff_from_grand, Genus), by = "species") %>%
  mutate(
    species = factor(species, levels = species_levels_for_plot),
    Genus   = factor(Genus, levels = genus_order),
    diff_from_grand = factor(
      diff_from_grand,
      levels = c(FALSE, TRUE),
      labels = c("Not different from grand", "Different from grand")
    )
  )

# ----------------------------
# 6) Axis text colors by Genus
#    (uses your existing genus_colors named vector)
# ----------------------------

genus_colors <- c(
  Abies          = "#17154f",
  Adenostoma     = "#2f357c",
  Arbutus        = "#6c5d9e",
  Arctostaphylos = "#9d9cd5",
  Calocedrus     = "#59385c",
  Ceanothus      = "#f6b3b0",
  Cercocarpus    = "#d8b847",
  Eriogonum      = "#bf3729",
  Heteromeles    = "#e69b00",
  Malosma        = "#f5bb50",
  Pinus          = "#ada43b",
  Pseudotsuga    = "#355828",
  Quercus        = "#df8d71",  # <-- pink, as requested
  Salvia         = "#d48f90",
  Umbellularia   = "#d8b847"
)



species_levels <- levels(plot_df$species)

species_levels <- levels(plot_df$species)

axis_y_cols <- diff_flag %>%
  distinct(species, Genus) %>%
  mutate(
    Genus = ifelse(is.na(Genus) | Genus == "", "Unknown", Genus),
    col   = unname(genus_colors[Genus]),
    col   = ifelse(is.na(col), "grey30", col)
  ) %>%
  slice(match(species_levels, species)) %>%   # <<< THIS is the key fix
  pull(col)


# ----------------------------
# 7) Ridgeline posterior plot
# ----------------------------
ggplot(plot_df, aes(x = slope, y = species, fill = diff_from_grand)) +
  geom_vline(xintercept = 0, linetype = 2, linewidth = 0.4) +
  geom_vline(xintercept = grand_med, linewidth = 0.6) +
  geom_density_ridges(
    scale = 2.2,
    rel_min_height = 0.01,
    alpha = 0.85,
    color = NA
  ) +
  scale_fill_manual(values = c("grey80", "black")) +
  labs(
    x = "Posterior of species slope (ilfm ~ mwp_z)",
    y = NULL,
    fill = NULL
  ) +
  theme_classic(base_size = 14) +
  theme(
    legend.position = "top",
    axis.text.y = element_text(color = axis_y_cols)
  ) + theme(axis.text.y = element_text(color = axis_y_cols))

```

#Fig. 2: Genus but ordered correctly
```{r}
library(tidybayes)
library(dplyr)
library(ggplot2)
library(ggridges)
library(forcats)
library(stringr)

# ----------------------------
# 0) Genus lookup from SpCodes
#    expects columns: SpCode6, Genus
# ----------------------------
genus_lookup <- SpCodes %>%
  select(species = SpCode6, Genus) %>%
  distinct() %>%
  mutate(
    Genus = trimws(as.character(Genus)),
    Genus = ifelse(is.na(Genus) | Genus == "", "Unknown", Genus)
  )

# ----------------------------
# 1) Extract posterior draws for species-specific slopes
# ----------------------------
slope_draws <- fit_spp_slopes %>%
  gather_draws(`^b_species.*:mwp_z$`, regex = TRUE) %>%
  mutate(
    species = gsub("^b_species", "", .variable),
    species = gsub(":mwp_z$", "", species)
  ) %>%
  transmute(.draw, species, slope = .value)

# ----------------------------
# 2) Define "grand slope" posterior (mean across species, per draw)
# ----------------------------
grand_draws <- slope_draws %>%
  group_by(.draw) %>%
  summarise(grand_slope = mean(slope, na.rm = TRUE), .groups = "drop")

grand_med <- median(grand_draws$grand_slope)

# ----------------------------
# 3) Inferential flag: different from grand if 95% CrI of (slope - grand) excludes 0
# ----------------------------
diff_flag <- slope_draws %>%
  left_join(grand_draws, by = ".draw") %>%
  mutate(diff = slope - grand_slope) %>%
  group_by(species) %>%
  summarise(
    diff_lo = quantile(diff, 0),
    diff_hi = quantile(diff, 1),
    mean    = mean(slope),          # <-- posterior mean for ordering
    med     = median(slope),
    .groups = "drop"
  ) %>%
  mutate(diff_from_grand = !(diff_lo <= 0 & diff_hi >= 0)) %>%
  left_join(genus_lookup, by = "species")

# ----------------------------
# 4) Ordering: by posterior MEAN only (no genus blocking)
# ----------------------------
species_order_top_to_bottom <- diff_flag %>%
  arrange(desc(mean)) %>%      # use arrange(desc(mean)) if you want highest at top
  pull(species)

# ggplot puts last level at the top → reverse
species_levels_for_plot <- rev(species_order_top_to_bottom)

# ----------------------------
# 5) Build plotting df
# ----------------------------
plot_df <- slope_draws %>%
  left_join(diff_flag %>% select(species, diff_from_grand, Genus), by = "species") %>%
  mutate(
    species = factor(species, levels = species_levels_for_plot),
    diff_from_grand = factor(
      diff_from_grand,
      levels = c(FALSE, TRUE),
      labels = c("Not different from grand", "Different from grand")
    )
  )

# ----------------------------
# 6) Axis text colors by Genus (fixed mapping)
# ----------------------------
genus_colors <- c(
  Abies          = "#17154f",
  Adenostoma     = "#8E3B46",
  Arbutus        = "#6c5d9e",
  Arctostaphylos = "#9d9cd5",
  Calocedrus     = "#59385c",
  Ceanothus      = "#2C7FB8",
  Cercocarpus    = "#d8b847",
  Eriogonum      = "#bf3729",
  Heteromeles    = "#e69b00",
  Malosma        = "#f5bb50",
  Pinus          = "#ada43b",
  Pseudotsuga    = "#355828",
  Quercus        = "#D1495B",
  Salvia         = "#d48f90",
  Umbellularia   = "#d8b847"
)

# genus_colors <- c(
#   Abies          = "#203A8F",  # sapphire
#   Adenostoma     = "#6F2DBD",  # amethyst
#   Arbutus        = "#1B7F5A",  # jade
#   Arctostaphylos = "#B45F2A",  # terracotta
#   Calocedrus     = "#2F2F2F",  # charcoal
#   Ceanothus      = "#D1495B",  # raspberry
#   Cercocarpus    = "#E6A23C",  # amber
#   Eriogonum      = "#8E3B46",  # mulberry
#   Heteromeles    = "#2C7FB8",  # steel blue
#   Malosma        = "#7D9A44",  # olive
#   Pinus          = "#2E6B3D",  # conifer green
#   Pseudotsuga    = "#0F2E3F",  # deep teal/navy
#   Quercus        = "#C97C5D",  # warm clay
#   Salvia         = "#6D597A",  # dusty purple
#   Umbellularia   = "#8C6D3F"   # bronze
# )



species_levels <- levels(plot_df$species)

axis_y_cols <- diff_flag %>%
  distinct(species, Genus) %>%
  mutate(
    Genus = ifelse(is.na(Genus) | Genus == "", "Unknown", Genus),
    col   = unname(genus_colors[Genus]),
    col   = ifelse(is.na(col), "grey30", col)
  ) %>%
  slice(match(species_levels, species)) %>%
  pull(col)

# ----------------------------
# 7) Ridgeline posterior plot
# ----------------------------
p_slopes <- ggplot(plot_df, aes(x = slope, y = species, fill = diff_from_grand)) +
  geom_vline(xintercept = 0, linetype = 2, linewidth = 0.4) +
  geom_vline(xintercept = grand_med, linewidth = 0.6) +
  geom_density_ridges(
    scale = 2.2,
    rel_min_height = 0.01,
    alpha = 0.85,
    color = NA
  ) +
  scale_fill_manual(values = c("grey60", "black")) +
  xlim(-0.55, 0.275) +
  labs(
    x = expression("Posterior of species slope (ilfm ~ " * italic(Psi)[MD] * ")"),
    y = NULL,
    fill = NULL
  ) +
  theme_classic(base_size = 14) +
  theme(axis.text.y = element_text(color = axis_y_cols),
        legend.position = "top") + theme(
    axis.text.y = element_text(
      color = axis_y_cols,
      face  = "bold",
      size  = 11
    )
)

ggsave(
  filename = here("figures", "species_slope_posteriors_by_genus.png"),
  plot     = p_slopes,
  width    = 6,
  height   = 5,
  units    = "in",
  dpi      = 300
)
```


##### Not ridge plots: 
```{r, eval = F}
# slope_mat: matrix of posterior draws, columns = species slopes
grand_draw <- rowMeans(slope_mat)  # one value per posterior draw
grand_lo   <- quantile(grand_draw, 0.025)
grand_hi   <- quantile(grand_draw, 0.975)
grand_med  <- median(grand_draw)

c(grand_lo = grand_lo, grand_med = grand_med, grand_hi = grand_hi)

library(dplyr)
library(ggplot2)
library(forcats)

# Summarize species slope CrIs from slope_mat
forest_df <- tibble(species = colnames(slope_mat)) %>%
  rowwise() %>%
  mutate(
    slope_med = median(slope_mat[, species]),
    slope_lo  = quantile(slope_mat[, species], 0.025),
    slope_hi  = quantile(slope_mat[, species], 0.975)
  ) %>%
  ungroup() %>%
  mutate(
    # use the UNWEIGHTED grand interval:
    overlaps_grand = !(slope_hi < grand_lo | slope_lo > grand_hi),
    species = fct_reorder(species, slope_med)
  )

ggplot(forest_df, aes(y = species, x = slope_med, color = overlaps_grand)) +
  geom_vline(xintercept = grand_med, linetype = 2, linewidth = 0.4) +
  geom_errorbarh(aes(xmin = slope_lo, xmax = slope_hi), height = 0, linewidth = 0.6) +
  geom_point(size = 2.3) +
  labs(
    x = "Species slope of ilfm ~ mwp_z (posterior median ± 95% CrI)",
    y = NULL
  ) +
  theme_classic(base_size = 14) + theme(legend.position = "none")

```

```{r, eval = F}
# posterior draws of grand mean (same as you have)
grand_draw <- rowMeans(slope_mat, na.rm = TRUE)

# posterior probability each species is greater than the grand mean
p_gt_grand <- apply(slope_mat, 2, function(x) mean(x > grand_draw, na.rm = TRUE))

# two-sided probability of being different from grand (direction-agnostic)
p_diff_grand <- 2 * pmin(p_gt_grand, 1 - p_gt_grand)

# flag as "different" at 95% posterior probability (analog of p<0.05)
diff_from_grand_95 <- p_diff_grand < 0.05

forest_df <- forest_df %>%
  mutate(
    p_diff_grand = p_diff_grand[as.character(species)],
    diff_from_grand_95 = diff_from_grand_95[as.character(species)]
  )

ggplot(forest_df, aes(y = species, x = slope_med, shape = diff_from_grand_95)) +
  geom_vline(xintercept = median(grand_draw), linetype = 2, linewidth = 0.4) +
  geom_errorbarh(aes(xmin = slope_lo, xmax = slope_hi), height = 0, linewidth = 0.6, color = "black") +
  geom_point(size = 2.3, color = "black") +
  scale_shape_manual(values = c(`FALSE` = 16, `TRUE` = 1)) +  # filled = not different, open = different
  labs(x = "Species slope of ilfm ~ mwp_z (posterior median ± 95% CrI)", y = NULL) +
  theme_classic(base_size = 14) +
  theme(legend.position = "none")

```

Color by leaf habit: 
```{r, eval = F}
forest_df1 <- forest_df %>%
  left_join(table1_df, by = "species")

leaf_colors <- c(
  Ever = "#1b9e77",
  Dec = "#d95f02",
  "Semi-Dec" = "#7570b3"  # optional
)


forest_df2 <- forest_df %>%
  left_join(table1_df, by = "species") %>%
  mutate(
    species_label = paste0(
      "<span style='color:",
      leaf_colors[as.character(dec_ever)],
      "'>",
      species,
      "</span>"
    ),
    species = fct_reorder(species, slope_med)
  )

# IMPORTANT: named labels (names must match the factor levels in y)
species_labels <- setNames(forest_df2$species_label, forest_df2$species)

ggplot(
  forest_df2,
  aes(y = species, x = slope_med, shape = overlaps_grand)
) +
  geom_vline(xintercept = grand_med, linetype = 2, linewidth = 0.4) +
  geom_errorbarh(
    aes(xmin = slope_lo, xmax = slope_hi),
    height = 0,
    linewidth = 0.6,
    color = "black"
  ) +
  geom_point(size = 2.3, color = "black") +
  scale_shape_manual(values = c(`TRUE` = 16, `FALSE` = 1)) +
  scale_y_discrete(labels = species_labels) +
  labs(x = "Slope (posterior median ± 95% CrI)", y = NULL) +
  theme_classic(base_size = 14) +
  theme(
    legend.position = "none",
    axis.text.y = element_markdown()
  )

```
Color by genus: 
```{r, eval = F}
forest_df1 <- forest_df %>%
  left_join(table1_df, by = "species")

family_colors <- c(
  Pinaceae      = "darkgreen",
  Cupressaceae  = "darkblue",
  Fagaceae      = "#d95f02",
  Rosaceae      = "#e7298a",
  Ericaceae     = "#7570b3",
  Lauraceae     = "#a6761d",
  Rhamnaceae    = "#1f78b4",
  Polygonaceae  = "#b2df8a",
  Anacardiaceae = "#fb9a99",
  Lamiaceae     = "#cab2d6"
)

library(dplyr)
library(forcats)
library(ggplot2)
library(ggtext)

forest_df2 <- forest_df %>%
  left_join(table1_df, by = "species") %>%
  mutate(
    family = trimws(as.character(family)),
    species_label = paste0(
      "<span style='color:",
      family_colors[family],
      "'>",
      species,
      "</span>"
    ),
    # RECOMPUTE overlap here (must have grand_lo and grand_hi defined)
    overlaps_grand = !(slope_hi < grand_lo | slope_lo > grand_hi),
    # force to two-level factor so both shapes can appear
    overlaps_grand = factor(overlaps_grand, levels = c(FALSE, TRUE)),
    species = fct_reorder(species, slope_med)
  )

species_labels <- setNames(forest_df2$species_label, forest_df2$species)

# quick check: do you actually have both TRUE and FALSE?
table(forest_df2$overlaps_grand, useNA = "ifany")

species_labels <- setNames(forest_df2$species_label, forest_df2$species)


ggplot(forest_df2, aes(y = species, x = slope_med, shape = overlaps_grand)) +
  geom_vline(xintercept = grand_med, linetype = 2, linewidth = 0.4) +
  geom_errorbarh(aes(xmin = slope_lo, xmax = slope_hi),
                 height = 0, linewidth = 0.6, color = "black") +
  geom_point(size = 2.3, color = "black") +
  scale_shape_manual(values = c(`FALSE` = 1, `TRUE` = 16), drop = FALSE) +
  scale_y_discrete(labels = species_labels) +
  labs(x = "Slope (posterior median ± 95% CrI)", y = NULL) +
  theme_classic(base_size = 14) +
  theme(legend.position = "none",
        axis.text.y = element_markdown())

```

Add grand slope without the pinaceae or cade: 
```{r}
# --- Grand slope 1: all species (unweighted mean across species per draw) ---
grand_draw_all <- rowMeans(slope_mat, na.rm = TRUE)
grand_med_all  <- median(grand_draw_all)
grand_lo_all   <- quantile(grand_draw_all, 0.025)
grand_hi_all   <- quantile(grand_draw_all, 0.975)

# --- Grand slope 2: exclude selected species ---
exclude_spp <- c("PINJEF", "ABICON", "CALDEC", "PSEMEN")  # note: you wrote CADEC; your data uses CALDEC
keep_cols <- setdiff(colnames(slope_mat), exclude_spp)

grand_draw_excl <- rowMeans(slope_mat[, keep_cols, drop = FALSE], na.rm = TRUE)
grand_med_excl  <- median(grand_draw_excl)
grand_lo_excl   <- quantile(grand_draw_excl, 0.025)
grand_hi_excl   <- quantile(grand_draw_excl, 0.975)


forest_df2 <- forest_df %>%
  left_join(table1_df, by = "species") %>%
  mutate(
    family = trimws(as.character(family)),
    species_label = paste0(
      "<span style='color:",
      family_colors[family],
      "'>",
      species,
      "</span>"
    ),
    # RECOMPUTE overlap here (must have grand_lo and grand_hi defined)
    overlaps_grand = !(slope_hi < grand_lo_all | slope_lo > grand_hi_all),

    # force to two-level factor so both shapes can appear
    overlaps_grand = factor(overlaps_grand, levels = c(FALSE, TRUE)),
    species = fct_reorder(species, slope_med)
  ) %>%
  mutate(
    overlaps_grand_excl = !(slope_hi < grand_lo_excl | slope_lo > grand_hi_excl),
    overlaps_grand_excl = factor(overlaps_grand_excl, levels = c(FALSE, TRUE))
  )


species_labels <- setNames(forest_df2$species_label, forest_df2$species)

# quick check: do you actually have both TRUE and FALSE?
table(forest_df2$overlaps_grand, useNA = "ifany")

species_labels <- setNames(forest_df2$species_label, forest_df2$species)


ggplot(forest_df2, aes(y = species, x = slope_med, shape = overlaps_grand)) +
  geom_vline(xintercept = grand_med_all,  linetype = 2, linewidth = 0.4) +
  geom_vline(xintercept = grand_med_excl, linetype = 3, linewidth = 0.4) +
  geom_errorbarh(aes(xmin = slope_lo, xmax = slope_hi),
                 height = 0, linewidth = 0.6, color = "black") +
  geom_point(size = 2.3, color = "black") +
  scale_shape_manual(values = c(`FALSE` = 1, `TRUE` = 16), drop = FALSE) +
  scale_y_discrete(labels = species_labels) +
  labs(x = "Slope (posterior median ± 95% CrI)", y = NULL) +
  theme_classic(base_size = 14) +
  theme(
    legend.position = "none",
    axis.text.y = element_markdown()
  )

ggplot(forest_df2, aes(y = species, x = slope_med)) +
  geom_vline(xintercept = grand_med_all,  linetype = 2, linewidth = 0.4) +
  geom_vline(xintercept = grand_med_excl, linetype = 3, linewidth = 0.4) +
  geom_errorbarh(aes(xmin = slope_lo, xmax = slope_hi),
                 height = 0, linewidth = 0.6, color = "black") +
  geom_point(
    aes(
      shape = overlaps_grand,
      color = overlaps_grand_excl
    ),
    size = 2.3,
    stroke = 1.1,
    fill = "white"   # so only outline color matters
  ) +
  scale_shape_manual(values = c(`FALSE` = 1, `TRUE` = 16), drop = FALSE) +
  scale_color_manual(values = c(`FALSE` = "black", `TRUE` = "dodgerblue3"), drop = FALSE) +
  scale_y_discrete(labels = species_labels) +
  labs(x = "Slope (posterior median ± 95% CrI)", y = NULL) +
  theme_classic(base_size = 14) +
  theme(
    legend.position = "none",
    axis.text.y = element_markdown()
  )

```

#Fig SX: Forest plot of intercepts: 

```{r}
# ============================================================
# Fig: Species intercept posteriors (ridgelines), genus-colored axis labels
#   - ordered by posterior MEAN (no genus blocking)
#   - grand line = mean across species per draw
#   - fill = "Different from grand" if 95% CrI of (intercept - grand) excludes 0
# ============================================================

library(tidybayes)
library(dplyr)
library(ggplot2)
library(ggridges)
library(forcats)
library(stringr)

# ----------------------------
# 0) Genus lookup from SpCodes
#    expects columns: SpCode6, Genus
# ----------------------------
genus_lookup <- SpCodes %>%
  select(species = SpCode6, Genus) %>%
  distinct() %>%
  mutate(
    Genus = trimws(as.character(Genus)),
    Genus = ifelse(is.na(Genus) | Genus == "", "Unknown", Genus)
  )

# ----------------------------
# 1) Extract posterior draws: species-specific intercepts
# ----------------------------
int_draws <- fit_spp_slopes %>%
  gather_draws(`^b_species[^:]+$`, regex = TRUE) %>%
  mutate(species = gsub("^b_species", "", .variable)) %>%
  transmute(.draw, species, intercept = .value)

# ----------------------------
# 2) "Grand intercept" posterior (mean across species, per draw)
# ----------------------------
grand_draws <- int_draws %>%
  group_by(.draw) %>%
  summarise(grand_int = mean(intercept, na.rm = TRUE), .groups = "drop")

grand_med <- median(grand_draws$grand_int)

# ----------------------------
# 3) Flag: different from grand if 95% CrI of (intercept - grand) excludes 0
# ----------------------------
diff_flag <- int_draws %>%
  left_join(grand_draws, by = ".draw") %>%
  mutate(diff = intercept - grand_int) %>%
  group_by(species) %>%
  summarise(
    diff_lo = quantile(diff, 0),
    diff_hi = quantile(diff, 1),
    mean    = mean(intercept),
    med     = median(intercept),
    .groups = "drop"
  ) %>%
  mutate(diff_from_grand = !(diff_lo <= 0 & diff_hi >= 0)) %>%
  left_join(genus_lookup, by = "species")

# ----------------------------
# 4) Ordering: by posterior MEAN only (no genus blocking)
# ----------------------------
species_order_top_to_bottom <- diff_flag %>%
  arrange(desc(mean)) %>%
  pull(species)

species_levels_for_plot <- rev(species_order_top_to_bottom)  # ggplot puts last at top

# ----------------------------
# 5) Build plotting df
# ----------------------------
plot_df <- int_draws %>%
  left_join(diff_flag %>% select(species, diff_from_grand, Genus), by = "species") %>%
  mutate(
    species = factor(species, levels = species_levels_for_plot),
    diff_from_grand = factor(
      diff_from_grand,
      levels = c(FALSE, TRUE),
      labels = c("Not different from grand", "Different from grand")
    )
  )

# ----------------------------
# 6) Axis text colors by Genus (your fixed mapping)
# ----------------------------
genus_colors <- c(
  Abies          = "#17154f",
  Adenostoma     = "#8E3B46",
  Arbutus        = "#6c5d9e",
  Arctostaphylos = "#9d9cd5",
  Calocedrus     = "#59385c",
  Ceanothus      = "#2C7FB8",
  Cercocarpus    = "#d8b847",
  Eriogonum      = "#bf3729",
  Heteromeles    = "#e69b00",
  Malosma        = "#f5bb50",
  Pinus          = "#ada43b",
  Pseudotsuga    = "#355828",
  Quercus        = "#D1495B",
  Salvia         = "#d48f90",
  Umbellularia   = "#d8b847"
)

species_levels <- levels(plot_df$species)

axis_y_cols <- diff_flag %>%
  distinct(species, Genus) %>%
  mutate(
    Genus = ifelse(is.na(Genus) | Genus == "", "Unknown", Genus),
    col   = unname(genus_colors[Genus]),
    col   = ifelse(is.na(col), "grey30", col)
  ) %>%
  slice(match(species_levels, species)) %>%
  pull(col)

# ----------------------------
# 7) Choose x-limits from the posterior (prevents hard-coding)
# ----------------------------
x_lo <- quantile(plot_df$intercept, 0.00, na.rm = TRUE)
x_hi <- quantile(plot_df$intercept, 1, na.rm = TRUE)

# ----------------------------
# 8) Ridgeline posterior plot (INTERCEPTS)
# ----------------------------
p_intercepts <- ggplot(plot_df, aes(x = intercept, y = species, fill = diff_from_grand)) +
  geom_vline(xintercept = 0, linetype = 2, linewidth = 0.4) +
  geom_vline(xintercept = grand_med, linewidth = 0.6) +
  geom_density_ridges(
    scale = 2.2,
    rel_min_height = 0.01,
    alpha = 0.85,
    color = NA
  ) +
  scale_fill_manual(values = c("grey60", "black")) +
  coord_cartesian(xlim = c(x_lo, x_hi)) +
  labs(
    x = "Posterior of species intercept (ilfm at mean-scaled ΨMD)",
    y = NULL,
    fill = NULL
  ) +
  theme_classic(base_size = 14) +
  theme(
    legend.position = "top",
    axis.text.y = element_text(color = axis_y_cols, face = "bold", size = 11)
  )

p_intercepts

ggsave(
  filename = here("figures", "species_intercept_posteriors_by_genus.png"),
  plot     = p_intercepts,
  width    = 6,
  height   = 5,
  units    = "in",
  dpi      = 300
)

```

#Predict:

```{r}
library(dplyr)
library(broom)
library(tidyr)
library(purrr)

# Fit the models
mod_common_slope <- glm(ilfm ~ mwp + species, data = df1, family = gaussian)
mod_species_interaction <- glm(ilfm ~ mwp * species, data = df1, family = gaussian)
mod_species_study <- glm(ilfm ~ mwp * sp_site, data = df1, family = gaussian)

# Helper to extract coefficients and label the model
extract_model_info <- function(model, model_name) {
  tidy(model) %>%
    mutate(model = model_name)
}

# Combine all model coefficients
model_coeffs <- bind_rows(
  extract_model_info(mod_common_slope, "common_slope"),
  extract_model_info(mod_species_interaction, "species_interaction"),
  extract_model_info(mod_species_study, "species_site_interaction")
)

# Utility to get baseline level of factor variable (alphabetical if not set)
baseline_level <- function(var) levels(factor(var))[1]

# Function to compute slope and intercept per group
compute_group_terms <- function(model, group_var, model_type) {
  group_list <- unique(df1[[group_var]])
  base_group <- baseline_level(df1[[group_var]])

  map_dfr(group_list, function(grp) {
    # Start with base intercept and slope
    intercept <- coef(model)[["(Intercept)"]]
    slope <- coef(model)[["mwp"]]

    if (grp != base_group) {
      int_term <- paste0(group_var, grp)
      slope_term <- paste0("mwp:", group_var, grp)

      if (int_term %in% names(coef(model))) {
        intercept <- intercept + coef(model)[[int_term]]
      }

      if (slope_term %in% names(coef(model))) {
        slope <- slope + coef(model)[[slope_term]]
      }
    }

    tibble(
      group = grp,
      intercept = intercept,
      slope = slope,
      model = model_type
    )
  })
}

# Get results for each model
coefs_common <- compute_group_terms(mod_common_slope, "species", "common_slope") %>% rename(species = group)

coefs_species_int <- compute_group_terms(mod_species_interaction, "species", "species_interaction") %>% rename(species = group)

coefs_species_study <- compute_group_terms(mod_species_study, "sp_site", "species_site_interaction") %>% rename(sp_study = group)%>% 
  separate_wider_delim(sp_study, names = c("species", "study"), "_") 
  

# Combine into one dataframe
coef_compare_df  <- bind_rows(coefs_common, coefs_species_int, coefs_species_study) %>% 
  mutate(group = case_when(
    model %in% c("species_interaction") ~ "species",
    model %in% c("common_slope") ~ "grand",
    model %in% c("species_site_interaction") ~ "sp_study",
  )) %>% 
  select(-study)

range(coefs_species_int$slope)

#Make unique dataframes per analysis with spp info
concept_both_df <- merge(coef_compare_df, df1, by = c("species"), all = T) %>% 
  filter(!(model == "species_site_interaction")) %>% 
  merge(sp_info) %>% 
  clean_names()

concept_study_df <- merge(coef_compare_df, df1, by = c("species"), all = T) %>% 
  filter(model == "species_site_interaction")  %>% 
  merge(sp_info)%>% 
  clean_names()

concept_df_all <- bind_rows(concept_both_df, concept_study_df)  %>% 
  clean_names() %>% 
  write_csv(here::here("data", "concept_df.csv"))

concept_df <- concept_df_all %>% 
  filter(group == "grand")  %>% 
  clean_names()
```

predict with species-specific slope:
```{r, predict}
# Predict water potential (mwp) for each sp_site
df_pred <- df1 %>%
  left_join(coefs_species_int, by = "species") %>%  # Merge coefficients, using separate slope and intercept per species
  mutate(
    mwp_pred = (ilfm - intercept) / slope,  # Solve for mwp using linear equation
   # lfm_pred = 1 / ilfm,  # Transform ilfm back to lfm
    lfm_pred = 1/(slope * mwp + intercept)  # Transform ilfm back to lfm
  ) 
  
# Plot predicted vs original lfm
ggplot(df_pred, aes(x = mwp, y = mwp_pred, color = sp_site)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original Water Potential",
    y = "Predicted Water Potential",
    title = "Predicted vs Original Water Potential"
  ) +
  theme_minimal()

# Plot predicted vs original lfm
ggplot(df_pred, aes(x = lfm, y = lfm_pred, color = sp_site)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original LFM",
    y = "Predicted LFM",
    title = "Predicted vs Original LFM"
  ) +
  theme_minimal()
```
predict with species and study-specific slope:
```{r, predict}
# Predict water potential (mwp) for each sp_site
df_pred <- df1 %>%
  left_join(coefs_species_study, by = "species") %>%  # Merge coefficients, using separate slope and intercept per species
  mutate(
    mwp_pred = (ilfm - intercept) / slope,  # Solve for mwp using linear equation
   # lfm_pred = 1 / ilfm,  # Transform ilfm back to lfm
    lfm_pred = 1/(slope * mwp + intercept)  # Transform ilfm back to lfm
  ) 
  
# Plot predicted vs original lfm
ggplot(df_pred, aes(x = mwp, y = mwp_pred, color = sp_site)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original Water Potential",
    y = "Predicted Water Potential",
    title = "Predicted vs Original Water Potential"
  ) +
  theme_minimal()

# Plot predicted vs original lfm
ggplot(df_pred, aes(x = lfm, y = lfm_pred, color = sp_site)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original LFM",
    y = "Predicted LFM",
    title = "Predicted vs Original LFM"
  ) +
  theme_minimal()
```

Predict with common slope:

```{r, predict}
#-----------
# Predict water potential (mwp) for each sp_site
df_pred <- df1 %>%
  left_join(coefs_common, by = "species") %>%  # Merge coefficients, using separate slope and intercept per species
  mutate(
    mwp_pred = (ilfm - intercept) / slope,  # Solve for mwp using linear equation
   # lfm_pred = 1 / ilfm,  # Transform ilfm back to lfm
    lfm_pred = 1/(slope * mwp + intercept)  # Transform ilfm back to lfm
  ) 
  
# Plot predicted vs original lfm
ggplot(df_pred, aes(x = mwp, y = mwp_pred, color = species, label = species)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original Water Potential",
    y = "Predicted Water Potential",
    title = "Predicted vs Original Water Potential"
  ) +
  theme_minimal()

# Plot predicted vs original lfm
ggplot(df_pred, aes(x = lfm, y = lfm_pred, color = species,
                    label = species)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original LFM",
    y = "Predicted LFM",
    title = "Predicted vs Original LFM"
  ) +
  theme_minimal()
```

#Model figs (Fig 3)
#####Figure 3. (models)
```{r, fig.height=5, fig.width=7}
# Define color palette for sites (color-blind friendly)
color_manual <- scale_color_manual(values  = c(
  "Pepperwood" = "#009E73",  # Green
  "StuntRanch" = "#E69F00",  # Orange
  "SEKI"       = "#56B4E9",  # Blue
  "Sedgwick"   = "#D55E00"))   # Red

# Identify the least negative (maximum) observed mwp per species
species_thresholds <- concept_both_df %>%
  filter(group == "grand") %>%
  group_by(species) %>%
  summarise(min_mwp = max(mwp, na.rm = TRUE), .groups = "drop")

# Generate model-predicted lines for each species and study
model_lines <- concept_df %>%
  filter(group == "grand") %>% 
  distinct(species, study, intercept, slope) %>%  
  group_by(species, study) %>%
  tidyr::expand_grid(mwp = seq(min(concept_df$mwp, na.rm = TRUE), max(concept_df$mwp, na.rm = TRUE), length.out = 100)) %>%
  left_join(species_thresholds, by = "species") %>%  
  mutate(
    ilfm_pred = intercept + slope * mwp,  
    line_type = ifelse(mwp > min_mwp, "dashed", "solid")  
  ) %>%
  ungroup()

# Separate data for solid and dashed lines
model_lines_solid <- model_lines %>% filter(line_type == "solid")
model_lines_dashed <- model_lines %>% filter(line_type == "dashed")

# Scatter plot of ilfm vs mwp with model lines
fig3a <- ggplot(concept_df %>%
  filter(group == "grand"), aes(x = -1 * mwp, y = ilfm)) +
  geom_point(aes(color = species), alpha = 0.3, color = "black") +  
  geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = ilfm_pred, color = study, group = interaction(species, study)), size = 0.5) +  
  geom_line(data = model_lines_dashed, aes(x = -1 * mwp, y = ilfm_pred, color = study, group = interaction(species, study)), size = 0.5, linetype = "dashed") +  
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    color = "Study"
  ) +
  color_manual +
  theme(legend.position = "none")

# Scatter plot of lfm vs mwp with model lines
fig3b <- ggplot(concept_df %>%
  filter(group == "grand"), aes(x = -1 * mwp, y = lfm)) +
  geom_point(aes(color = species), alpha = 0.3, color = "black") +  
  geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = interaction(species, study)), size = 0.5) +  
  geom_line(data = model_lines_dashed, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = interaction(species, study)), size = 0.5, linetype = "dashed") +  
  labs(
    x = "Water Potential (MPa)",
    y = "LFM",
    color = "Study"
  ) +
  color_manual +
  theme(legend.position = "none")

# Extract legend
legend <- cowplot::get_legend(
  ggplot(concept_df %>%
    filter(group == "grand"), aes(x = -1 * mwp, y = lfm)) +
    geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = interaction(species, study)), size = 0.5) +
    geom_line(data = model_lines_dashed, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = interaction(species, study)), size = 0.5, linetype = "dashed") +
    labs(color = "Study") +
    color_manual
)

# Combine plots
fig3.1 <- cowplot::plot_grid(fig3a, fig3b, nrow = 2)
fig3 <- cowplot::plot_grid(fig3.1, legend, nrow = 1, rel_widths = c(1, 0.25))
fig3

ggsave(plot = fig3, here::here("figures", "fig3.jpg"), dpi = 600, height = 4, width = 6, units = "in")
```


```{r, figure1}



# Generate model-predicted lines for each species
model_lines <- concept_df %>%
  filter(group == "grand") %>% 
  distinct(species,intercept, slope) %>%  # Get unique specie
  group_by(species) %>%
  summarise(
    mwp = seq(min(concept_df$mwp, na.rm = TRUE), max(concept_df$mwp, na.rm = TRUE), length.out = 100), # Generate x values
    ilfm_pred = intercept + slope * mwp,  # Compute predicted y values
    species = unique(species),  # Retain study info for coloring
    .groups = "drop"
  ) 


# Scatter plot of ilfm vs mwp with model lines
fig3a <- ggplot(concept_df %>%
  filter(group == "grand"), aes(x = -1*mwp, y = ilfm)) +
  geom_point(aes(color = species), alpha = 0.5) +  # Scatter points colored by species
  geom_line(data = model_lines, aes(x = -1*mwp, y = ilfm_pred, color = species), size = 0.5) +  # Model lines colored by study
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    title = "Model fits with species intercept and common slope",
    color = "Study"
  ) +
  color_species + 
  #theme_minimal() +
  theme(legend.position = "false") 

# Scatter plot of ilfm vs mwp with model lines
fig3b <- ggplot(concept_df %>%
  filter(group == "grand"), aes(x = -1*mwp, y = lfm)) +
  geom_point(aes(color = species), alpha = 0.5) +  # Scatter points colored by species
  geom_line(data = model_lines, aes(x = -1*mwp, y = 1/ilfm_pred, color = species), size = .5) +  # Model lines colored by study
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    #title = "Model fits with species intercept and common slope",
    color = "Study"
  ) +
  #theme_minimal() +
  color_species + 
  theme(legend.position = "false")

fig3 <- cowplot::plot_grid(fig3a, fig3b, nrow = 2)
fig3


# Extract legend
legend <- cowplot::get_legend(
  ggplot(concept_df %>%
    filter(group == "grand"), aes(x = -1 * mwp, y = lfm)) +
    geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = species, group = interaction(species, study)), size = 0.5) +
    labs(color = "Study") +
    color_species
)

# Combine plots
fig3.1 <- cowplot::plot_grid(fig3a, fig3b, nrow = 2)
fig3.1 <- cowplot::plot_grid(fig3.1, legend, nrow = 1, rel_widths = c(1, 0.5))
fig3.1

ggsave(plot = fig3.1, here::here("figures", "figSX_species.jpg"), dpi = 600, height = 4, width = 6, units = "in")
```


####*Figure S1a, colored by f type

```{r}
concept_slopes_df <- concept_both_df %>%
  filter(group == "species")

# Model-predicted lines per species (but we will COLOR by functional_type)
model_lines <- concept_slopes_df %>%
  distinct(species, intercept, slope, functional_type) %>%
  left_join(
    concept_slopes_df %>%
      group_by(species) %>%
      summarise(
        abs_min = min(abs(mwp), na.rm = TRUE),
        abs_max = max(abs(mwp), na.rm = TRUE),   # <-- cap at highest absolute value
        sign_mwp = sign(stats::median(mwp, na.rm = TRUE)),
        .groups = "drop"
      ) %>%
      mutate(sign_mwp = if_else(sign_mwp == 0, -1, sign_mwp)), # fallback if median==0
    by = "species"
  ) %>%
  rowwise() %>%
  mutate(abs_mwp = list(seq(abs_min, abs_max, length.out = 100))) %>%
  tidyr::unnest(abs_mwp) %>%
  ungroup() %>%
  mutate(
    mwp = sign_mwp * abs_mwp,
    ilfm_pred = intercept + slope * mwp
  ) 

# ---- Panel A: iLFM ----
figSXa <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = ilfm)) +
  geom_point(aes(color = functional_type), alpha = 0.4) +
  # 1) Angiosperm lines (drawn first, underneath)
  geom_line(
    data = dplyr::filter(model_lines, functional_type == "angiosperm"),
    aes(x = -1*mwp, y = ilfm_pred, color = functional_type, group = species),
    linewidth = 0.5
  ) +
  # 2) Gymnosperm lines (drawn second, on top)
  geom_line(
    data = dplyr::filter(model_lines, functional_type == "gymnosperm"),
    aes(x = -1*mwp, y = ilfm_pred, color = functional_type, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    color = "Functional type"
  ) +
  theme(legend.position = "none") +
  scale_color_manual(
  values = c(
    "angiosperm" = "#E69F00",  # orange
    "gymnosperm" = "#0072B2"   # blue
  )
)

# ---- Panel B: LFM ----
figSXb <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = lfm)) +
  geom_point(aes(color = functional_type), alpha = 0.4) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = 1 / ilfm_pred, color = functional_type, group = species),
    linewidth = 0.5
  ) +
  geom_line(
    data = dplyr::filter(model_lines, functional_type == "angiosperm"),
    aes(x = -1*mwp, y = 1/ilfm_pred, color = functional_type, group = species),
    linewidth = 0.5
  ) +
  geom_line(
    data = dplyr::filter(model_lines, functional_type == "gymnosperm"),
    aes(x = -1*mwp, y = 1/ilfm_pred, color = functional_type, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    color = "Functional type"
  ) +
  theme(legend.position = "none") +
  scale_color_manual(
  values = c(
    "angiosperm" = "#E69F00",  # orange
    "gymnosperm" = "#0072B2"   # blue
  )
)

# ---- Legend (functional_type colors, but still one line per species) ----
legend <- cowplot::get_legend(
  ggplot(model_lines, aes(x = -1 * mwp, y = 1 / ilfm_pred,
                          color = functional_type, group = species)) +
    geom_line(linewidth = 0.6) +
    labs(color = "Functional type") +
    theme_minimal() +
    scale_color_manual(
  values = c(
    "angiosperm" = "#E69F00",  # orange
    "gymnosperm" = "#0072B2"   # blue
  )
)
  # + your_functional_type_scale_here
  # e.g., + scale_color_manual(values = ft_cols)
)

# Combine + save
figSX <- cowplot::plot_grid(figSXa, figSXb, nrow = 2)
figSX <- cowplot::plot_grid(figSX, legend, nrow = 1, rel_widths = c(1, 0.35))

figSX

ggsave(
  plot = figSX,
  filename = here::here("figures", "figSX_species_lines_colored_by_functional_type.jpg"),
  dpi = 600, height = 4, width = 6, units = "in"
)

```
####Figure S1a, colored by genus

```{r}
concept_slopes_df <- concept_both_df %>%
  filter(group == "species") 

model_lines <- concept_slopes_df%>%
  distinct(species, genus, intercept, slope) %>%
  left_join(
    concept_slopes_df %>%
      group_by(species) %>%
      summarise(
       abs_min = min(abs(mwp), na.rm = TRUE),
        abs_max = max(abs(mwp), na.rm = TRUE),   # <-- cap at highest absolute value
        sign_mwp = sign(stats::median(mwp, na.rm = TRUE)),
        .groups = "drop"
      ) %>%
      mutate(sign_mwp = if_else(sign_mwp == 0, -1, sign_mwp)), # fallback if median==0
    by = "species"
  ) %>%
  rowwise() %>%
  mutate(abs_mwp = list(seq(abs_min, abs_max, length.out = 100))) %>%
  tidyr::unnest(abs_mwp) %>%
  ungroup() %>%
  mutate(
    mwp = sign_mwp * abs_mwp,
    ilfm_pred = intercept + slope * mwp
  )

# ---- Panel A: iLFM ----
figSXa <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = ilfm)) +
  geom_point(aes(color = genus), alpha = 0.5) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = ilfm_pred, color = genus, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    color = "Genus"
  ) +
  theme(legend.position = "none")


# ---- Panel B: LFM ----
figSXb <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = lfm)) +
  geom_point(aes(color = genus), alpha = 0.5) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = 1 / ilfm_pred, color = genus, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    color = "Genus"
  ) +
  theme(legend.position = "none")


# ---- Legend (functional_type colors, but still one line per species) ----
legend <- cowplot::get_legend(
  ggplot(model_lines,
         aes(x = -1 * mwp, y = 1 / ilfm_pred,
             color = genus, group = species)) +
    geom_line(linewidth = 0.6) +
    labs(color = "Genus") +
    theme_minimal()
  # + scale_color_manual(values = genus_cols)  # if you have one
)


# Combine + save
figSX <- cowplot::plot_grid(figSXa, figSXb, nrow = 2)
figSX <- cowplot::plot_grid(figSX, legend, nrow = 1, rel_widths = c(1, 0.35))

figSX

ggsave(
  plot = figSX,
  filename = here::here("figures", "figSX_species_lines_colored_by_genus.jpg"),
  dpi = 600, height = 4, width = 6, units = "in"
)

```
####Figure S1a, colored by family

```{r}
concept_slopes_df <- concept_both_df %>%
  filter(group == "species") 

model_lines <- concept_slopes_df %>%
  distinct(species, family, intercept, slope)  %>%
  left_join(
    concept_slopes_df %>%
      group_by(species) %>%
      summarise(
        abs_min = min(abs(mwp), na.rm = TRUE),
        abs_max = max(abs(mwp), na.rm = TRUE),   # <-- cap at highest absolute value
        sign_mwp = sign(stats::median(mwp, na.rm = TRUE)),
        .groups = "drop"
      ) %>%
      mutate(sign_mwp = if_else(sign_mwp == 0, -1, sign_mwp)), # fallback if median==0
    by = "species"
  ) %>%
  rowwise() %>%
  mutate(abs_mwp = list(seq(abs_min, abs_max, length.out = 100))) %>%
  tidyr::unnest(abs_mwp) %>%
  ungroup() %>%
  mutate(
    mwp = sign_mwp * abs_mwp,
    ilfm_pred = intercept + slope * mwp
  ) 

# ---- Panel A: iLFM ----
figSXa <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = ilfm)) +
  geom_point(aes(color = family), alpha = 0.5) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = ilfm_pred, color = family, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    color = "family"
  ) +
  theme(legend.position = "none")


# ---- Panel B: LFM ----
figSXb <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = lfm)) +
  geom_point(aes(color = family), alpha = 0.5) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = 1 / ilfm_pred, color = family, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    color = "family"
  ) +
  theme(legend.position = "none")


# ---- Legend (functional_type colors, but still one line per species) ----
legend <- cowplot::get_legend(
  ggplot(model_lines,
         aes(x = -1 * mwp, y = 1 / ilfm_pred,
             color = family, group = species)) +
    geom_line(linewidth = 0.6) +
    labs(color = "family") +
    theme_minimal()
  # + scale_color_manual(values = family_cols)  # if you have one
)


# Combine + save
figSX <- cowplot::plot_grid(figSXa, figSXb, nrow = 2)
figSX <- cowplot::plot_grid(figSX, legend, nrow = 1, rel_widths = c(1, 0.35))

figSX

ggsave(
  plot = figSX,
  filename = here::here("figures", "figSX_species_lines_colored_by_family.jpg"),
  dpi = 600, height = 4, width = 6, units = "in"
)

```

####Figure S1., colored by species
```{r, figure1}
concept_slopes_df <- concept_both_df %>%
  filter(group == "species") 

# Generate model-predicted lines for each species
model_lines <- concept_slopes_df  %>% 
  merge(table1_df)%>% 
  distinct(species, intercept, slope, family)  %>%
  left_join(
    concept_slopes_df %>%
      group_by(species) %>%
      summarise(
        abs_min = min(abs(mwp), na.rm = TRUE),
        abs_max = max(abs(mwp), na.rm = TRUE),   # <-- cap at highest absolute value
        sign_mwp = sign(stats::median(mwp, na.rm = TRUE)),
        .groups = "drop"
      ) %>%
      mutate(sign_mwp = if_else(sign_mwp == 0, -1, sign_mwp)), # fallback if median==0
    by = "species"
  ) %>%
  rowwise() %>%
  mutate(abs_mwp = list(seq(abs_min, abs_max, length.out = 100))) %>%
  tidyr::unnest(abs_mwp) %>%
  ungroup() %>%
  mutate(
    mwp = sign_mwp * abs_mwp,
    ilfm_pred = intercept + slope * mwp
  ) 

# Scatter plot of ilfm vs mwp with model lines
figSXa <- ggplot(concept_slopes_df , aes(x = -1*mwp, y = ilfm)) +
  geom_point(aes(color = species), alpha = 0.5) +  # Scatter points colored by species
  geom_line(data = model_lines, aes(x = -1*mwp, y = ilfm_pred, color = species), size = 0.5) +  # Model lines colored by study
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
   # title = "Model fits with species intercept and slope",
    color = "Study"
  ) +
  color_species + 
  #theme_minimal() +
  theme(legend.position = "false")

# Scatter plot of ilfm vs mwp with model lines
figSXb <- ggplot(concept_slopes_df , aes(x = -1*mwp, y = lfm)) +
  geom_point(aes(color = species), alpha = 0.5) +  # Scatter points colored by species
  geom_line(data = model_lines, aes(x = -1*mwp, y = 1/ilfm_pred, color = species), size = .5) +  # Model lines colored by study
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    #title = "Model fits with species intercept and slope",
    color = "Study"
  ) +
  #theme_minimal() +
  color_species + 
  theme(legend.position = "false")


# Extract legend
legend <- cowplot::get_legend(
  ggplot(concept_df %>%
    filter(group == "grand"), aes(x = -1 * mwp, y = lfm)) +
    geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = species, group = interaction(species, study)), size = 0.5) +
    labs(color = "Species") +
    color_species
)

# Combine plots
figSX <- cowplot::plot_grid(figSXa, figSXb, nrow = 2)
figSX
figSX <- cowplot::plot_grid(figSX, legend, nrow = 1, rel_widths = c(1, 0.5))
figSX

ggsave(plot = figSX, here::here("figures", "figSX_fgroup_sppint.jpg"), dpi = 600, height = 4, width = 6, units = "in")
```

###Figure S1., colored by study
```{r, figure1}
concept_slopes_df <- concept_both_df %>%
  filter(group == "species") 

model_lines <- concept_slopes_df %>%
  distinct(species, study, intercept, slope)  %>%
  left_join(
    concept_slopes_df %>%
      group_by(species) %>%
      summarise(
        abs_min = min(abs(mwp), na.rm = TRUE),
        abs_max = max(abs(mwp), na.rm = TRUE),   # <-- cap at highest absolute value
        sign_mwp = sign(stats::median(mwp, na.rm = TRUE)),
        .groups = "drop"
      ) %>%
      mutate(sign_mwp = if_else(sign_mwp == 0, -1, sign_mwp)), # fallback if median==0
    by = "species"
  ) %>%
  rowwise() %>%
  mutate(abs_mwp = list(seq(abs_min, abs_max, length.out = 100))) %>%
  tidyr::unnest(abs_mwp) %>%
  ungroup() %>%
  mutate(
    mwp = sign_mwp * abs_mwp,
    ilfm_pred = intercept + slope * mwp
  ) 

# ---- Panel A: iLFM ----
figSXa <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = ilfm)) +
  geom_point(aes(color = study), alpha = 0.5) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = ilfm_pred, color = study, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    color = "study"
  ) +
  theme(legend.position = "none")


# ---- Panel B: LFM ----
figSXb <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = lfm)) +
  geom_point(aes(color = study), alpha = 0.5) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    color = "study"
  ) +
  theme(legend.position = "none")


# ---- Legend (functional_type colors, but still one line per species) ----
legend <- cowplot::get_legend(
  ggplot(model_lines,
         aes(x = -1 * mwp, y = 1 / ilfm_pred,
             color = study, group = species)) +
    geom_line(linewidth = 0.6) +
    labs(color = "study") +
    theme_minimal()
  # + scale_color_manual(values = study_cols)  # if you have one
)


# Combine + save
figSX <- cowplot::plot_grid(figSXa, figSXb, nrow = 2)
figSX <- cowplot::plot_grid(figSX, legend, nrow = 1, rel_widths = c(1, 0.35))

figSX

ggsave(
  plot = figSX,
  filename = here::here("figures", "figSX_species_lines_colored_by_study.jpg"),
  dpi = 600, height = 4, width = 6, units = "in"
)

```

#####Figure SX (differences across studies)
```{r, slopes}
model <- lm(ilfm ~ mwp * sp_site, data = df1)
summary(model)

coef_sp_site_dupes <- coefs_species_study %>% 
  group_by(species) %>% 
  filter(n() >= 2)

spp_dupes <- list(unique(coef_sp_site_dupes$species))
spp_dupes

df2 <- df %>% 
  filter(species %in% c("ADEFAS", "HETARB", "QUEAGR", "QUEDOU", "QUEKEL"))

# Step 1: Run interaction models for each species
interaction_results <- df2 %>%
  group_by(species) %>%
  group_modify(~ {
    model <- lm(ilfm ~ mwp * sp_site, data = .x)
    interaction_p <- anova(model)[["Pr(>F)"]][which(rownames(anova(model)) == "mwp:sp_site")]
    tibble(interaction_p = interaction_p)
  }) %>%
  mutate(sig_interaction = interaction_p < 0.05)

df_plot <- df2 %>%
  left_join(interaction_results, by = "species")

# 1) Build a little df with one row per facet containing the star label + position
#    Assumes df_plot has a logical column sig_interaction per species (TRUE/FALSE)
star_df <- df_plot %>%
  group_by(species) %>%
  summarise(
    sig = any(sig_interaction, na.rm = TRUE),
    x_pos = max(mwp, na.rm = TRUE),
    y_pos = max(ilfm, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    star = ifelse(sig, "Sig. site effect", ""),
    # nudge in from the upper-right corner a bit
    x_pos = x_pos - 0.03 * (x_pos - min(df_plot$mwp, na.rm = TRUE)),
    y_pos = y_pos - 0.03 * (y_pos - min(df_plot$ilfm, na.rm = TRUE))
  )

# 2) Plot: constant line size + add stars in upper right of each panel
figSX_studydiffs <- ggplot(df_plot, aes(x = mwp, y = ilfm, color = study, group = sp_site)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 0.7) +   # all same thickness
  geom_text(
    data = star_df,
    aes(x = x_pos, y = y_pos, label = star),
    inherit.aes = FALSE,
    hjust = 1, vjust = 1,
    size = 3,
    color = "black"
  ) +
  facet_wrap(~ species, scales = "free") +
  labs(
    x = "Minimum Water Potential (MPa)",
    y = "1/LFM",
    color = "Site"
  ) +
  theme(
    legend.position = "right",
    strip.text = element_text(face = "bold"),
    plot.title = element_text(face = "bold", size = 16)
  ) +
  theme(
  legend.position = c(0.95, 0.05),   # lower right
  legend.justification = c(1, 0),    # anchor legend box at its bottom-right
  strip.text = element_text(face = "bold"),
  plot.title = element_text(face = "bold", size = 16)
) +
  scale_color_manual(values  = c(
    "Pepperwood" = "#009E73",
    "StuntRanch" = "#E69F00",
    "SEKI"       = "#56B4E9",
    "Sedgwick"   = "#D55E00"
  ))

figSX_studydiffs

ggsave(plot =figSX_studydiffs, 
        filename = here::here("figures", "figSX_studydiffs.jpg"), 
       dpi = 600, width = 9, height = 5)

```
