---
title: "Additional analysis"
author: "Indra Boving"
date: "2024-04-03"
output: html_document
---

#Setup
```{r setup, include=FALSE}
rm(list = ls())
library(tidyverse)
library(here)
library(janitor)
source(here("scripts", "figure_info.R"))
library(ggpmisc)

color_species =    scale_color_manual(values = c("#17154f", "#2f357c", "#6c5d9e", "#9d9cd5", "#b0799a", "#f6b3b0", "#e48171", "#bf3729", "#e69b00", "#f5bb50", "#ada43b", "#355828",
                                 "#5b859e", "#1e395f", "#75884b", "#1e5a46", "#df8d71", "#af4f2f", "#d48f90", "#732f30", "#ab84a5", "#59385c", "#d8b847", "#b38711"))
```

#Data wrangling: 

#####Read in: 

Description of datasets: 

```{r}
df <- read_csv(here::here("data", "all-data-combined.csv")) %>% 
  clean_names() %>% 
  mutate(ilfm = 1/lfm) %>% 
  mutate(tissue_age = case_when(
  tissue_age %in% c(NA, NaN) ~ "both",
  TRUE ~ as.character(tissue_age)
  )) %>% 
  filter(!(sp_site %in% c("ABICON_SEKI", "PINJEF_SEKI", "CALDEC_SEKI", "PSEMEN_Pepperwood"))) #these act really odd, dont include
  # filter(!(sp_site %in% c("ABICON_SEKI", "PINJEF_SEKI") & tissue_age %in% c("old")))

```

#####Outliers? 

```{r}
df %>% 
  filter(study == "SEKI") %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = tissue_age)) + 
  geom_hline(yintercept = 70, linetype = "dotted") +
    geom_point(alpha = .4) +
  labs(x = "Midday Water Poential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Study", 
       shape = "Study") +
  color +
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  facet_wrap(~species, scales = "free")

df %>% 
  filter(study == "Sedgwick") %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = tissue_age)) + 
  geom_hline(yintercept = 70, linetype = "dotted") +
    geom_point(alpha = .4) +
  labs(x = "Midday Water Poential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Study", 
       shape = "Study") +
  color +
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  facet_wrap(~species, scales = "free")
```
model and look for outliers for each site:

```{r}
#SEKI outliers:
df_seki  <- df %>% 
  clean_names() %>% 
  mutate(ilfm = 1/lfm) %>% 
  filter(study == "SEKI")

#model with untransformed LFM: 
mod <- glm(mwp ~ lfm, data = df_seki)
mod
summary(mod)
plot(mod)

#model with transformed LFM: 
mod_inv <- glm(mwp ~ ilfm, data = df_seki)
mod_inv
summary(mod_inv)
plot(mod_inv)
#resid(mod_inv)

AIC(mod_inv)
AIC(mod)

#SEKI shows this the least

df[168,]

mod2 <- glm(mwp ~ lfm, data = df_seki[-168,])
mod2
summary(mod2)
plot(mod2)

AIC(mod, mod2)

coef(mod)
coef(mod2)

#Sedgwick outliers:
df_sedge  <- df %>% 
  clean_names() %>% 
  mutate(ilfm = 1/lfm) %>% 
  filter(study == "Sedgwick")

#model with untransformed LFM: 
mod <- glm(mwp ~ lfm, data = df_sedge)
mod
summary(mod)
plot(mod)

#model with untransformed LFM: 
mod2 <- glm(mwp ~ lfm, data = df_sedge[-231,])
mod2
summary(mod2)
plot(mod2)

AIC(mod, mod2)
coef(mod)
coef(mod2)

df_sedge[231,]

#model with transformed LFM: 
mod_inv <- glm(mwp ~ ilfm, data = df_sedge)
mod_inv
summary(mod_inv)
plot(mod_inv)
#resid(mod_inv)

AIC(mod_inv)
AIC(mod)

#Pepperwood outliers
df_pep  <- df %>% 
  clean_names() %>% 
  mutate(ilfm = 1/lfm) %>% 
  filter(!(study == "Pepperwood"))

#model with untransformed LFM: 
mod <- glm(mwp ~ lfm, data = df_pep)
mod
summary(mod)
plot(mod)

#model with transformed LFM: 
mod_inv <- glm(mwp ~ ilfm, data = df_pep)
mod_inv
summary(mod_inv)
plot(mod_inv)
#resid(mod_inv)

AIC(mod_inv)
AIC(mod)
```

Remove outliers, now this is the dataset we want to use: 
```{r}
df1 <- df %>% 
  filter(!(species %in% c("QUEAGR") & date %in% c("2022-04-27") & study %in% c("Sedgwick"))) %>% 
  mutate(study_nice = case_when(
    study %in% c("Pepperwood") ~ "PwD",
    study %in% c("Sedgwick") ~ "SeR",
    study %in% c("SEKI") ~ "PrC",
    study %in% c("StuntRanch") ~ "StR"
  ))

unique(df1$study)
```

####Table 1: (dataset summary)

Table 1. Species names and characteristics and sample sizes across the four studies. Sites: PeW = Pepperwood, StR = Stunt Ranch (Pivovaroff et al. 2019), SeR = Sedgwick Reserve, PrC = Providence Creek Watershed; Dec/Ever = deciduous/evergreen; Growth form = tree or shrub. Sample sizes indicate individual observations (LFM and MPa from a single individual on a single date).

```{r}
#devtools::install_github("ecoinfor/U.Taxonstand")
#install.packages("U.Taxonstand")
#library(Taxonstand)
library(U.Taxonstand)  # If you're using U.Taxonstand instead

SpCodes <- read_csv(here("data", "SpCodes.csv")) %>%
  mutate(species = SpCode6) %>% 
  mutate(family = familyMatch(splist = c(Genus), taxon = "plant")$family)

traits_df <- read_csv(here("data", "species-traits-withseki.csv")) %>% 
  clean_names() %>% 
  mutate(species = sp_code) %>% 
  select(species, functional_type, growth_form)

sp_info <- merge(traits_df, SpCodes)

table1_df <- merge(df1, sp_info, by = c("species")) %>% 
  group_by(study, species, Genus_species, functional_type, growth_form, family) %>% 
  summarise(n = n()) %>% 
  pivot_wider(names_from = c(study), 
              values_from = n) %>% 
  mutate(dec_ever = case_when(
    species %in% c("QUEDOU",
                   "QUEGAR",
                   "QUEKEL",
                   "SALLEU",
                   "SALMEL") ~ "Dec",
    species %in% c("ERIFAS") ~ "Semi-Dec",
    TRUE ~ as.character("Ever")
  )) %>% 
  mutate(growth_form = case_when(
    species %in% c("CERBET") ~ "tree/shrub",
    TRUE ~ as.character(growth_form)
  )) %>% 
  mutate(common_name = case_when(
    species %in% c("ADEFAS") ~ "Chamise",
    species %in% c("ARBMEN") ~ "Madrone",
    species %in% c("CEACUN") ~ "Bickbush",
    species %in% c("CEAPAR") ~ "Parry ceanothus",
    species %in% c("HETARB") ~ "Toyon",
    species %in% c("PSEMEN") ~ "Douglas-fir",
    species %in% c("QUEAGR") ~ "Live oak",
    species %in% c("QUEDOU") ~ "Blue oak",
    species %in% c("QUEDUR") ~ "Leather oak",
    species %in% c("QUEGAR") ~ "Oregon white oak",
    species %in% c("QUEKEL") ~ "California black oak",
    species %in% c("UMBCAL") ~ "California bay",
    species %in% c("ARCPAT") ~ "Greenleaf manzanita",
    species %in% c("CEACOR") ~ "Whitethorn ceanothus",
    species %in% c("ARCGLA") ~ "Eastwood manzanita",
    species %in% c("CEASPI") ~ "Greenbark ceanothus",
    species %in% c("CERBET") ~ "Mountain mahogany",
    species %in% c("ERIFAS") ~ "California buckwheat",
    species %in% c("MALLAU") ~ "Laurel sumac",
    species %in% c("QUEBER") ~ "Scrub oak",
    species %in% c("SALLEU") ~ "Purple sage",
    species %in% c("SALMEL") ~ "Black sage")) %>% 
  ungroup() %>% 
  dplyr::select(species, Genus_species, common_name, family, growth_form, dec_ever, Pepperwood, SEKI, Sedgwick, StuntRanch) %>% 
  rename(PeW = Pepperwood, 
         PrC = SEKI, 
         StR = StuntRanch, 
         SeR = Sedgwick) %>% 
  arrange(species, Genus_species, common_name, family, growth_form, dec_ever, PeW, PrC, StR, SeR) %>%
  adorn_totals("row")

# table1_df  %>% 
#   kable(format = "pipe")

write_csv(table1_df, here("results", "figures", "table1.csv"))
```

####Figure 1: (datasets)

```{r}
fig1 <- df1 %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = species)) + 
  geom_hline(yintercept = 60, linetype = "dotted") +
    geom_point(alpha = .8) +
  labs(x = "Midday Water Poential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Species", 
       shape = "Study") +
    #scale_color_manual(values = cal_palette("sierra1", n = 22, type = "discrete")) +
  color_species + 
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  facet_wrap(~study_nice, nrow = 2)
fig1

ggsave(plot = fig1, here::here("figures", "fig1.jpg"), dpi = 600, height = 4, width = 6, units = "in")
```

```{r}
## Preliminary analysis of 2021 Live Fuel Moisture (LFM) data
  # Remove all objects from the workspace to start fresh

library(ggplot2)  # Load ggplot2 package for advanced plotting capabilities
source(here('scripts', 'lfm_functions.R'))
# Source custom functions from external script

# Read in the combined dataset; 'as.is = TRUE' prevents strings from converting to factors
# 'row.names = 1' uses the first column as row names
lwa <- df1

# Calculate the inverse of LFM for modeling purposes
lwa$ilfm <- 1 / lwa$lfm

# Display the first few rows of the data to check if it's loaded correctly
head(lwa)

# Create a frequency table of the 'study' variable
table(lwa$study)

# Get a sorted list of unique study sites
sites <- sort(unique(lwa$study))

# Verify the number of observations per study
table(lwa$study)

# Check the total number of observations
nrow(lwa)

### Plotting by Site

# Define colors for each site for consistent plotting
scolors <- c("#B9C7E2", "#ECAB99",  "#5B6530", "#9484B1",  "#F1C100")  # Added color for SEKI

# Assign colors to each observation based on the study site
lwa$scolors <- scolors[match(lwa$study, sites)]

# Confirm that colors are assigned correctly
table(lwa$scolors)

# Randomly sample 1000 observations for plotting to avoid overplotting
rsamp <- sample(1:nrow(lwa), 1000)  # Sample from the full dataset

# Set up an empty plot with defined axes and limits
plot(lfm ~ mwp, data = lwa, type = 'n',
     xlab = 'Midday water potential (MPa)',
     ylab = 'Live fuel moisture',
     xlim = c(-8, 0), ylim = c(0, 3.5))

# Plot data points for each study site with different symbols and colors
points(lfm ~ mwp, data = lwa[lwa$study == 'Sedgwick', ],
       pch = 5, cex = 1, col = lwa$scolors[lwa$study == 'Sedgwick'])

points(lfm ~ mwp, data = lwa[lwa$study == 'StuntRanch', ],
       pch = 15, cex = 1, col = lwa$scolors[lwa$study == 'StuntRanch'])

points(lfm ~ mwp, data = lwa[lwa$study == 'Pepperwood', ],
       pch = 19, cex = 1.2, col = lwa$scolors[lwa$study == 'Pepperwood'])

# Include SEKI in the points plotting
points(lfm ~ mwp, data = lwa[lwa$study == 'SEKI', ],
       pch = 17, cex = 1.2, col = lwa$scolors[lwa$study == 'SEKI'])  # Different symbol for SEKI

# Add a legend to the plot
legend(-7, 3, sites, fill = NULL, border = 'white')

# Add custom legend symbols corresponding to each site
points(rep(-6.7, length(sites)), seq(2.84, 2.64 - 0.2 * (length(sites) - 1), length.out = length(sites)),
       pch = c(19, 5, 15, 17), col = scolors, cex = 2)  # Added SEKI symbol
```

#Conceptual Model:


#####Figure 2: (color)
```{r}
## conceptual model
source(here("scripts", "lfm_functions.R"))
spres <- read.csv(here("results", "species-results.csv"))
head(spres)
slp <- -0.198

#MWPvec <- seq(-6,0,length.out=25)
ilfm.sat.vec <- seq(0.25,1.25,length.out=25)
MWPcrit <- c()
for (i in 1:length(ilfm.sat.vec)) MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i],slp),1/0.7)
lfm.sat.vec <- 1/ilfm.sat.vec
plot(MWPcrit,lfm.sat.vec,xlim=c(-8,0),ylim=c(0,4),type='l',lwd=2,xlab='Minimum MWP (MPa)',ylab='LFM @ MWP=0')

for (i in 1:length(ilfm.sat.vec)) MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i],slp),1/0.5)
lfm.sat.vec <- 1/ilfm.sat.vec
lines(MWPcrit,lfm.sat.vec,xlim=c(-8,0),ylim=c(0,4),lwd=1)

for (i in 1:length(ilfm.sat.vec)) MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i],slp),1/1)
lfm.sat.vec <- 1/ilfm.sat.vec
lines(MWPcrit,lfm.sat.vec,xlim=c(-8,0),ylim=c(0,4),lwd=1)

#points(I(1/model1.int)~minWP,data=spres[which(spres$study=='Coastal'),],pch=19)
text(I(1/model1.int)~minWP,data=spres[which(spres$study=='Coastal'),],labels=letters)

# conceptual figure, in inverted space - need to flip to LFM# conceptual figulettersre, in inverted space - need to flip to LFM
lfm.sat <- c(0.9,0.5)
slp <- -0.2
min.MWP <- c(-6,-3)

xy <- inversePlotData(c(min.MWP[1],0),c(lfm.sat[1],slp))
head(xy)
plot(xy$MWP,xy$LFM)

(MWPcrit <- solveForX(c(lfm.sat[2],slp),1/0.7))
#------
(max.iLFM <- lfm.sat + min.MWP*slp)
(min.LFM <- 1/max.iLFM)

op=par(mfrow=c(1,2))
plot(c(-7,0),c(0,3),type='n',xlab='MWP',ylab='1/LFM')
x <- list()
y <- list()
for (i in 1:2) {
  x[[i]] <- c(0,min.MWP[i])
  y[[i]] <- c(lfm.sat[i],max.iLFM[i])
  lines(x[[i]],y[[i]],type='b',cex=2,pch=c(1,19))
}

xy1 <- inversePlotData(c(0,min.MWP[1]),c(lfm.sat[1],slp))
xy2 <- inversePlotData(c(0,min.MWP[2]),c(lfm.sat[2],slp))
plot(c(-7,0),c(0,3),type='n',xlab='MWP',ylab='LFM')
lines(xy1$MWP,xy1$LFM,type='l')
head(xy1)
points(xy1[c(1,100),c('MWP','LFM')],cex=2,pch=c(1,19))
lines(xy2$MWP,xy2$LFM,type='l')
points(xy2[c(1,100),c('MWP','LFM')],cex=2,pch=c(1,19))
par(op)

#-----
# Choose distinct colors for each line
cols <- c("steelblue3", "tomato3")  # i=1 -> cols[1], i=2 -> cols[2]

xy <- inversePlotData(c(min.MWP[1], 0), c(lfm.sat[1], slp))
plot(xy$MWP, xy$LFM)

(MWPcrit <- solveForX(c(lfm.sat[2], slp), 1/0.7))

(max.iLFM <- lfm.sat + min.MWP * slp)
(min.LFM  <- 1 / max.iLFM)

op <- par(mfrow = c(1, 2))

## Panel 1: 1/LFM vs MWP
plot(c(-7, 0), c(0, 3), type = "n", xlab = "MWP", ylab = "1/LFM")
mtext("A", side = 3, adj = 0, line = 1.2, font = 2, cex = 1.2)  # Panel label
x <- vector("list", 2)
y <- vector("list", 2)
for (i in 1:2) {
  x[[i]] <- c(0, min.MWP[i])
  y[[i]] <- c(lfm.sat[i], max.iLFM[i])
  # open circle for first point, filled circle for second
  lines(x[[i]], y[[i]], col = cols[i], lwd = 2)
  points(x[[i]][1], y[[i]][1], pch = 21, bg = "white", col = cols[i], cex = 2, lwd = 2)
  points(x[[i]][2], y[[i]][2], pch = 19, col = cols[i], cex = 2)
}

## Panel 2: LFM vs MWP
xy1 <- inversePlotData(c(0, min.MWP[1]), c(lfm.sat[1], slp))
xy2 <- inversePlotData(c(0, min.MWP[2]), c(lfm.sat[2], slp))
plot(c(-7, 0), c(0, 3), type = "n", xlab = "MWP", ylab = "LFM")
mtext("B", side = 3, adj = 0, line = 1.2, font = 2, cex = 1.2)  # Panel label

lines(xy1$MWP, xy1$LFM, col = cols[1], lwd = 2)
points(xy1[1, c("MWP", "LFM")], pch = 21, bg = "white", col = cols[1], cex = 2, lwd = 2)
points(xy1[100, c("MWP", "LFM")], pch = 19, col = cols[1], cex = 2)

lines(xy2$MWP, xy2$LFM, col = cols[2], lwd = 2)
points(xy2[1, c("MWP", "LFM")], pch = 21, bg = "white", col = cols[2], cex = 2, lwd = 2)
points(xy2[100, c("MWP", "LFM")], pch = 19, col = cols[2], cex = 2)

par(op)

#----
library(dplyr)
library(ggplot2)
library(patchwork)

# Colors mapped consistently across both panels
cols <- c("steelblue3", "tomato3")
names(cols) <- c("1","2")  # map to id "1" and "2"

# --- Data prep ---------------------------------------------------------------

# Panel A (1/LFM vs MWP): two straight line segments with endpoints
max.iLFM <- lfm.sat + min.MWP * slp

dfA_lines <- tibble(
  id = factor(c(1,1, 2,2)),
  MWP = c(0, min.MWP[1], 0, min.MWP[2]),
  invLFM = c(lfm.sat[1], max.iLFM[1], lfm.sat[2], max.iLFM[2])
)

dfA_open <- dfA_lines %>%
  group_by(id) %>%
  slice_head(n = 1) %>%
  ungroup()

dfA_filled <- dfA_lines %>%
  group_by(id) %>%
  slice_tail(n = 1) %>%
  ungroup()

# Panel B (LFM vs MWP): two curves from inversePlotData
xy1 <- inversePlotData(c(0, min.MWP[1]), c(lfm.sat[1], slp)) %>% mutate(id = factor(1))
xy2 <- inversePlotData(c(0, min.MWP[2]), c(lfm.sat[2], slp)) %>% mutate(id = factor(2))
dfB_curve <- bind_rows(xy1, xy2)

dfB_open <- dfB_curve %>%
  group_by(id) %>%
  slice_head(n = 1) %>%
  ungroup()

dfB_filled <- dfB_curve %>%
  group_by(id) %>%
  slice_tail(n = 1) %>%
  ungroup()

# --- Plots -------------------------------------------------------------------

# Panel A: 1/LFM vs MWP
pA <- ggplot() +
  geom_line(data = dfA_lines,
            aes(x = MWP, y = invLFM, group = id, color = id), linewidth = 1) +
  geom_vline(xintercept = 0, linetype="dotted") +
  geom_point(data = dfA_open,
             aes(x = MWP, y = invLFM, color = id),
             shape = 21, fill = "white", size = 3.5, stroke = 1.2) +
  geom_point(data = dfA_filled,
             aes(x = MWP, y = invLFM, color = id),
             shape = 19, size = 3.5) +
  annotate("text", x = -7, y = 3, label = "A", fontface = "bold",
           hjust = 0, vjust = 1, size = 5) +
  coord_cartesian(xlim = c(-7, 0), ylim = c(0, 3)) +
  scale_color_manual(values = cols, guide = "none") +
  labs(x = "Midday Water Potential (MPa)", y = "1/LFM (%)")

# Panel B: LFM vs MWP
pB <- ggplot(dfB_curve, aes(x = MWP, y = LFM, color = id)) +
  geom_line(linewidth = 1) +
  geom_vline(xintercept = 0, linetype="dotted") +
  geom_point(data = dfB_open,
             aes(x = MWP, y = LFM),
             shape = 21, fill = "white", size = 3.5, stroke = 1.2) +
  geom_point(data = dfB_filled,
             aes(x = MWP, y = LFM),
             shape = 19, size = 3.5) +
  annotate("text", x = -7, y = 3, label = "B", fontface = "bold",
           hjust = 0, vjust = 1, size = 5) +
  coord_cartesian(xlim = c(-7, 0), ylim = c(0, 3)) +
  scale_color_manual(values = cols, guide = "none") +
  labs(x = "Midday Water Potential (MPa)", y = "LFM (%)")

# Side-by-side layout (no legend)
pA + pB + plot_layout(ncol = 2)

# Create the combined plot
final_plot <- pA + pB + plot_layout(ncol = 2, 
                                    axis_titles = "collect")
final_plot

# Save it
ggsave(
  filename = here("figures", "Figure2_color.png"),  # or .pdf, .jpg, etc.
  plot     = final_plot,
  width    = 8,     # inches
  height   = 4,     # inches
  dpi      = 300    # high resolution
)
#----
```


#Q1: 
Intro/discussion:
1) What are the aggregate and species-level relationships between leaf water potential and live fuel moisture, and how do they compare across studies? We predict that initial LFM and minimum WP will explain variation in minimum LFM observed at the end of the dry season (following the conceptual model in Figure 2), and that these will be largely consistent across species.  


#####Figure SX. (linear fits)
Linear relationship between iLFM and middays: 

```{r}
# Model with untransformed LFM
mod <- glm(mwp ~ lfm, data = df1)
mod_summary <- summary(mod)

# Model with transformed LFM (inverse LFM)
mod_inv <- glm(mwp ~ ilfm, data = df1)
mod_inv_summary <- summary(mod_inv)

# Compare AIC and BIC
aic_values <- c(AIC(mod), AIC(mod_inv))
bic_values <- c(BIC(mod), BIC(mod_inv))
model_names <- c("Untransformed LFM", "Transformed LFM (iLFM)")

# Compute Pseudo R-squared (McFadden's R²)
pseudo_r2 <- function(model) {
  1 - (model$deviance / model$null.deviance)
}

r2_values <- c(pseudo_r2(mod), pseudo_r2(mod_inv))

# Compare residuals
par(mfrow = c(2, 2))  # Set plotting layout for residual diagnostics
plot(mod, main = "Untransformed LFM Model")
plot(mod_inv, main = "Transformed LFM Model")

# Create a summary table for comparison
model_comparison <- data.frame(
  Model = model_names,
  AIC = aic_values,
  BIC = bic_values,
  Pseudo_R2 = r2_values
)

print(model_comparison)

# Determine the better model based on AIC
best_model <- ifelse(AIC(mod_inv) < AIC(mod), "Transformed LFM (iLFM)", "Untransformed LFM")
cat("Best model based on AIC:", best_model, "\n")
```


#####Table SX (coefs)
```{r, models}
library(lme4)

mod_spp_int <- glm(ilfm ~ mwp*species, data = df1, family = gaussian)
#mod_spp_int_lmer <- lmer(ilfm ~ mwp*species + species|study, data = df1, REML = T)
mod_spp_noint <- glm(ilfm ~ mwp + species, data = df1, family = gaussian)
#mod_spp_lmer <- lmer(ilfm ~ mwp + species + 1|study, data = df1)

car::vif(mod_spp_noint)

AIC(mod_spp_int, mod_spp_noint)
BIC(mod_spp_int, mod_spp_noint)

anova(mod_spp_int, mod_spp_noint)

# AIC(mod_spp_lmer, mod_spp_noint_lmer)
# BIC(mod_spp_lmer, mod_spp_noint_lmer)
# anova(mod_spp_lmer, mod_spp_noint_lmer)

plot(mod_spp_noint)

plot(mod_spp_int)

#r2: 
R2_spp_int <- performance::r2(mod_spp_int)
R2_spp_int

R2_spp_noint <- performance::r2(mod_spp_noint)
R2_spp_noint

#model details: 
coef(summary(mod_spp_int))
summary(mod_spp_int)

summary(mod_spp_noint)

tablesx_coefs <- broom::tidy(mod_spp_noint) %>% 
    dplyr::mutate(across(where(is.numeric), round, 4)) %>% 
  mutate(p.value.stars = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01 & p.value < 0.001 ~ "**",
    p.value < 0.05 & p.value > 0.01 ~ "*", 
    TRUE ~ as.character(" ")
  ))

write_csv(tablesx_coefs, here("results", "figures", "tableSX_coefs.csv"))

tablesx_ints_coefs <- broom::tidy(mod_spp_int) %>% 
    dplyr::mutate(across(where(is.numeric), round, 4)) %>% 
  mutate(p.value.stars = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01 & p.value < 0.001 ~ "**",
    p.value < 0.05 & p.value > 0.01 ~ "*", 
    TRUE ~ as.character(" ")
  ))
tablesx_ints_coefs

write_csv(tablesx_ints_coefs, here("results", "figures", "tableSX_ints_coefs.csv"))
```

DF with slopes and intercepts: 

```{r}
library(dplyr)
library(broom)
library(tidyr)
library(purrr)

# Fit the models
mod_common_slope <- glm(ilfm ~ mwp + species, data = df1, family = gaussian)
mod_species_interaction <- glm(ilfm ~ mwp * species, data = df1, family = gaussian)
mod_species_study <- glm(ilfm ~ mwp * sp_site, data = df1, family = gaussian)

# Helper to extract coefficients and label the model
extract_model_info <- function(model, model_name) {
  tidy(model) %>%
    mutate(model = model_name)
}

# Combine all model coefficients
model_coeffs <- bind_rows(
  extract_model_info(mod_common_slope, "common_slope"),
  extract_model_info(mod_species_interaction, "species_interaction"),
  extract_model_info(mod_species_study, "species_site_interaction")
)

# Utility to get baseline level of factor variable (alphabetical if not set)
baseline_level <- function(var) levels(factor(var))[1]

# Function to compute slope and intercept per group
compute_group_terms <- function(model, group_var, model_type) {
  group_list <- unique(df1[[group_var]])
  base_group <- baseline_level(df1[[group_var]])

  map_dfr(group_list, function(grp) {
    # Start with base intercept and slope
    intercept <- coef(model)[["(Intercept)"]]
    slope <- coef(model)[["mwp"]]

    if (grp != base_group) {
      int_term <- paste0(group_var, grp)
      slope_term <- paste0("mwp:", group_var, grp)

      if (int_term %in% names(coef(model))) {
        intercept <- intercept + coef(model)[[int_term]]
      }

      if (slope_term %in% names(coef(model))) {
        slope <- slope + coef(model)[[slope_term]]
      }
    }

    tibble(
      group = grp,
      intercept = intercept,
      slope = slope,
      model = model_type
    )
  })
}

# Get results for each model
coefs_common <- compute_group_terms(mod_common_slope, "species", "common_slope") %>% rename(species = group)

coefs_species_int <- compute_group_terms(mod_species_interaction, "species", "species_interaction") %>% rename(species = group)

coefs_species_study <- compute_group_terms(mod_species_study, "sp_site", "species_site_interaction") %>% rename(sp_study = group)%>% 
  separate_wider_delim(sp_study, names = c("species", "study"), "_") 
  


# Combine into one dataframe
coef_compare_df  <- bind_rows(coefs_common, coefs_species_int, coefs_species_study) %>% 
  mutate(group = case_when(
    model %in% c("species_interaction") ~ "species",
    model %in% c("common_slope") ~ "grand",
    model %in% c("species_site_interaction") ~ "sp_study",
  )) %>% 
  select(-study)

range(coefs_species_int$slope)

#compare:
coef_compare_df %>% 
  ggplot(aes(y = slope, 
             x = intercept,
             color = group)) +
  geom_point(alpha = .4)


summary(coef_compare_df
        )

concept_both_df <- merge(coef_compare_df, df1, by = c("species"), all = T) %>% 
  filter(!(model == "species_site_interaction")) 
concept_study_df <- merge(coef_compare_df, df1, by = c("species"), all = T) %>% 
  filter(model == "species_site_interaction")

concept_df_all <- bind_rows(concept_both_df, concept_study_df)

concept_df <- concept_df_all %>% 
  filter(group == "grand")

```

#####Figure SX (differences across studies)
```{r, slopes}
coef_sp_site_dupes <- coefs_species_study %>% 
  group_by(species) %>% 
  filter(n() >= 2)

spp_dupes <- list(unique(coef_sp_site_dupes$species))
spp_dupes

df2 <- df %>% 
  filter(species %in% c("ADEFAS", "HETARB", "QUEAGR", "QUEDOU", "QUEKEL"))

# Step 1: Run interaction models for each species
interaction_results <- df2 %>%
  group_by(species) %>%
  group_modify(~ {
    model <- lm(ilfm ~ mwp * sp_site, data = .x)
    interaction_p <- anova(model)[["Pr(>F)"]][which(rownames(anova(model)) == "mwp:sp_site")]
    tibble(interaction_p = interaction_p)
  }) %>%
  mutate(sig_interaction = interaction_p < 0.05)

df_plot <- df2 %>%
  left_join(interaction_results, by = "species")

figSX_studydiffs <- ggplot(df_plot, aes(x = mwp, y = ilfm, color = sp_site, group = sp_site)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE, aes(size = sig_interaction)) +
  scale_size_manual(values = c(`TRUE` = 1.4, `FALSE` = 0.5), guide = "none") +
  facet_wrap(~ species, scales = "free") +
  labs(
   # title = "Relationship between ILFM and MWP across sites by species",
   # subtitle = "Bold lines indicate species with significant site-specific slopes (interaction p < 0.05)",
    x = "Minimum Water Potential (MPa)",
    y = "1/LFM"
  ) +
  #theme_minimal() +
  theme(
    legend.position = "right",
    strip.text = element_text(face = "bold"),
    plot.title = element_text(face = "bold", size = 16)
  ) +
  scale_color_manual(values = c("#17154f", "#2f357c", "#6c5d9e", "#9d9cd5", "#b0799a", "#f6b3b0", "#e48171", "#bf3729", "#e69b00", "#f5bb50", "#ada43b", "#355828",
                                 "#5b859e", "#1e395f", "#75884b", "#1e5a46", "#df8d71", "#af4f2f", "#d48f90", "#732f30", "#ab84a5", "#59385c", "#d8b847", "#b38711")) +
  labs(color = "Species_Site")
figSX_studydiffs

ggsave(plot =figSX_studydiffs, 
        filename = here::here("figures", "figSX_studydiffs.jpg"), 
       dpi = 600, width = 9, height = 5)

model <- lm(ilfm ~ mwp * sp_site, data = df2)
summary(model)
```

```{r, predict}
# Predict water potential (mwp) for each sp_site
df_pred <- df1 %>%
  left_join(coefs_species_int, by = "species") %>%  # Merge coefficients, using separate slope and intercept per species
  mutate(
    mwp_pred = (ilfm - intercept) / slope,  # Solve for mwp using linear equation
   # lfm_pred = 1 / ilfm,  # Transform ilfm back to lfm
    lfm_pred = 1/(slope * mwp + intercept)  # Transform ilfm back to lfm
  ) 
  
# Plot predicted vs original lfm
ggplot(df_pred, aes(x = mwp, y = mwp_pred, color = sp_site)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original Water Potential",
    y = "Predicted Water Potential",
    title = "Predicted vs Original Water Potential"
  ) +
  theme_minimal()

# Plot predicted vs original lfm
ggplot(df_pred, aes(x = lfm, y = lfm_pred, color = sp_site)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original LFM",
    y = "Predicted LFM",
    title = "Predicted vs Original LFM"
  ) +
  theme_minimal()
```


```{r, predict}
#-----------
# Predict water potential (mwp) for each sp_site
df_pred <- df1 %>%
  left_join(coefs_common, by = "species") %>%  # Merge coefficients, using separate slope and intercept per species
  mutate(
    mwp_pred = (ilfm - intercept) / slope,  # Solve for mwp using linear equation
   # lfm_pred = 1 / ilfm,  # Transform ilfm back to lfm
    lfm_pred = 1/(slope * mwp + intercept)  # Transform ilfm back to lfm
  ) 
  
# Plot predicted vs original lfm
ggplot(df_pred, aes(x = mwp, y = mwp_pred, color = species, label = species)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original Water Potential",
    y = "Predicted Water Potential",
    title = "Predicted vs Original Water Potential"
  ) +
  theme_minimal()

# Plot predicted vs original lfm
ggplot(df_pred, aes(x = lfm, y = lfm_pred, color = species,
                    label = species)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original LFM",
    y = "Predicted LFM",
    title = "Predicted vs Original LFM"
  ) +
  theme_minimal()
```


#####Figure 3. (models)
```{r, fig.height=5, fig.width=7}
# Define color palette for sites (color-blind friendly)
color_manual <- scale_color_manual(values  = c(
  "Pepperwood" = "#009E73",  # Green
  "StuntRanch" = "#E69F00",  # Orange
  "SEKI"       = "#56B4E9",  # Blue
  "Sedgwick"   = "#D55E00"))   # Red

# Identify the least negative (maximum) observed mwp per species
species_thresholds <- concept_both_df %>%
  filter(group == "grand") %>%
  group_by(species) %>%
  summarise(min_mwp = max(mwp, na.rm = TRUE), .groups = "drop")

# Generate model-predicted lines for each species and study
model_lines <- concept_df %>%
  filter(group == "grand") %>% 
  distinct(species, study, intercept, slope) %>%  
  group_by(species, study) %>%
  tidyr::expand_grid(mwp = seq(min(concept_df$mwp, na.rm = TRUE), max(concept_df$mwp, na.rm = TRUE), length.out = 100)) %>%
  left_join(species_thresholds, by = "species") %>%  
  mutate(
    ilfm_pred = intercept + slope * mwp,  
    line_type = ifelse(mwp > min_mwp, "dashed", "solid")  
  ) %>%
  ungroup()

# Separate data for solid and dashed lines
model_lines_solid <- model_lines %>% filter(line_type == "solid")
model_lines_dashed <- model_lines %>% filter(line_type == "dashed")

# Scatter plot of ilfm vs mwp with model lines
fig3a <- ggplot(concept_df %>%
  filter(group == "grand"), aes(x = -1 * mwp, y = ilfm)) +
  geom_point(aes(color = species), alpha = 0.3, color = "black") +  
  geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = ilfm_pred, color = study, group = interaction(species, study)), size = 0.5) +  
  geom_line(data = model_lines_dashed, aes(x = -1 * mwp, y = ilfm_pred, color = study, group = interaction(species, study)), size = 0.5, linetype = "dashed") +  
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    color = "Study"
  ) +
  color_manual +
  theme(legend.position = "none")

# Scatter plot of lfm vs mwp with model lines
fig3b <- ggplot(concept_df %>%
  filter(group == "grand"), aes(x = -1 * mwp, y = lfm)) +
  geom_point(aes(color = species), alpha = 0.3, color = "black") +  
  geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = interaction(species, study)), size = 0.5) +  
  geom_line(data = model_lines_dashed, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = interaction(species, study)), size = 0.5, linetype = "dashed") +  
  labs(
    x = "Water Potential (MPa)",
    y = "LFM",
    color = "Study"
  ) +
  color_manual +
  theme(legend.position = "none")

# Extract legend
legend <- cowplot::get_legend(
  ggplot(concept_df %>%
    filter(group == "grand"), aes(x = -1 * mwp, y = lfm)) +
    geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = interaction(species, study)), size = 0.5) +
    geom_line(data = model_lines_dashed, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = interaction(species, study)), size = 0.5, linetype = "dashed") +
    labs(color = "Study") +
    color_manual
)

# Combine plots
fig3.1 <- cowplot::plot_grid(fig3a, fig3b, nrow = 2)
fig3 <- cowplot::plot_grid(fig3.1, legend, nrow = 1, rel_widths = c(1, 0.25))
fig3

ggsave(plot = fig3, here::here("figures", "fig3.jpg"), dpi = 600, height = 4, width = 6, units = "in")
```


```{r, figure1}
color_species <- scale_color_manual(values = c(
  "ADEFAS" = "#17154f", "ARBMEN" = "#2f357c", "ARCGLA" = "#6c5d9e", "ARCPAT" = "#9d9cd5", 
  "CEACOR" = "#b0799a", "CEACUN" = "#f6b3b0", "CEAPAR" = "#e48171", "CEASPI" = "#bf3729", 
  "CERBET" = "#e69b00", "ERIFAS" = "#f5bb50", "HETARB" = "#ada43b", "MALLAU" = "#355828", 
  "PSEMEN" = "#5b859e", "QUEAGR" = "#1e395f", "QUEBER" = "#75884b", "QUEDOU" = "#1e5a46", 
  "QUEDUR" = "#df8d71", "QUEGAR" = "#af4f2f", "QUEKEL" = "#d48f90", "SALLEU" = "#732f30", 
  "SALMEL" = "#ab84a5", "UMBCAL" = "#59385c"
))


# Generate model-predicted lines for each species
model_lines <- concept_df %>%
  filter(group == "grand") %>% 
  distinct(species,intercept, slope) %>%  # Get unique specie
  group_by(species) %>%
  summarise(
    mwp = seq(min(concept_df$mwp, na.rm = TRUE), max(concept_df$mwp, na.rm = TRUE), length.out = 100), # Generate x values
    ilfm_pred = intercept + slope * mwp,  # Compute predicted y values
    species = unique(species),  # Retain study info for coloring
    .groups = "drop"
  ) 


# Scatter plot of ilfm vs mwp with model lines
fig3a <- ggplot(concept_df %>%
  filter(group == "grand"), aes(x = -1*mwp, y = ilfm)) +
  geom_point(aes(color = species), alpha = 0.5) +  # Scatter points colored by species
  geom_line(data = model_lines, aes(x = -1*mwp, y = ilfm_pred, color = species), size = 0.5) +  # Model lines colored by study
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    title = "Model fits with species intercept and common slope",
    color = "Study"
  ) +
  color_species + 
  #theme_minimal() +
  theme(legend.position = "false") 

# Scatter plot of ilfm vs mwp with model lines
fig3b <- ggplot(concept_df %>%
  filter(group == "grand"), aes(x = -1*mwp, y = lfm)) +
  geom_point(aes(color = species), alpha = 0.5) +  # Scatter points colored by species
  geom_line(data = model_lines, aes(x = -1*mwp, y = 1/ilfm_pred, color = species), size = .5) +  # Model lines colored by study
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    #title = "Model fits with species intercept and common slope",
    color = "Study"
  ) +
  #theme_minimal() +
  color_species + 
  theme(legend.position = "false")

fig3 <- cowplot::plot_grid(fig3a, fig3b, nrow = 2)
fig3


# Extract legend
legend <- cowplot::get_legend(
  ggplot(concept_df %>%
    filter(group == "grand"), aes(x = -1 * mwp, y = lfm)) +
    geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = species, group = interaction(species, study)), size = 0.5) +
    labs(color = "Study") +
    color_species
)

# Combine plots
fig3.1 <- cowplot::plot_grid(fig3a, fig3b, nrow = 2)
fig3.1 <- cowplot::plot_grid(fig3.1, legend, nrow = 1, rel_widths = c(1, 0.5))
fig3.1

ggsave(plot = fig3.1, here::here("figures", "figSX_species.jpg"), dpi = 600, height = 4, width = 6, units = "in")
```


####Figure S1.
```{r, figure1}
concept_slopes_df <- concept_both_df %>%
  filter(group == "species")
# Generate model-predicted lines for each species
model_lines <- concept_slopes_df  %>% 
  distinct(species, intercept, slope) %>%  # Get unique species-study combinations
  group_by(species) %>%
  summarise(
    mwp = seq(min(concept_df$mwp, na.rm = TRUE), max(concept_df$mwp, na.rm = TRUE), length.out = 100), # Generate x values
    ilfm_pred = intercept + slope * mwp,  # Compute predicted y values
    species = unique(species),  # Retain study info for coloring
    .groups = "drop"
  )


# Scatter plot of ilfm vs mwp with model lines
figSXa <- ggplot(concept_slopes_df , aes(x = -1*mwp, y = ilfm)) +
  geom_point(aes(color = species), alpha = 0.5) +  # Scatter points colored by species
  geom_line(data = model_lines, aes(x = -1*mwp, y = ilfm_pred, color = species), size = 0.5) +  # Model lines colored by study
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
   # title = "Model fits with species intercept and slope",
    color = "Study"
  ) +
  color_species + 
  #theme_minimal() +
  theme(legend.position = "false")

# Scatter plot of ilfm vs mwp with model lines
figSXb <- ggplot(concept_slopes_df , aes(x = -1*mwp, y = lfm)) +
  geom_point(aes(color = species), alpha = 0.5) +  # Scatter points colored by species
  geom_line(data = model_lines, aes(x = -1*mwp, y = 1/ilfm_pred, color = species), size = .5) +  # Model lines colored by study
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    #title = "Model fits with species intercept and slope",
    color = "Study"
  ) +
  #theme_minimal() +
  color_species + 
  theme(legend.position = "false")

# Extract legend
legend <- cowplot::get_legend(
  ggplot(concept_df %>%
    filter(group == "grand"), aes(x = -1 * mwp, y = lfm)) +
    geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = species, group = interaction(species, study)), size = 0.5) +
    labs(color = "Study") +
    color_species
)

# Combine plots
figSX <- cowplot::plot_grid(figSXa, figSXb, nrow = 2)
figSX
figSX <- cowplot::plot_grid(figSX, legend, nrow = 1, rel_widths = c(1, 0.5))
figSX

ggsave(plot = figSX, here::here("figures", "figSX_species_int.jpg"), dpi = 600, height = 4, width = 6, units = "in")
```

#Q2: 

Question: Across species, what are the contributions of initial LFM and minimum WP to explain variation in minimum LFM observed at the end of the dry season (following the conceptual model in Figure 2)? 

```{r, minwpvsmaxlfm}
concept_params_df <- concept_both_df %>% 
  clean_names() %>% 
  group_by(species) %>% 
  mutate(minlfm = min(lfm, na.rm = T),
         maxlfm = max(lfm, na.rm = T),
         minwp = min(mwp, na.rm = T), 
         maxwp = max(mwp, na.rm = T),
         minilfm = 1/minlfm, 
         intercept_lfm = 1/intercept,
         maxlfm_minwp = -1*minwp + maxlfm
         ) 

#species vs. grand intercepts: 
concept_df_wide <- concept_params_df %>% 
  rename(spp_code = species) %>% 
  select(spp_code, group, intercept) %>% 
  distinct() %>%  # Ensure unique rows
  pivot_wider(names_from = group, values_from = intercept, names_repair = "unique")

concept_df_wide %>% 
ggplot(aes(x = grand, y = species, color = spp_code)) +
  geom_abline() +
  geom_point()


df <- concept_params_df %>% filter(group == "species")

q2mod <- lmer(minlfm ~ maxlfm + minwp + (1|species) + (1|study), data = df)
q2mod
summary(q2mod)

head(concept_params_df)
```

For species-interaction model, are there sig relationships? 

```{r}
params_test_df <- concept_params_df %>% 
  select(species, intercept, intercept_lfm, slope, minlfm, minwp, minilfm, group, maxlfm, maxwp) %>% 
  unique()

fig4a <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = intercept_lfm, 
             x = minlfm, 
            )) +
  geom_point(aes( color = species)) +
  geom_smooth(method = "lm", se  = F) +
  color_species +
  stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4a
#initial LFM does not well explain end of season LFM

fig4b <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = intercept, 
             x = minlfm, 
            )) +
  geom_point(aes( color = species)) +
  geom_smooth(method = "lm", se  = F) +
   stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4b
#Initial 1/lfm does seem to kinda explain how low water potentials eventually go... 


fig4c <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = intercept, 
             x = minwp, 
            )) +
  geom_abline()+
  geom_point(aes(color = species)) +
  geom_smooth(method = "lm", se  = F, color = "black") +
  stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4c
#Intercept is related to but not totally teh same as the intercept


fig4d <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = minwp, 
             x = maxlfm, 
            )) +
  geom_point(aes( color = species)) +
  geom_smooth(method = "lm", se  = F) +
stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4d

fig4e <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = maxwp, 
             x = minlfm, 
            )) +
  geom_point(aes( color = species)) +
  geom_smooth(method = "lm", se  = F) +
stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4e
#Intercept is related to but not totally teh same as the intercept

fig4f <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = minwp, 
             x = minlfm, 
            )) +
  geom_point(aes( color = species)) +
 # geom_smooth(method = "lm", se  = F) +
  color_species +
stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4f

fig4g <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = slope, 
             x = minlfm, 
            )) +
  geom_point(aes( color = species)) +
 # geom_smooth(method = "lm", se  = F) +
  color_species +
stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4g


fig4g <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = slope, 
             x = maxlfm, 
            )) +
  geom_point(aes( color = species)) +
 # geom_smooth(method = "lm", se  = F) +
  color_species +
stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4g

fig4h <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = slope, 
             x = minwp, 
            )) +
  geom_point(aes( color = species)) +
 # geom_smooth(method = "lm", se  = F) +
  color_species +
stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4h

# fig4h <- params_test_df %>% 
#   filter(group == "species") %>% 
#   ggplot(aes(y = maxlfm_minwp, 
#              x = minlfm, 
#             )) +
#   geom_point(aes( color = species)) +
#  # geom_smooth(method = "lm", se  = F) +
#   color_species +
#   stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
#   stat_poly_line()
# fig4h

```
#### Figure 4a (param correlations):
```{r}
color_species <- scale_color_manual(values = c(
  "#17154f", "#2f357c", "#6c5d9e", "#9d9cd5", "#b0799a", "#f6b3b0", "#e48171", "#bf3729",
  "#e69b00", "#f5bb50", "#ada43b", "#355828", "#5b859e", "#1e395f", "#75884b", "#1e5a46",
  "#df8d71", "#af4f2f", "#d48f90", "#732f30", "#ab84a5", "#59385c", "#d8b847", "#b38711"
))

make_lm_plot <- function(df, xvar, yvar, xlab, ylab, eq_x = NULL, eq_y = NULL, eq_col = "black") {
  model <- lm(reformulate(xvar, yvar), data = df)
  eqn <- paste0(
    "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3),
    "\nR² = ", round(summary(model)$r.squared, 3),
    "\np = ", signif(summary(model)$coefficients[2, 4], 3)
  )
  
  # Default to upper left corner unless overridden
  if (is.null(eq_x)) eq_x <- min(df[[xvar]], na.rm = TRUE)
  if (is.null(eq_y)) eq_y <- max(df[[yvar]], na.rm = TRUE)

  ggplot(df, aes_string(x = xvar, y = yvar, color = "species")) +
    geom_point(size = 2) +
    geom_smooth(method = "lm", se = FALSE, color = eq_col) +
    annotate("text", x = eq_x, y = eq_y, label = eqn, hjust = 0, vjust = 1,
             size = 3.5, color = eq_col, fontface = "italic") +
    color_species +
    labs(x = xlab, y = ylab, color = "Species") +
   # theme_minimal(base_size = 12) +
    theme(legend.position = "right")
}

df_plot <- params_test_df %>% filter(group == "species")

fig4a <- make_lm_plot(df_plot, "minlfm", "intercept_lfm", "Minimum LFM (%)", "Intercept LFM")
fig4b <- make_lm_plot(df_plot, "minlfm", "intercept", "Minimum LFM (%)", "Model Intercept (1/LFM)")
fig4c <- make_lm_plot(df_plot, "minwp", "intercept", "Minimum WP (MPa)", "Model Intercept (1/LFM)")
fig4d <- make_lm_plot(df_plot, "maxlfm", "minwp", "Maximum LFM (%)", "Minimum WP (MPa)")
fig4e <- make_lm_plot(df_plot, "minlfm", "maxwp", "Minimum LFM (%)", "Maximum WP (MPa)")
fig4f <- make_lm_plot(df_plot, "minlfm", "minwp", "Minimum LFM (%)", "Minimum WP (MPa)")
fig4g <- make_lm_plot(df_plot, "minlfm", "slope", "Minimum LFM (%)", "Model Slope")
fig4h <- make_lm_plot(df_plot, "maxlfm", "slope", "Maximum LFM (%)", "Model Slope")
fig4i <- make_lm_plot(df_plot, "minwp", "slope", "Minimum WP (MPa)", "Model Slope")
fig4j <- make_lm_plot(df_plot, "maxwp", "slope", "Maximum WP (MPa)", "Model Slope")


library(cowplot)

legend <- get_legend(
  fig4a + theme(legend.box.margin = margin(0, 0, 5, 0))
)

plots_figsx_param_corrs <- plot_grid(
  fig4a + theme(legend.position = "none"),
  fig4b + theme(legend.position = "none"),
  fig4c + theme(legend.position = "none"),
  fig4d + theme(legend.position = "none"),
  fig4e + theme(legend.position = "none"),
  #fig4f + theme(legend.position = "none"),
  fig4g + theme(legend.position = "none"),
  fig4h + theme(legend.position = "none"), 
  fig4i + theme(legend.position = "none"),
  fig4j + theme(legend.position = "none"),
  ncol = 3,
  
  labels = LETTERS[1:9]
)

plots_figsx_param_corrs_final <- plot_grid(plots_figsx_param_corrs, legend, rel_widths = c(1, .25), nrow = 1)
plots_figsx_param_corrs_final


ggsave(plot =plots_figsx_param_corrs_final, 
        filename = here::here("figures", "figsx_param_corrs.jpg"), 
       dpi = 600, width = 12, height = 10)

#Save only the significant ones:
```


```{r}
plots_fig4a <- plot_grid(
  #fig4a + theme(legend.position = "none"),
  #fig4b + theme(legend.position = "none"),
 # fig4c + theme(legend.position = "none"),
 # fig4d + theme(legend.position = "none"),
 # fig4e + theme(legend.position = "none"),
  fig4f + theme(legend.position = "none"),
  fig4g + theme(legend.position = "none"),
 # fig4i + theme(legend.position = "none"),
  nrow = 1,
  labels = LETTERS[1:2]
)

plots_fig4a_final <- plot_grid(plots_fig4a, legend, rel_widths = c(1, .25), nrow = 1)
plots_fig4a_final


ggsave(plot =plots_fig4a_final, 
        filename = here::here("figures", "fig4a.jpg"), 
       dpi = 600, width = 9, height = 3.5)

```


####Figure 4. (isocline)

Using common slope for all species: 

```{r, fig.height=4, fig.width=6}
# Read species results
# spres_old <- read.csv(here('results', 'species-results.csv'))

# Ensure 'spres' has all the necessary columns from the previous steps
spres <- concept_params_df %>% 
  filter(group == "grand") %>% 
  mutate(model1.int = intercept,
         model1.slp = slope,  # Ensure slope is named 'model1.slp'
         SpCode6 = species, 
         minWP = minwp)

# Inspect the modified dataframe
head(spres)

# Generate a sequence of inverse LFM saturation values
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)

# Initialize an empty list to store critical MWP values for each species
MWPcrit_list <- list()

# Loop through each unique species and calculate the critical MWP using species-specific slopes
for (sp in unique(spres$species)) {
  
  # Get the species-specific slope from 'spres'
  species_slope <- spres %>% 
    filter(species == sp) %>% 
    pull(model1.slp)
  
  # Initialize a vector to hold critical MWP values for the current species
  MWPcrit <- c()
  
  # Calculate critical MWP for the current species
  for (i in 1:length(ilfm.sat.vec)) {
    MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.7)  # Use species-specific slope
  }
  
  # Store the results for each species in the list
  MWPcrit_list[[sp]] <- MWPcrit
}

# Convert inverse LFM saturation values back to LFM
lfm.sat.vec <- 1 / ilfm.sat.vec

# Step 7: Plot the conceptual model curve
plot(MWPcrit, lfm.sat.vec, 
     xlim = c(-8, 0), ylim = c(0, 4),
     type = 'l', lwd = 0, col = "blue",
     xlab = 'Minimum Minimum Water Potential (MPa)', 
     ylab = 'LFM @ Midday Water Potential = 0')

# Step 8: Repeat the calculations for different LFM thresholds

# 60% LFM
for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.62)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, lwd = 1, col = "maroon")
text(MWPcrit[length(MWPcrit)], lfm.sat.vec[length(lfm.sat.vec)], labels = "60% LFM", pos = 4, col = "maroon", cex = 0.8)

# 77% LFM
for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.77)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, lwd = 1, col = "goldenrod")
text(MWPcrit[length(MWPcrit)], lfm.sat.vec[length(lfm.sat.vec)], labels = "77% LFM", pos = 3, col = "goldenrod", cex = 0.8)

# Step 9: Add species data points to the conceptual model plot
# text(I(1 / model1.int) ~ minWP,
#      data = spres,
#      labels = spres$SpCode6,
#      pos = 4,
#      cex = 0.6) # Reduced text size to prevent overlap

# Assign unique letters to unique species
unique_species <- unique(spres$SpCode6)
species_letters <- setNames(letters[1:length(unique_species)], unique_species)

# Add a new column in 'spres' mapping species to their assigned letters
spres$Letter <- species_letters[spres$SpCode6]

# Create a letter-to-species lookup table
letter_mapping <- data.frame(
  Letter = spres$Letter,
  Species = spres$SpCode6
) %>% distinct()  # Ensure each species appears only once

# Define color palette for species
color_species <- c("#17154f", "#2f357c", "#6c5d9e", "#9d9cd5", "#b0799a", "#f6b3b0", "#e48171", "#bf3729", 
                   "#e69b00", "#f5bb50", "#ada43b", "#355828", "#5b859e", "#1e395f", "#75884b", "#1e5a46", 
                   "#df8d71", "#af4f2f", "#d48f90", "#732f30", "#ab84a5", "#59385c", "#d8b847", "#b38711")

# Ensure we have enough colors for all unique species
color_species <- setNames(color_species[1:length(unique_species)], unique_species)

# Add species-specific labels at the correct locations
text(spres$minWP, 1 / spres$model1.int,  # (x, y) coordinates
     labels = spres$Letter,               # Assign unique letters instead of species codes
     col = color_species[spres$SpCode6],  # Assign colors by species
     #pos = 5,                              # Adjust text positioning
     cex = 1)                            # Adjust text size to avoid overlap

```
To save the isocline: 
```{r}
# Save base R plot as high-resolution JPEG
jpeg(filename = here::here("figures", "fig4.jpg"), 
     width = 5, height = 4, units = "in", res = 600)

# Reduce whitespace: bottom, left, top, right margins
par(mar = c(3.5, 3.5, 1, 1), mgp = c(2, 0.6, 0))  # mgp controls label spacing
# Re-run the plotting code below to draw inside the jpeg device

# Step 7: Plot the conceptual model curve
plot(MWPcrit, lfm.sat.vec, 
     xlim = c(-8, 0), ylim = c(0, 4),
     type = 'l', lwd = 0, col = "blue",
     xlab = 'Minimum Minimum Water Potential (MPa)', 
     ylab = 'LFM @ Midday Water Potential = 0')

# 60% LFM line
for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.62)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, lwd = 1, col = "maroon")
text(MWPcrit[length(MWPcrit)], lfm.sat.vec[length(lfm.sat.vec)], labels = "60% LFM", pos = 4, col = "maroon", cex = 0.8)

# 77% LFM line
for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.77)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, lwd = 1, col = "goldenrod")
text(MWPcrit[length(MWPcrit)], lfm.sat.vec[length(lfm.sat.vec)], labels = "77% LFM", pos = 3, col = "goldenrod", cex = 0.8)

# Add species labels (letters)
text(spres$minWP, 1 / spres$model1.int,
     labels = spres$Letter,
     col = color_species[spres$SpCode6],
     cex = 1)

# Close the jpeg device
dev.off()

# Print letter-to-species mapping table
print(letter_mapping)

# Load necessary package
library(knitr)

# Print the letter-to-species mapping as a formatted table
letter_mapping %>% 
  kable(format = "pipe", col.names = c("Letter", "Species"))

write.csv(letter_mapping, file = here::here("figures", "letter_mapping.csv"), row.names = FALSE)
```
To save isocline labels: 

```{r}
library(dplyr)
library(knitr)
library(kableExtra)
library(here)

# Create the colored table
letter_mapping_colored <- letter_mapping %>%
  mutate(Letter = paste0("<span style='color:", color_species[Species], "'>", Letter, "</span>"))

# Generate the HTML table
table_html <- letter_mapping_colored %>%
  kable("html", escape = FALSE, col.names = c("Letter", "Species")) %>%
  kable_styling(full_width = FALSE, position = "left")

# Build full HTML page with styling for 2-column layout and smaller text
html_page <- paste0(
  "<!DOCTYPE html>
  <html>
  <head>
    <meta charset='UTF-8'>
    <title>Letter Mapping</title>
    <style>
      body {
        font-size: 0.85em;
        column-count: 2;
        column-gap: 2em;
        font-family: sans-serif;
      }
      table {
        margin-bottom: 1em;
        break-inside: avoid;
      }
    </style>
  </head>
  <body>",
  table_html,
  "</body>
  </html>"
)

# Save to file
writeLines(html_page, here("figures", "letter_mapping.html"))
```
####Figure 4, (NEW isocline with genus)
```{r}
library(dplyr)

# ----------------------------
# Build spres from parameters
# ----------------------------
spres <- concept_params_df %>% 
  filter(group == "grand") %>% 
  mutate(
    model1.int = intercept,
    model1.slp = slope,      # slope column for convenience
    SpCode6    = species, 
    minWP      = minwp
  )

# ----------------------------
# Join Genus info (REQUIRED)
#   - Replace `species_key_df` with your actual table name
#   - Must contain columns: SpCode6, Genus
# ----------------------------
spres <- spres %>%
  left_join(SpCodes %>% select(SpCode6, Genus), by = "SpCode6")

# Optional check for any species missing a Genus
if (any(is.na(spres$Genus))) {
  warning("Some SpCode6 have no Genus in species_key_df.")
}

# ----------------------------
# Generate conceptual curves
# ----------------------------
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)

# If you truly want species-specific MWPcrit per species, your list builder is fine.
# Keeping for completeness (not used directly in the plot below):

MWPcrit_list <- list()
for (sp in unique(spres$species)) {
  species_slope <- spres %>% filter(species == sp) %>% pull(model1.slp)
  MWPcrit <- numeric(length(ilfm.sat.vec))
  for (i in seq_along(ilfm.sat.vec)) {
    MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.7)
  }
  MWPcrit_list[[sp]] <- MWPcrit
}

# Use a "typical" slope for drawing the conceptual lines (so code below is robust).
# If you prefer a different summary (mean, a specific species, etc.), change here:
species_slope <- median(spres$model1.slp, na.rm = TRUE)

# ----------------------------
# Plot open: 
# ----------------------------

# Open JPEG device
jpeg(
  filename = here::here("figures", "Fig2_genus.jpg"),
  width    = 7,   
  height   = 4.5,     
  units    = "in",
  res      = 300    # high resolution
)


## 1) Make room on the right (set before plotting)

op <- par(no.readonly = TRUE)                  # save current par
# Tight margins + space for legend in right margin
par(mar = c(4, 4, 0.5, 6), mgp = c(2.2, 0.6, 0), xpd = TRUE) # add right margin & allow drawing in margins

# ----------------------------
# Base curve at 70% (reference), multiplied by 100
# ----------------------------
# --- Build the base (70%) reference once, then scale y to percent for plotting
MWPcrit <- numeric(length(ilfm.sat.vec))
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.7)
}
lfm_pct <- (1 / ilfm.sat.vec) * 100  # scale to percent for plotting

plot(
  MWPcrit, lfm_pct,
  xlim = c(-8, 0.1), ylim = c(0, 400),
  type = "l", lwd = 0, col = "blue",
  xlab = "Minimum Minimum Water Potential (MPa)",
  ylab = "LFM (%) @ Midday Water Potential = 0",
  yaxt = "n"
)
axis(2, at = seq(0, 400, 100), labels = seq(0, 400, 100), las = 1)

# --- 60% LFM curve (x depends on threshold; y is the same lfm_pct scale)
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.62)
}
lines(MWPcrit, lfm_pct, lwd = 1.5, col = "maroon")
text(tail(MWPcrit, 1), tail(lfm_pct, 1), labels = "60% LFM", pos = 1, col = "maroon", cex = 0.9)

# --- 77% LFM curve
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.77)
}
lines(MWPcrit, lfm_pct, lwd = 1.5, col = "goldenrod")
text(tail(MWPcrit, 1), tail(lfm_pct, 1), labels = "77% LFM", pos = 3, col = "goldenrod", cex = 0.9)

# --- Species letters (also scaled to percent on y)
text(
  x = spres$minWP,
  y = (1 / spres$model1.int) * 100,
  labels = spres$Letter,
  col = genus_cols[spres$Genus],
  cex = 1
)

# ----------------------------
# Assign unique letters per species (unchanged)
# ----------------------------
unique_species <- unique(spres$SpCode6)
species_letters <- setNames(letters[seq_along(unique_species)], unique_species)
spres$Letter <- species_letters[spres$SpCode6]

# Lookup (if needed elsewhere)
letter_mapping <- data.frame(
  Letter  = spres$Letter,
  Species = spres$SpCode6
) %>% distinct()

# ----------------------------
# Colors by Genus (CHANGE HERE)
# ----------------------------
# Okabe–Ito palette; expand if more genera than base colors
okabe_ito <- c("#17154f", "#5b859e", "#6c5d9e", "#9d9cd5", "#732f30", "#f6b3b0", "#e48171", "#bf3729",  "#e69b00", "#ab84a5", "#355828","#ada43b", "#5b859e", "#1e395f", "#75884b", "#df8d71", "#af4f2f", "#d48f90", "#59385c", "#d8b847", "#b38711")

genus_levels <- sort(unique(spres$Genus))
ng <- length(genus_levels)
genus_colors <- if (ng > length(okabe_ito)) {
  grDevices::colorRampPalette(okabe_ito)(ng)
} else {
  okabe_ito[seq_len(ng)]
}
genus_cols <- setNames(genus_colors, genus_levels)

# ----------------------------
# Plot species letters colored by Genus (REPLACEMENT)
# ----------------------------
text(
  x = spres$minWP,
  y = 1 / spres$model1.int * 100,
  labels = spres$Letter,
  col = genus_cols[spres$Genus],
  cex = 1
)

# Optional legend:
# Build the legend text: "a - Abies concolor"
## 2) Legend: outside plot border, inside device
# Build unique mapping (as before)
legend_df <- data.frame(
  Letter  = spres$Letter,
  Species = spres$SpCode6,
  Genus   = spres$Genus
) %>% distinct()

legend_text   <- paste0(legend_df$Letter, " - ", legend_df$Species)
legend_colors <- genus_cols[legend_df$Genus]

# Place legend using user coords just beyond the top-right plot corner
usr <- par("usr")  # c(xmin, xmax, ymin, ymax)
x_off <- diff(usr[1:2]) * 0.02   # 2% of x-range to the right of plot box
y_off <- diff(usr[3:4]) * 0.02   # 01% down from the top

legend(
  x = usr[2] + x_off,            # a touch to the right of the plot border
  y = usr[4] - y_off,            # a touch below the top border
  xjust = 0, yjust = 1,          # anchor legend’s top-left corner
  legend = legend_text,
  text.col = legend_colors,
  pch = 15, col = legend_colors,
  bty = "n", cex = 0.8,
  y.intersp = 0.9
)

## 3) (Optional) restore par when done
# par(op)

# Restore par settings
par(op)

# Close device to write file
dev.off()
 
```


####Figure S2.

Separate slopes for isoclines per species (probably not what we want to do though, v messy looking):

```{r, eval = F}
# Source custom functions if needed
source(here('scripts', 'lfm_functions.R'))

# Read species results
#spres_old <- read.csv(here('results', 'species-results.csv'))

# Ensure 'spres' has all the necessary columns from the previous steps
spres <- concept_params_df %>% 
  filter(slope_type == "species") %>% 
  mutate(model1.int = intercept,
         model1.slp = slope,  # Ensure slope is named 'model1.slp'
         #model2.int = int_sppstudy, 
        # model2_slp = slope_sppstudy, 
         SpCode6 = species, 
         minWP = minwp)

# Inspect the modified dataframe
head(spres)

# Generate a sequence of inverse LFM saturation values
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)

# Initialize an empty list to store critical MWP values for each species
MWPcrit_list <- list()

# Loop through each unique species and calculate the critical MWP using species-specific slopes
for (sp in unique(spres$species)) {
  
  # Get the species-specific slope from 'spres'
  species_slope <- spres %>% 
    filter(species == sp) %>% 
    pull(model1.slp)
  
  # Initialize a vector to hold critical MWP values for the current species
  MWPcrit <- c()
  
  # Calculate critical MWP for the current species
  for (i in 1:length(ilfm.sat.vec)) {
    MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.7)  # Use species-specific slope
  }
  
  # Store the results for each species in the list
  MWPcrit_list[[sp]] <- MWPcrit
}

# Example: Extract MWPcrit for a specific species (e.g., "species1")
# MWPcrit_list[["species1"]]

# Convert inverse LFM saturation values back to LFM
lfm.sat.vec <- 1 / ilfm.sat.vec

# Plot the conceptual model for each species using its own slope
plot(MWPcrit_list[[1]], lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4),
     type = 'l', lwd = 2, xlab = 'Minimum MWP (MPa)', ylab = 'LFM @ MWP = 0')

# Add lines for each species
for (sp in unique(spres$species)) {
  lines(MWPcrit_list[[sp]], lfm.sat.vec, lwd = 1)  # Add lines for each species
}

# Add species data points to the conceptual model plot
text(I(1 / model1.int) ~ minWP, data = spres,
     labels = spres$species, col = 'blue')  # Add species codes as labels
```

```{r, isocline_fig, eval = F}
# Source custom functions if needed
source(here('scripts', 'lfm_functions.R'))

# Read species results
#spres_old <- read.csv(here('results', 'species-results.csv'))

# Ensure 'spres' has all the necessary columns from the previous steps
spres <- traits_df %>% 
  filter(slope_type == "grand") %>% 
  mutate(model1.int = intercept,
         model1.slp = slope,  # Ensure slope is named 'model1.slp'
         #model2.int = int_sppstudy, 
        # model2_slp = slope_sppstudy, 
         SpCode6 = species, 
         minWP = minwp)

# Inspect the modified dataframe
head(spres)

# Generate a sequence of inverse LFM saturation values
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)

# Initialize an empty list to store critical MWP values for each species
MWPcrit_list <- list()

# Loop through each unique species and calculate the critical MWP using species-specific slopes
for (sp in unique(spres$species)) {
  
  # Get the species-specific slope from 'spres'
  species_slope <- spres %>% 
    filter(species == sp) %>% 
    pull(model1.slp)
  
  # Initialize a vector to hold critical MWP values for the current species
  MWPcrit <- c()
  
  # Calculate critical MWP for the current species
  for (i in 1:length(ilfm.sat.vec)) {
    MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.7)  # Use species-specific slope
  }
  
  # Store the results for each species in the list
  MWPcrit_list[[sp]] <- MWPcrit
}

# Example: Extract MWPcrit for a specific species (e.g., "species1")
# MWPcrit_list[["species1"]]

# Convert inverse LFM saturation values back to LFM
lfm.sat.vec <- 1 / ilfm.sat.vec

# Step 7: Plot the conceptual model curve
# This plot visualizes the relationship between minimum MWP and LFM based on the estimated slope and intercept
plot(MWPcrit, lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4),  # Set plot limits for axes
     type = 'l', lwd = .1, col = "blue",                                # Line plot with a thick line width
     xlab = 'Minimum MWP (MPa)',                            # X-axis label (MWP in MPa)
     ylab = 'LFM @ MWP = 0')                                # Y-axis label (LFM when MWP = 0)



# Step 8: Repeat the calculations for different LFM thresholds
# Here, different thresholds are used (e.g., 0.5, 1.0) to simulate how the relationship changes with LFM.


for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.62)  #60% LFM
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4), lwd = 1, col = "maroon")  # Add a line to the plot for this threshold



for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.77)    # New threshold of 1/.77 (e.g., 77% LFM)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4), lwd = 1, col = "goldenrod")  # Add a line for this threshold

# Step 9: Add species data points to the conceptual model plot
# The points represent observed data for different species and their corresponding MWP and LFM.
# Here, you can filter data by study or other criteria and plot them.
# Replace 'letters' with actual labels or data as needed
# You might filter by 'Coastal' or other specific groups depending on your dataset
# points(I(1 / model1.int) ~ minWP, data = spres[which(spres$study == 'Coastal'), ], pch = 19)

# # Add labels for species points to the plot (use species codes or other identifiers)
# text(I(1 / model1.int) ~ minWP, data = spres,   # Text labels instead of points for clarity
#      labels = letters)                          # Replace 'letters' with actual species labels or codes

#Add points
#points(I(1 / model1.int) ~ minWP, data = spres, pch = 19)

#-----------
# Plot species-specific data points
# We are using the 'minWP' (Minimum MWP) for each species and inverting the model intercepts (1 / model1.int) for plotting.
# Replace the 'letters' argument with the species codes from the 'SpCode6' column in 'spres' dataframe.


text(I(1 / model1.int) ~ minWP,  # Inverse of intercept plotted against minimum MWP
     data = spres,               # Data from the spres dataframe
     labels = spres$SpCode6,     # Use species codes from the SpCode6 column for labeling
     pos = 4, 
     size = .24)

#-----------
# Create a mapping of letters to species codes
letter_mapping <- data.frame(
  letter = letters[1:nrow(spres)],  # Use the first 'n' letters based on the number of rows in 'spres'
  species_code = spres$SpCode6     # Corresponding species codes from the 'SpCode6' column
)
```

#Q3: trait correlations

Question: How strongly are the species parameters associated with critical plant traits related to drought tolerance and access to water: Leaf Dry Matter Content (LDMC), water potential at 50% loss of conductivity (Ψ50), osmotic potential at turgor loss point (πTLP), and rooting depth?.

Set up plotting and data: 
```{r, warning = F}
#read in trait df.
#Data is mean from TRY, 
traits_df <- read_csv(here("data", "traits_rd_20250327.csv"))
```


```{r, warning = F}
#Attach trait data to model data: 
q3_df1 <- merge(traits_df, concept_params_df, by = ("species"), all = T) %>% 
 # select(-study) %>% 
  #filter(group == "species") %>% 
  filter(group == "grand") %>% 
  mutate(int_spp = intercept,
         intercept_lfm = 1/intercept,
         slope_spp = slope,
         min_lfm = minlfm,
         max_lfm = maxlfm, 
         min_mwp = minwp, 
         max_mwp = maxwp
         ) %>% 
  select(-date, -mwp, -lfm, -ilfm, -x1, -sp_site, -tissue_age) %>% 
  distinct()
```


```{r, warning = F}
pds_q3_df_raw <- read_csv(here('data', 'all-data-combined-predawns.csv')) %>% 
  clean_names() %>% 
  filter(!(species %in% c("PINJEF", "ABICON", "CALDEC")))

pds_q3_df_raw %>% 
  ggplot(aes(y = wp, x = lfm, color = species, shape = study)) +
  geom_point()
```


```{r, warning = F}
pds_q3_df <- pds_q3_df_raw %>% 
  group_by(species) %>% 
  filter(time %in% "pd") %>% 
  mutate(min_pd = min(wp, na.rm = T),
         max_pd = max(wp, na.rm = T)) %>% 
  select(-wp, -date, -lfm, -x1) %>% 
  distinct()
#add in predawns:
q3_df <- merge(q3_df1, pds_q3_df, by = c("species", "study"), all = T) %>% 
  select(-study, -study_nice, -sp_site, -tissue_age, -time) %>% 
  group_by(species) %>% 
  fill(c("min_pd", "max_pd"), .direction = "downup") %>% 
  distinct() 
```


```{r, warning = F}
#Function to view each relationship: 
library(ggplot2)
library(ggpmisc) # For stat_poly_eq
library(dplyr)
library(plotly)

# Define function to create plots for multiple y-variables
# Define function to create interactive plots
plot_all_relationships <- function(data, x_var, y_vars) {
  plots <- lapply(y_vars, function(y_var) {
    # Fit linear model
    model <- lm(reformulate(x_var, y_var), data = data)
    eqn <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "<br>R² = ", round(summary(model)$r.squared, 3), 
      "<br>p = ", signif(summary(model)$coefficients[2, 4], 3)
    )
    
    # Create ggplot
    p <- ggplot(data, aes_string(x = x_var, y = y_var)) +
      geom_point(aes(color = species, text = species)) +
      geom_smooth(method = "lm", se = FALSE) +
      labs(x = x_var, y = y_var, title = y_var) +
      theme_minimal()
    
    # Convert to Plotly and add annotation
    ggplotly(p, tooltip = "text") %>%
      layout(annotations = list(
        x = 0.05, y = 0.95, xref = "paper", yref = "paper",
        text = eqn, showarrow = FALSE, align = "left"
      ))
  })
  
  return(plots)
}

# Define y-variables
y_variables <- c("slope", "intercept", "intercept_lfm", "min_lfm", "min_mwp", "maxlfm", "min_pd", "max_pd")

#remove outlider Salvias: 
q3_df_outs <- q3_df %>% 
  filter(!(species %in% c("SALMEL", "SALLEU")))
```

Is TLP related to any model params?
```{r, warning = F}
# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "psi_tlp", y_variables)

# Display the plots
for (plot in plots) print(plot)
```


```{r, warning = F}
plots <- plot_all_relationships(q3_df_outs, "psi_tlp", y_variables)

# Display the plots
for (plot in plots) print(plot)
```

Is P50 related to any model params?
```{r, warning = F}

# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "plc50_stem", y_variables)

# Display the plots
for (plot in plots) print(plot)

plots <- plot_all_relationships(q3_df_outs, "plc50_stem", y_variables)

# Display the plots
for (plot in plots) print(plot)
```

Is LDMC related to any model params?
```{r, warning = F}

# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "ldmc", y_variables)

# Display the plots
for (plot in plots) print(plot)

plots <- plot_all_relationships(q3_df_outs, "ldmc", y_variables)

# Display the plots
for (plot in plots) print(plot)
```

Is SLA related to any model params?
```{r, warning = F}

# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "sla", y_variables)

# Display the plots
for (plot in plots) print(plot)

plots <- plot_all_relationships(q3_df_outs, "sla", y_variables)

# Display the plots
for (plot in plots) print(plot)
```

Is rooting depth related to any model params?
```{r, warning = F}

# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "max_rooting_depth_m", y_variables)

# Display the plots
for (plot in plots) print(plot)

plots <- plot_all_relationships(q3_df_outs, "max_rooting_depth_m", y_variables)
# Display the plots
for (plot in plots) print(plot)
```

Is rooting depth related to any traits? (Just try for fun)
```{r, warning = F}
y_variables <- c("ldmc", "plc50_stem", "psi_tlp", "sla", "minwp", "maxwp", "min_pd", "max_pd")
# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "max_rooting_depth_m", y_variables)

# Display the plots
for (plot in plots) print(plot)

#remove QUDO, hard to measure P50 and its driving the relationship. 
q3_df_outs <- q3_df %>% 
  filter(!(species %in% c("QUEDOU")))

plots <- plot_all_relationships(q3_df_outs, "max_rooting_depth_m", y_variables)

# Display the plots
for (plot in plots) print(plot)
#Doesnt make a difference. 
```

Is TLP related to P50?
```{r}
q3_df %>% ggplot(aes(y = plc50_stem, x = psi_tlp)) +
  geom_point() +
  stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
```

####Table SX. (traits)
```{r}
tablesx <- read_csv(here("data", "traits_rd_20250327.csv"))
tablesx

nrd <- tablesx %>% 
  select(max_rooting_depth_m) %>% 
  drop_na() %>% 
  count()
nrd

nplc50 <- tablesx %>% 
  select(plc50_stem) %>% 
  drop_na() %>% 
  count()
nplc50

n<- tablesx %>% 
  select(5) %>% 
  drop_na() %>% 
  count()
n
  
write_csv(tablesx, here("results", "figures", "tableSX_traits.csv"))
```

####Figure 5. (traits, grand)
```{r}
color_species =    scale_color_manual(values = c("#17154f", "#2f357c", "#6c5d9e", "#9d9cd5", "#b0799a", "#f6b3b0", "#e48171", "#bf3729", "#e69b00", "#f5bb50", "#ada43b", "#355828",
                                 "#5b859e", "#1e395f", "#75884b", "#1e5a46", "#df8d71", "#af4f2f", "#d48f90", "#732f30", "#ab84a5", "#59385c", "#d8b847", "#b38711","#b38651"))

q3_df_salvias <- q3_df %>% 
  filter(species %in% c("SALLEU", "SALMEL"))

q3_df_outs <- q3_df %>% 
  filter(!(species %in% c("SALLEU", "SALMEL")))

#P50 x Min MPA
model <- lm(min_mwp ~ plc50_stem, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(min_mwp ~ plc50_stem, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5a <- ggplot() +
  geom_point(data = q3_df, aes(y = min_mwp, x = plc50_stem, color = species)) +
  geom_point(data = q3_df_salvias, aes(y = min_mwp, x = plc50_stem, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(y = min_mwp, x = plc50_stem), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_outs, aes(y = min_mwp, x = plc50_stem), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = -9.75, y = -3.25, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = -9.75, y = -4.5, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Minimum Midday Water Potential (MPa)",
       x = "P50 (MPa)", 
       color = "Species") 
fig5a

#P50 x Min LFM
model <- lm(min_lfm ~ plc50_stem, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(min_lfm ~ plc50_stem, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5b <- ggplot() +
  geom_point(data = q3_df, aes(y = min_lfm, x = plc50_stem, color = species)) +
  # geom_point(data = q3_df_salvias, aes(y = min_lfm, x = plc50_stem, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(y = min_lfm, x = plc50_stem), method = "lm", se = F, color = "#ab84a5") +
  # geom_smooth(data = q3_df_outs, aes(y = min_lfm, x = plc50_stem), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = -9.75, y = 1.05, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  # annotate("text", x = -9.75, y = .9, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Minimum Seasonal LFM (%)",
       x = "P50 (MPa)", 
       color = "Species") 
fig5b

legend <- cowplot::get_legend(
  # create some space to the left of the legend
  fig5a + theme(legend.box.margin = margin(0, 0, 5, 0))
)

plots <- cowplot::plot_grid(fig5a + theme(legend.position = "none"), 
                   fig5b + theme(legend.position = "none"),
                   nrow = 1)

plots_legend_grandint <- cowplot::plot_grid(plots,
                   legend,
                   nrow = 1,
                   rel_widths = c(1,.275))

plots_legend_grandint

ggsave(plot = plots_legend_grandint, here::here("figures", "fig5.jpg"), dpi = 600)
```



#-----

#Species intercepts and slopes: 
```{r, warning = F}
#read in trait df.
#Data is mean from TRY, 
traits_df <- read_csv(here("data", "traits_rd_20250327.csv"))

#Attach trait data to model data: 
q3_df <- merge(traits_df, concept_params_df, by = ("species"), all = T) %>% 
  filter(group == "species") %>% 
  #filter(group == "grand") %>% 
  mutate(int_spp = intercept,
         intercept_lfm = 1/intercept,
         slope_spp = slope,
         min_lfm = minlfm,
         max_lfm = maxlfm, 
         min_mwp = minwp, 
         max_mwp = maxwp
         ) %>% 
  select(-date, -mwp, -lfm, -ilfm, -x1, -study, -sp_site, -tissue_age) %>% 
  distinct()
  
#Function to view each relationship: 
library(ggplot2)
library(ggpmisc) # For stat_poly_eq
library(dplyr)
library(plotly)

# Define function to create plots for multiple y-variables
# Define function to create interactive plots
plot_all_relationships <- function(data, x_var, y_vars) {
  plots <- lapply(y_vars, function(y_var) {
    # Fit linear model
    model <- lm(reformulate(x_var, y_var), data = data)
    eqn <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "<br>R² = ", round(summary(model)$r.squared, 3), 
      "<br>p = ", signif(summary(model)$coefficients[2, 4], 3)
    )
    
    # Create ggplot
    p <- ggplot(data, aes_string(x = x_var, y = y_var)) +
      geom_point(aes(color = species, shape = growth_form, text = species)) +
      geom_smooth(method = "lm", se = FALSE) +
      labs(x = x_var, y = y_var, title = y_var) +
      theme_minimal()
    
    # Convert to Plotly and add annotation
    ggplotly(p, tooltip = "text") %>%
      layout(annotations = list(
        x = 0.05, y = 0.95, xref = "paper", yref = "paper",
        text = eqn, showarrow = FALSE, align = "left"
      ))
  })
  
  return(plots)
}

# Define y-variables
y_variables <- c("slope", "intercept", "intercept_lfm", "min_lfm", "min_mwp")

#remove outlider Salvias: 
q3_df_outs <- q3_df %>% 
  filter(!(species %in% c("SALMEL", "SALLEU")))
```

Is TLP related to any model params?
```{r, warning = F}
# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "psi_tlp", y_variables)

# Display the plots
for (plot in plots) print(plot)
```


```{r, warning = F}
plots <- plot_all_relationships(q3_df_outs, "psi_tlp", y_variables)

# Display the plots
for (plot in plots) print(plot)
```

Is P50 related to any model params?
```{r, warning = F}

# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "plc50_stem", y_variables)

# Display the plots
for (plot in plots) print(plot)

plots <- plot_all_relationships(q3_df_outs, "plc50_stem", y_variables)

# Display the plots
for (plot in plots) print(plot)
```

Is LDMC related to any model params?
```{r, warning = F}

# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "ldmc", y_variables)

# Display the plots
for (plot in plots) print(plot)

plots <- plot_all_relationships(q3_df_outs, "ldmc", y_variables)

# Display the plots
for (plot in plots) print(plot)
```

Is SLA related to any model params?
```{r, warning = F}

# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "sla", y_variables)

# Display the plots
for (plot in plots) print(plot)

plots <- plot_all_relationships(q3_df_outs, "sla", y_variables)

# Display the plots
for (plot in plots) print(plot)
```

Is rooting depth related to any model params?
```{r, warning = F}

# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "max_rooting_depth_m", y_variables)

# Display the plots
for (plot in plots) print(plot)

plots <- plot_all_relationships(q3_df_outs, "max_rooting_depth_m", y_variables)
# Display the plots
for (plot in plots) print(plot)
```

Is rooting depth related to any traits? (Just try for fun)
```{r, warning = F}
y_variables <- c("ldmc", "plc50_stem", "psi_tlp", "sla")
# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "max_rooting_depth_m", y_variables)

# Display the plots
for (plot in plots) print(plot)

#remove QUDO, hard to measure P50 and its driving the relationship. 
q3_df_outs <- q3_df %>% 
  filter(!(species %in% c("QUEDOU")))

plots <- plot_all_relationships(q3_df_outs, "max_rooting_depth_m", y_variables)

# Display the plots
for (plot in plots) print(plot)
#Doesnt make a difference. 
```

####Figure SX. (traits, spp)
```{r}
color_species =    scale_color_manual(values = c("#17154f", "#2f357c", "#6c5d9e", "#9d9cd5", "#b0799a", "#f6b3b0", "#e48171", "#bf3729", "#e69b00", "#f5bb50", "#ada43b", "#355828",
                                 "#5b859e", "#1e395f", "#75884b", "#1e5a46", "#df8d71", "#af4f2f", "#d48f90", "#732f30", "#ab84a5", "#59385c", "#d8b847", "#b38711"))

q3_df_salvias <- q3_df %>% 
  filter(species %in% c("SALLEU", "SALMEL"))

q3_df_outs <- q3_df %>% 
  filter(!(species %in% c("SALLEU", "SALMEL")))
```

```{r}
#TLP x MaxLFM
model <- lm(intercept_lfm ~ psi_tlp, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(intercept_lfm ~ psi_tlp, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5a <- ggplot() +
  geom_point(data = q3_df, aes(y = intercept_lfm, x = psi_tlp, color = species)) +
  geom_point(data = q3_df_salvias, aes(y = intercept_lfm, x = psi_tlp, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(y = intercept_lfm, x = psi_tlp), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_outs, aes(y = intercept_lfm, x = psi_tlp), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = -3.525, y = 4.1, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = -3.525, y = 3.1, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Maximum LFM (Model Intercept)",
       x = "Turgor Loss Point (Mpa)", 
       color = "Species") 
fig5a
```


```{r}
#P50 x Min MPA
model <- lm(min_mwp ~ plc50_stem, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(min_mwp ~ plc50_stem, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5b <- ggplot() +
  geom_point(data = q3_df, aes(y = min_mwp, x = plc50_stem, color = species)) +
  geom_point(data = q3_df_salvias, aes(y = min_mwp, x = plc50_stem, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(y = min_mwp, x = plc50_stem), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_outs, aes(y = min_mwp, x = plc50_stem), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = -9.75, y = -3.25, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = -9.75, y = -4.5, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Minimum Midday Water Potential (MPa)",
       x = "P50 (MPa)", 
       color = "Species") 
fig5b

#P50 x Min LFM
model <- lm(min_lfm ~ plc50_stem, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(min_lfm ~ plc50_stem, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5c <- ggplot() +
  geom_point(data = q3_df, aes(y = min_lfm, x = plc50_stem, color = species)) +
  # geom_point(data = q3_df_salvias, aes(y = min_lfm, x = plc50_stem, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(y = min_lfm, x = plc50_stem), method = "lm", se = F, color = "#ab84a5") +
  # geom_smooth(data = q3_df_outs, aes(y = min_lfm, x = plc50_stem), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = -9.75, y = 1.05, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  # annotate("text", x = -9.75, y = .9, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Minimum Seasonal LFM (%)",
       x = "P50 (MPa)", 
       color = "Species") 
fig5c
```


```{r}
#LDMC x Max LFM
model <- lm(intercept_lfm ~ ldmc, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(intercept_lfm ~ ldmc, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5d <- ggplot() +
  geom_point(data = q3_df, aes(y = intercept_lfm, x = ldmc, color = species)) +
  geom_point(data = q3_df_salvias, aes(intercept_lfm, x = ldmc, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(intercept_lfm, x = ldmc), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_outs, aes(intercept_lfm, x = ldmc), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = .375, y = 4.25, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = .375, y = 3.25, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Maximum LFM (Model Intercept)",
       x = "LDMC (g)", 
       color = "Species") 
fig5d
```


```{r}
#slope x SLA
model <- lm(slope ~ sla, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(slope ~ sla, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5e <- ggplot() +
  geom_point(data = q3_df, aes(y = slope, x = sla, color = species)) +
  geom_point(data = q3_df_salvias, aes(y = slope, x = sla, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(y = slope, x = sla), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_outs, aes(y = slope, x = sla), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = 9.75, y = -.025, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = 9.75, y = -.095, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Slope",
       x = "SLA (cm2/g)", 
       color = "Species") +
  xlim(4.5, 14) +
  ylim(-.25, 0)

fig5e
```


```{r}
#Max LFM and SLA
model <- lm(intercept_lfm ~ sla, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(intercept_lfm ~ sla, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5f <- ggplot() +
  geom_point(data = q3_df, aes(y = intercept_lfm, x = sla, color = species)) +
  geom_point(data = q3_df_salvias, aes(y = intercept_lfm, x = sla, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(y = intercept_lfm, x = sla), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_outs, aes(y = intercept_lfm, x = sla), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = 4, y = 4.2, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = 4, y = 3.2, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Maximum LFM (Model Intercept)",
       x = "SLA (cm2/g)", 
       color = "Species") 
fig5f
```

####Combine:
```{r}
legend <- cowplot::get_legend(
  # create some space to the left of the legend
  fig5f + theme(legend.box.margin = margin(0, 0, 0, 0))
)
```

```{r}
plots <- cowplot::plot_grid(fig5a + theme(legend.position = "none"), 
                   #fig5b + theme(legend.position = "none"), 
                   #fig5c + theme(legend.position = "none"), 
                   fig5d + theme(legend.position = "none"), 
                   fig5e + theme(legend.position = "none"), 
                   fig5f + theme(legend.position = "none"),
                   nrow = 2)

plots_legend_int <- cowplot::plot_grid(plots,
                   legend,
                   rel_widths = c(1,.35))
plots_legend_int
ggsave(plot = plots_legend_int, here::here("figures", "figsx_spptraits.jpg"), dpi = 600, height = 6, width = 8)
```

##---------
```{r, eval = F}
## Preliminary analysis of 2021 Live Fuel Moisture (LFM) data

rm(list = ls())  # Remove all objects from the workspace to start fresh

library(ggplot2)  # Load ggplot2 package for advanced plotting capabilities
source(here('scripts', 'lfm_functions.R'))
# Source custom functions from external script

# Read in the combined dataset; 'as.is = TRUE' prevents strings from converting to factors
# 'row.names = 1' uses the first column as row names
lwa <- read.csv(here('data', 'all-data-combined.csv'))

# Calculate the inverse of LFM for modeling purposes
lwa$ilfm <- 1 / lwa$lfm

# Display the first few rows of the data to check if it's loaded correctly
head(lwa)

# Create a frequency table of the 'study' variable
table(lwa$study)

# Get a sorted list of unique study sites
sites <- sort(unique(lwa$study))

# Verify the number of observations per study
table(lwa$study)

# Check the total number of observations
nrow(lwa)

### Plotting by Site

# Define colors for each site for consistent plotting
scolors <- c("#B9C7E2", "#ECAB99",  "#5B6530", "#9484B1",  "#F1C100")  # Added color for SEKI

# Assign colors to each observation based on the study site
lwa$scolors <- scolors[match(lwa$study, sites)]

# Confirm that colors are assigned correctly
table(lwa$scolors)

# Randomly sample 1000 observations for plotting to avoid overplotting
rsamp <- sample(1:nrow(lwa), 1000)  # Sample from the full dataset

# Set up an empty plot with defined axes and limits
plot(lfm ~ mwp, data = lwa, type = 'n',
     xlab = 'Midday water potential (MPa)',
     ylab = 'Live fuel moisture',
     xlim = c(-8, 0), ylim = c(0, 3.5))

# Plot data points for each study site with different symbols and colors
points(lfm ~ mwp, data = lwa[lwa$study == 'Sedgwick', ],
       pch = 5, cex = 1, col = lwa$scolors[lwa$study == 'Sedgwick'])

points(lfm ~ mwp, data = lwa[lwa$study == 'StuntRanch', ],
       pch = 15, cex = 1, col = lwa$scolors[lwa$study == 'StuntRanch'])

points(lfm ~ mwp, data = lwa[lwa$study == 'Pepperwood', ],
       pch = 19, cex = 1.2, col = lwa$scolors[lwa$study == 'Pepperwood'])

# Include SEKI in the points plotting
points(lfm ~ mwp, data = lwa[lwa$study == 'SEKI', ],
       pch = 17, cex = 1.2, col = lwa$scolors[lwa$study == 'SEKI'])  # Different symbol for SEKI

# Add a legend to the plot
legend(-7, 3, sites, fill = NULL, border = 'white')

# Add custom legend symbols corresponding to each site
points(rep(-6.7, length(sites)), seq(2.84, 2.64 - 0.2 * (length(sites) - 1), length.out = length(sites)),
       pch = c(19, 5, 15, 17), col = scolors, cex = 2)  # Added SEKI symbol





# Prepare for analyses by site and species
sites <- sort(unique(lwa$Sp.Site))  # Re-affirm the list of species at each site
table(lwa$study)  # Check the distribution of observations

# Create a new logical column indicating if the site is coastal
lwa$coastal <- TRUE
#lwa$coastal[which(lwa$study == 'SEKI')] <- FALSE  # Mark 'SEKI' as non-coastal

# Initialize lists and labels for storing results
rsel <- list()  # List to hold row indices for each analysis subset
slabel <- sites  # Labels corresponding to each subset

# Populate 'rsel' with row indices for each site
for (i in 1:length(sites)) {
  rsel[[i]] <- which(lwa$Sp.Site == sites[i])
}

# # Add indices for coastal sites
# i <- i + 1
# rsel[[i]] <- which(lwa$coastal)

# Add indices for all data
i <- i + 1
#rsel[[i]] <- 1:nrow(lwa)

# Update labels accordingly
slabel <- c(slabel)

# Confirm that 'rsel' and 'slabel' are correctly set up
length(rsel)
slabel

# Initialize data structures to store statistical results
stres <- data.frame(
  study = slabel,
  Nspec = NA,
  Nobs = NA,
  BIC.no.int = NA,
  common.slope = NA,
  BIC.int = NA
)

spres <- list()  # List to hold species-specific results
scoeff <- list()  # List to hold coefficients from models
pvals <- list()  # List to hold predicted values from models

# Define parameters for model forms and factors
pform <- 'Inv'  # Model form: 'Reg' for regular, could be 'Inv' for inverse
sppFac <- 'SpeciesSite'  # Species factor, could be 'Species' or 'SpeciesSite'
slpModel <- 'SpSpecific'  # Slope model: 'Common' or 'SpSpecific'

# Initialize the loop counter
i = 31

# Loop through each subset defined in 'rsel'
for (i in 1:length(rsel)) {
  # Subset the data for the current selection
  td <- lwa[rsel[[i]], ]
  
  # Adjust species factor if necessary
  if (sppFac == 'SpeciesSite') td$Species <- td$Sp.Site
  
  # Record the number of observations and species
  stres$Nobs[i] <- nrow(td)
  spp <- sort(unique(td$Species))
  stres$Nspec[i] <- length(spp)
  
  # Prepare a dataframe to store species-specific results
  spres[[i]] <- data.frame(
    study = rep(slabel[i], length(spp)),
    species = spp,
    Nobs = NA,
    minWP = NA,
    critWP = NA,
    minLFM = NA,
    model1.int = NA,
    model1.slp = NA,
    model2.int = NA,
    model2.slp = NA
  )
  
  # Fit a model without interaction to test if species have different intercepts
  fit1 <- glm(ilfm ~ mwp, data = td)
  stres$BIC.no.int[i] <- BIC(fit1)  # Store Bayesian Information Criterion
  stres$common.slope[i] <- coefficients(fit1)[2]  # Common slope across species
  scoeff[[i]] <- coefficients(fit1)  # Store coefficients
  pvals[[i]] <- fit1$fitted.values  # Store fitted values
  
  # Extract and store intercepts for each species
  spres[[i]]$model1.int[1] <- coefficients(fit1)[1]
  spres[[i]]$model1.int[-1] <- coefficients(fit1)[1] + coefficients(fit1)[-c(1:2)]
  spres[[i]]$model1.slp <- coefficients(fit1)[2]
  
}

 s=1
  for (s in 1:length(spp))
  {
    r1 <- which(td$Species==spp[s])
    spres[[i]]$Nobs[s] <- length(r1)
    spres[[i]]$minWP[s] <- min(td$mwp[r1],na.rm=T)
    spres[[i]]$minLFM[s] <- min(td$lfm[r1],na.rm=T)
    #print(c(i,length(r1)))
    fit <- lm(ilfm[r1]~mwp[r1],data=td)
    cfit <- coefficients(fit)
    spres[[i]][s,c('model2.int','model2.slp')] <- cfit
    mm <- range(td$mwp[r1],na.rm=T)
    yy <- cfit[1] + cfit[2]*mm
    
    if (slpModel == 'SpSpecific') {
      xy <- inversePlotData(mm,cfit) 
      x0y <- inversePlotData(c(mm[2],0),cfit) 
      spres[[i]]$critWP[s] <- solveForX(cfit,yval=1/0.7)
    } else {
      cs <- c(spres[[i]]$model1.int[s],spres[[i]]$model1.slp[s])
      xy <- inversePlotData(mm,cs)
      x0y <- inversePlotData(c(mm[2],0),cs)
      spres[[i]]$critWP[s] <- solveForX(cs,yval=1/0.7)
    }
    
    if (pform=='Reg') {
      lines(LFM~MWP,data=xy,col=td$scolors[r1[1]],lwd=2) 
      lines(LFM~MWP,data=x0y,col=td$scolors[r1[1]],lwd=2,lty=3) 
    } else {
      lines(iLFM~MWP,data=xy,col=td$scolors[r1[1]],lwd=2)
      lines(iLFM~MWP,data=x0y,col=td$scolors[r1[1]],lwd=2,lty=3) 
    }
  }


# Display the statistical results
stres
spres[[1]]  # Results for the first subset
spres[[4]]  # Results for the fourth subset (i = 4)

# Combine species-specific results into one dataframe
spres.all <- spres[[1]]
for (i in 2:length(spres)) spres.all <- rbind(spres.all, spres[[i]])

# Check dimensions and content of the combined results
dim(spres.all)
table(spres.all$study)
head(spres.all)
tail(spres.all)

# Create a shortened species code for easier reference
spres.all$SpCode6 <- substr(spres.all$species, 1, 6)

spres.all <- spres.all %>% 
  separate(study, c("spp", "study"), sep = "_")
```
#---------

#Davids code: 

```{r, eval = F}
## Preliminary analysis of 2021 Live Fuel Moisture (LFM) data

#rm(list = ls())  # Remove all objects from the workspace to start fresh

library(ggplot2)  # Load ggplot2 package for advanced plotting capabilities
source(here('scripts', 'lfm_functions.R'))
# Source custom functions from external script

# Read in the combined dataset; 'as.is = TRUE' prevents strings from converting to factors
# 'row.names = 1' uses the first column as row names
lwa <- read.csv(here('data', 'all-data-combined.csv'))

# Calculate the inverse of LFM for modeling purposes
lwa$ilfm <- 1 / lwa$lfm

# Display the first few rows of the data to check if it's loaded correctly
head(lwa)

# Create a frequency table of the 'study' variable
table(lwa$study)

# Remove data from the 'SEKI' study as per analysis requirement
lwa <- lwa[-which(lwa$study == 'SEKI'),]

# Get a sorted list of unique study sites
sites <- sort(unique(lwa$study))

# Verify the number of observations per study after removal
table(lwa$study)

# Check the total number of observations
nrow(lwa)

### Plotting by Site

# Define colors for each site for consistent plotting
scolors <- c('orange', 'black', 'blue')

# Assign colors to each observation based on the study site
lwa$scolors <- scolors[match(lwa$study, sites)]

# Confirm that colors are assigned correctly
table(lwa$scolors)

# Randomly sample 1000 observations for plotting to avoid overplotting
rsamp <- sample(1:1000, 1000)

# Set up an empty plot with defined axes and limits
plot(lfm ~ mwp, data = lwa, type = 'n',
     xlab = 'Midday water potential (MPa)',
     ylab = 'Live fuel moisture',
     xlim = c(-8, 0), ylim = c(0, 3.5))

# Uncomment the line below to plot sampled points with colors based on study site
# points(lfm ~ mwp, data = lwa[rsamp, ], pch = 1, cex = 1, col = lwa$scolors)

# Plot data points for each study site with different symbols and colors
points(lfm ~ mwp, data = lwa[lwa$study == 'Sedgwick', ],
       pch = 5, cex = 1, col = lwa$scolors[lwa$study == 'Sedgwick'])

points(lfm ~ mwp, data = lwa[lwa$study == 'StuntRanch', ],
       pch = 15, cex = 1, col = lwa$scolors[lwa$study == 'StuntRanch'])

points(lfm ~ mwp, data = lwa[lwa$study == 'Pepperwood', ],
       pch = 19, cex = 1.2, col = lwa$scolors[lwa$study == 'Pepperwood'])

# Add a legend to the plot
legend(-7, 3, sites, fill = NULL, border = 'white')

# Add custom legend symbols corresponding to each site
points(rep(-6.7, 3), c(2.84, 2.64, 2.44),
       pch = c(19, 5, 15), col = scolors, cex = 2)

# Prepare for analyses by site
sites <- sort(unique(lwa$study))  # Re-affirm the list of study sites
table(lwa$study)  # Check the distribution of observations

# Create a new logical column indicating if the site is coastal
lwa$coastal <- TRUE
lwa$coastal[which(lwa$study == 'SEKI')] <- FALSE  # Mark 'SEKI' as non-coastal

# Initialize lists and labels for storing results
rsel <- list()  # List to hold row indices for each analysis subset
slabel <- sites  # Labels corresponding to each subset

# Populate 'rsel' with row indices for each site
for (i in 1:length(sites)) {
  rsel[[i]] <- which(lwa$study == sites[i])
}

# Add indices for coastal sites
i <- i + 1
rsel[[i]] <- which(lwa$coastal)

# Add indices for all data
i <- i + 1
rsel[[i]] <- 1:nrow(lwa)

# Update labels accordingly
slabel <- c(slabel, 'Coastal', 'All')

# Confirm that 'rsel' and 'slabel' are correctly set up
length(rsel)
slabel

# Initialize data structures to store statistical results
stres <- data.frame(
  study = slabel,
  Nspec = NA,
  Nobs = NA,
  BIC.no.int = NA,
  common.slope = NA,
  BIC.int = NA
)

spres <- list()  # List to hold species-specific results
scoeff <- list()  # List to hold coefficients from models
pvals <- list()  # List to hold predicted values from models

# Define parameters for model forms and factors
pform <- 'Reg'  # Model form: 'Reg' for regular, could be 'Inv' for inverse
sppFac <- 'SpeciesSite'  # Species factor, could be 'Species' or 'SpeciesSite'
slpModel <- 'SpSpecific'  # Slope model: 'Common' or 'SpSpecific'

# Initialize the loop counter
i = 4

# Loop through each subset defined in 'rsel'
# For demonstration, only running for i = 4
# Uncomment the loop below to run for all subsets
 for (i in 1:length(rsel))
#for (i in 4:4) 
  {
  # Subset the data for the current selection
  td <- lwa[rsel[[i]], ]
  
  # Adjust species factor if necessary
  if (sppFac == 'SpeciesSite') td$Species <- td$Sp.Site
  
  # Record the number of observations and species
  stres$Nobs[i] <- nrow(td)
  spp <- sort(unique(td$Species))
  stres$Nspec[i] <- length(spp)
  
  # Prepare a dataframe to store species-specific results
  spres[[i]] <- data.frame(
    study = rep(slabel[i], length(spp)),
    species = spp,
    Nobs = NA,
    minWP = NA,
    critWP = NA,
    minLFM = NA,
    model1.int = NA,
    model1.slp = NA,
    model2.int = NA,
    model2.slp = NA
  )
  
  # Fit a model without interaction to test if species have different intercepts
  fit1 <- glm(ilfm ~ mwp + Species, data = td)
  stres$BIC.no.int[i] <- BIC(fit1)  # Store Bayesian Information Criterion
  stres$common.slope[i] <- coefficients(fit1)[2]  # Common slope across species
  scoeff[[i]] <- coefficients(fit1)  # Store coefficients
  pvals[[i]] <- fit1$fitted.values  # Store fitted values
  
  # Extract and store intercepts for each species
  spres[[i]]$model1.int[1] <- coefficients(fit1)[1]
  spres[[i]]$model1.int[-1] <- coefficients(fit1)[1] + coefficients(fit1)[-c(1:2)]
  spres[[i]]$model1.slp <- coefficients(fit1)[2]
  
  # Fit a model with interaction to test if species have different slopes
  fit2 <- glm(ilfm ~ mwp * Species, data = td)
  stres$BIC.int[i] <- BIC(fit2)
```

Plot transformed and untransformed values: 
```{r, eval = F}
# Set up plotting parameters
  op = par(mar = c(5, 5, 3, 1))
  
  # Fit a simple model for plotting purposes
  fit <- glm(ilfm ~ mwp, data = td)
  mm <- range(td$mwp, na.rm = TRUE)
  summary(fit)
  
  # Generate data for plotting the inverse relationship
  xy <- inversePlotData(mm, coefficients(fit))
  
  # Plot the data and model fit
  if (pform == 'Reg') {
    # Plot regular LFM vs. MWP
    plot(lfm ~ mwp, data = td, main = slabel[i],
         xlim = c(-8, 0), ylim = c(0, 4),
         ylab = 'LFM', xlab = 'MWP')
    abline(h = 0.7, lty = 2)  # Add horizontal line at LFM = 0.7
    lines(LFM ~ MWP, data = xy, lwd = 3, col = 'red')  # Plot model fit
  } else {
    # Plot inverse LFM vs. MWP
    plot(ilfm ~ mwp, data = td, main = slabel[i],
         xlim = c(-8, 0), ylim = c(0, 2.5),
         ylab = '1/LFM', xlab = 'MWP')
    abline(h = 1 / 0.7, lty = 2)  # Threshold line at inverse LFM = 1/0.7
    lines(iLFM ~ MWP, data = xy, lwd = 3, col = 'red')  # Plot model fit
  }
  
  # Calculate mean midday water potential
  mean(td$mwp, na.rm = TRUE)
  
  # Loop through each species to analyze species-specific relationships
  s = 1
  for (s in 1:length(spp)) {
    # Select data for the current species
    r1 <- which(td$Species == spp[s])
    
    # Record the number of observations and minimum values
    spres[[i]]$Nobs[s] <- length(r1)
    spres[[i]]$minWP[s] <- min(td$mwp[r1], na.rm = TRUE)
    spres[[i]]$minLFM[s] <- min(td$lfm[r1], na.rm = TRUE)
    
    # Fit a linear model for the species
    fit <- lm(ilfm[r1] ~ mwp[r1], data = td)
    cfit <- coefficients(fit)
    spres[[i]][s, c('model2.int', 'model2.slp')] <- cfit  # Store coefficients
    
    # Determine the range of MWP for plotting
    mm <- range(td$mwp[r1], na.rm = TRUE)
    yy <- cfit[1] + cfit[2] * mm  # Calculate fitted values
    
    # Depending on slope model, calculate inverse plot data and critical WP
    if (slpModel == 'SpSpecific') {
      xy <- inversePlotData(mm, cfit)
      x0y <- inversePlotData(c(mm[2], 0), cfit)
      spres[[i]]$critWP[s] <- solveForX(cfit, yval = 1 / 0.7)
    } else {
      cs <- c(spres[[i]]$model1.int[s], spres[[i]]$model1.slp[s])
      xy <- inversePlotData(mm, cs)
      x0y <- inversePlotData(c(mm[2], 0), cs)
      spres[[i]]$critWP[s] <- solveForX(cs, yval = 1 / 0.7)
    }
    
    # Add species-specific lines to the plot
    if (pform == 'Reg') {
      lines(LFM ~ MWP, data = xy, col = td$scolors[r1[1]], lwd = 2)
      lines(LFM ~ MWP, data = x0y, col = td$scolors[r1[1]], lwd = 2, lty = 3)
    } else {
      lines(iLFM ~ MWP, data = xy, col = td$scolors[r1[1]], lwd = 2)
      lines(iLFM ~ MWP, data = x0y, col = td$scolors[r1[1]], lwd = 2, lty = 3)
    }
  }
  par(op)  # Reset plotting parameters
}

# Display the statistical results
stres
spres[[1]]  # Results for the first subset
spres[[4]]  # Results for the fourth subset (i = 4)

# Combine species-specific results into one dataframe
spres.all <- spres[[1]]
for (i in 2:length(spres)) spres.all <- rbind(spres.all, spres[[i]])

# Check dimensions and content of the combined results
dim(spres.all)
table(spres.all$study)
head(spres.all)
tail(spres.all)

# Create a shortened species code for easier reference
spres.all$SpCode6 <- substr(spres.all$species, 1, 6)
```

Correlate species traits with physiological measurements

```{r,eval = F}
# Subset the results to coastal sites
td <- spres.all[which(spres.all$study == 'Coastal'), ]
dim(td)

# Plot minimum LFM against model intercept
plot(minLFM ~ I(1 / model1.int), data = td)
abline(h = 0.7)  # Add horizontal line at LFM = 0.7

# Plot minimum LFM against minimum water potential
plot(minLFM ~ minWP, data = td)
abline(h = 0.7)

# Plot model intercept against minimum water potential
plot(I(1 / model1.int) ~ minWP, data = td)
abline(h = 0.7)

# Fit a generalized linear model
fit <- glm(minLFM ~ minWP + model1.int, data = td)
summary(fit)
plot(fit)  # Diagnostic plots

# Save the statistical summaries to CSV files
write.csv(here(stres, 'results', 'summary-results.csv'))
write.csv(here(spres.all, 'results', 'species-results.csv'))

# Load species traits data
spresc <- spres.all[which(spres.all$study == 'Coastal'), ]
spt <- read.csv(here('data', 'species-traits.csv'))
names(spt)

# Match species codes and merge trait data
s2s <- match(spresc$SpCode6, spt$SpCode)
spresc$PLC50.stem <- spt$PLC50.stem[s2s]
spresc$PSI.TLP <- spt$PSI.TLP[s2s]
spresc$LDMC <- spt$LDMC[s2s]

names(spresc)

# Plotting relationships between traits and physiological measurements
op = par(mfrow = c(1, 2))

# Plot minimum WP against stem PLC50
plot(minWP ~ PLC50.stem, data = spresc, pch = 19,
     xlab = 'PLC50 (MPa)', ylab = 'Minimum MWP (MPa)')
cor(spresc$minWP, spresc$PLC50.stem, use = 'pair')  # Correlation coefficient

# Identify and exclude outliers (e.g., certain species)
rsel <- which(spresc$SpCode6 %in% c('SALLEU', 'SALMEL'))
cor(spresc$minWP[-c(rsel)], spresc$PLC50.stem[-c(rsel)], use = 'pair')
points(minWP ~ PLC50.stem, data = spresc[rsel, ], pch = 1, cex = 2)

# Plot model intercept against osmotic potential at turgor loss point (TLP)
plot(I(1 / model1.int) ~ PSI.TLP, data = spresc, pch = 19,
     xlab = 'Osmotic potential at TLP (MPa)',
     ylab = 'LFM at MWP = 0')
cor(1 / spresc$model1.int, spresc$PSI.TLP, use = 'pair')

par(op)  # Reset plotting parameters

# Plot minimum LFM against osmotic potential at TLP
plot(minLFM ~ PSI.TLP, data = spresc, pch = 19,
     xlab = 'Osmotic potential at TLP (MPa)',
     ylab = 'LFM at MWP = 0')
cor(spresc$minLFM, spresc$PSI.TLP, use = 'pair')
cor(spresc$minLFM, spresc$PLC50.stem, use = 'pair')
```

Conceptual Model
```{r, eval = F}
# Source custom functions again if needed
source(here('scripts', 'lfm_functions.R'))

# Read species results
spres <- read.csv(here('results', 'species-results.csv'))
head(spres)

# Define a common slope for the conceptual model
slp <- -0.198

# Generate a sequence of inverse LFM saturation values
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 25)

# Initialize a vector to hold critical MWP values
MWPcrit <- c()

# Calculate critical MWP for different LFM thresholds
for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], slp), 1 / 0.7)
}

# Convert inverse LFM saturation values back to LFM
lfm.sat.vec <- 1 / ilfm.sat.vec

# Plot the conceptual model curve
plot(MWPcrit, lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4),
     type = 'l', lwd = 2,
     xlab = 'Minimum MWP (MPa)', ylab = 'LFM @ MWP = 0')

# Repeat calculations for different LFM thresholds (e.g., 0.5 and 1.0)
for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], slp), 1 / 0.5)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4), lwd = 1)

for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], slp), 1 / 1)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4), lwd = 1)

# Add species data points to the conceptual model plot
# Note: Replace 'letters' with actual labels or data as needed
# points(I(1 / model1.int) ~ minWP, data = spres[which(spres$study == 'Coastal'), ], pch = 19)
text(I(1 / model1.int) ~ minWP, data = spres[which(spres$study == 'Coastal'), ],
     labels = letters)

#### END HERE
### 'spres.all' summarizes all results by site and species

```

#-----


```{r, eval = F}
##2) Create a dataframe with species, study, or combined slopes and intercepts. 

# Load necessary libraries
library(tidyverse)
library(janitor)  # For clean_names function

# Initialize the final dataframe to store results
final_df1 <- lwa %>%
  select(Species, study, Sp.Site) %>%
  distinct()

# Function to fit model and extract slope & intercept
fit_model <- function(data, formula) {
  model <- glm(formula, data = data)
  coef(model)[1:2]  # return intercept and slope
}

# Model 1: Fit for each Sp.Site
sp_site_model <- lwa %>%
  group_by(Sp.Site) %>%
  do(model = fit_model(., ilfm ~ mwp)) %>%
  mutate(int_sppstudy = model[1],
         slope_sppstudy = model[2]) %>%
  select(Sp.Site, int_sppstudy, slope_sppstudy)

# Extract minimum mwp and lfm values
min_values <- lwa %>%
  group_by(Sp.Site) %>%
  mutate(min_mwp = min(mwp, na.rm = TRUE),
         min_lfm = min(lfm, na.rm = TRUE),
         n = n()) %>%
  select(Sp.Site, min_mwp, min_lfm, n)

# Model 2: Fit for each study
study_model <- lwa %>%
  group_by(study) %>%
  do(model = fit_model(., ilfm ~ mwp)) %>%
  mutate(int_study = model[1],
         slope_study = model[2]) %>%
  select(study, int_study, slope_study)

# Model 3: Fit for each species
species_model <- lwa %>%
  group_by(Species) %>%
  do(model = fit_model(., ilfm ~ mwp)) %>%
  mutate(int_spp = model[1],
         slope_spp = model[2]) %>%
  select(Species, int_spp, slope_spp)

# Model 4: Fit all data with different intercepts for each Species and the same slope across all species
all_data_model <- glm(ilfm ~ mwp + factor(Species), data = lwa)

# Extract intercepts and the shared slope from the model coefficients
species_intercepts <- coef(all_data_model)[grep("Species", names(coef(all_data_model)))]
baseline_intercept <- coef(all_data_model)["(Intercept)"]
shared_slope <- coef(all_data_model)["mwp"]

# Create a dataframe for species intercepts, adjusting by adding the baseline intercept
species_intercepts_df <- data.frame(
  Species = c(levels(as.factor(lwa$Species))[1], levels(as.factor(lwa$Species))[-1]),  # Include baseline species
  int_all = c(baseline_intercept, species_intercepts + baseline_intercept)
)

# Add the shared slope across all species as a single value
species_intercepts_df <- species_intercepts_df %>%
  mutate(slope_all = shared_slope)

# Model 5: Fit data filtered where group == "Coastal" with different intercepts for each Species and the same slope
coastal_data <- lwa %>%
  filter(group == "Coastal")

coastal_model <- glm(ilfm ~ mwp + factor(Species), data = coastal_data)

# Extract intercepts and the shared slope from the Coastal model coefficients
coastal_species_intercepts <- coef(coastal_model)[grep("Species", names(coef(coastal_model)))]
coastal_baseline_intercept <- coef(coastal_model)["(Intercept)"]
coastal_shared_slope <- coef(coastal_model)["mwp"]

# Create a dataframe for Coastal species intercepts, adjusting by adding the baseline intercept
coastal_intercepts_df <- data.frame(
  Species = c(levels(as.factor(coastal_data$Species))[1], levels(as.factor(coastal_data$Species))[-1]),  # Include baseline species
  int_all_coastal = c(coastal_baseline_intercept, coastal_species_intercepts + coastal_baseline_intercept)
)

# Add the shared slope across all Coastal species as a single value
coastal_intercepts_df <- coastal_intercepts_df %>%
  mutate(slope_all_coastal = coastal_shared_slope)

# Combine all results into the final dataframe
final_df <- final_df1 %>%
  left_join(sp_site_model, by = "Sp.Site") %>%
  left_join(min_values, by = "Sp.Site") %>%
  left_join(study_model, by = "study") %>%
  left_join(species_model, by = "Species") %>%
  left_join(species_intercepts_df, by = "Species") %>%
  left_join(coastal_intercepts_df, by = "Species") %>%
  clean_names() %>%
  distinct() %>%
  mutate(min_ilfm = 1 / min_lfm)

# Display the final dataframe
print(final_df)

# Plotting slope vs intercept colored by study
final_df %>%
  ggplot(aes(y = int_sppstudy, x = slope_sppstudy, color = study)) +
  geom_point()

# Another plot for visualization
final_df %>%
  ggplot(aes(y = int_sppstudy, x = slope_sppstudy, color = study)) +
  geom_point()

#Just get columns we want, and then make a nice table of the slopes and ints of individual species
mods_df <- final_df %>% 
  select(1:3, min_mwp, min_lfm, min_ilfm, n, slope_all, int_all, slope_all_coastal, int_all_coastal, slope_spp, int_spp)


```

#-----


<!-- Rewrite code so that it just gets the slope from a run using all species independantly:  -->

<!-- ```{r} -->
<!-- summary(lwa) -->
<!-- ``` -->


<!-- 1) Model running inverse LFM -->
<!-- ```{r} -->
<!-- lwa_new <- lwa  -->

<!-- # Prepare for analyses by site -->
<!-- sites <- sort(unique(lwa$study))  # Re-affirm the list of study sites -->
<!-- table(lwa$study)  # Check the distribution of observations -->

<!-- # Create a new logical column indicating if the site is coastal -->
<!-- lwa$coastal <- TRUE -->
<!-- lwa$coastal[which(lwa$study == 'SEKI')] <- FALSE  # Mark 'SEKI' as non-coastal -->

<!-- # Initialize lists and labels for storing results -->
<!-- rsel <- list()  # List to hold row indices for each analysis subset -->
<!-- slabel <- sites  # Labels corresponding to each subset -->

<!-- # Populate 'rsel' with row indices for each site -->
<!-- for (i in 1:length(sites)) { -->
<!--   rsel[[i]] <- which(lwa$study == sites[i]) -->
<!-- } -->

<!-- # Add indices for coastal sites -->
<!-- i <- i + 1 -->
<!-- rsel[[i]] <- which(lwa$coastal) -->

<!-- # Add indices for all data -->
<!-- i <- i + 1 -->
<!-- rsel[[i]] <- 1:nrow(lwa) -->

<!-- # Update labels accordingly -->
<!-- slabel <- c(slabel, 'Coastal', 'All') -->

<!-- # Confirm that 'rsel' and 'slabel' are correctly set up -->
<!-- length(rsel) -->
<!-- slabel -->

<!-- # Initialize data structures to store statistical results -->
<!-- stres <- data.frame( -->
<!--   study = slabel, -->
<!--   Nspec = NA, -->
<!--   Nobs = NA, -->
<!--   BIC.no.int = NA, -->
<!--   common.slope = NA, -->
<!--   BIC.int = NA -->
<!-- ) -->

<!-- spres <- list()  # List to hold species-specific results -->
<!-- scoeff <- list()  # List to hold coefficients from models -->
<!-- pvals <- list()  # List to hold predicted values from models -->

<!-- # Define parameters for model forms and factors -->
<!-- pform <- 'Inv'  # Model form: 'Reg' for regular, could be 'Inv' for inverse -->
<!-- sppFac <- 'Species'  # Species factor, could be 'Species' or 'SpeciesSite' -->
<!-- slpModel <- 'SpSpecific'  # Slope model: 'Common' or 'SpSpecific' -->

<!-- # Initialize the loop counter -->
<!-- i = length(spres) -->

<!-- # Loop through each subset defined in 'rsel' -->
<!-- for (i in 1:length(rsel)) { -->
<!--   # Subset the data for the current selection -->
<!--   td <- lwa[rsel[[i]], ] -->

<!--   # Adjust species factor if necessary so that if species occur at different sites they are treated differently -->
<!--   if (sppFac == 'SpeciesSite') td$species <- td$sp_site -->

<!--   # Record the number of observations and species -->
<!--   stres$Nobs[i] <- nrow(td) -->
<!--   spp <- sort(unique(td$species)) -->
<!--   stres$Nspec[i] <- length(spp) -->

<!--   # Prepare a dataframe to store species-specific results -->
<!--   spres[[i]] <- data.frame( -->
<!--     study = rep(slabel[i], length(spp)), -->
<!--     species = spp, -->
<!--     Nobs = NA, -->
<!--     minWP = NA, -->
<!--     critWP = NA, -->
<!--     minLFM = NA, -->
<!--     model1.int = NA, -->
<!--     model1.slp = NA, -->
<!--     model2.int = NA, -->
<!--     model2.slp = NA -->
<!--   ) -->

<!--   # Fit a model without interaction to test if species have different intercepts -->
<!--   fit1 <- glm(ilfm ~ mwp * species, data = td) -->
<!--   stres$BIC.no.int[i] <- BIC(fit1)  # Store Bayesian Information Criterion -->
<!--   stres$common.slope[i] <- coefficients(fit1)[2]  # Common slope across species -->
<!--   scoeff[[i]] <- coefficients(fit1)  # Store coefficients -->
<!--   pvals[[i]] <- fit1$fitted.values  # Store fitted values -->

<!-- # Extract and store intercepts for each species -->
<!--   spres[[i]]$model1.int[1] <- coefficients(fit1)[1] -->
<!--   spres[[i]]$model1.int[-1] <- coefficients(fit1)[1] + coefficients(fit1)[-c(1:2)] -->
<!--   spres[[i]]$model1.slp <- coefficients(fit1)[2] -->

<!--   # Fit a model with interaction to test if species have different slopes -->
<!--   fit2 <- glm(ilfm ~ mwp * species, data = td) -->
<!--   stres$BIC.int[i] <- BIC(fit2) -->

<!-- # Display the statistical results -->
<!-- stres -->
<!-- spres[[1]]  # Results for the first subset -->
<!-- spres[[4]]  # Results for the fourth subset (i = 4) -->

<!-- # Combine species-specific results into one dataframe -->
<!-- spres.all <- spres[[1]] -->
<!-- for (i in 2:length(spres)) spres.all <- rbind(spres.all, spres[[i]]) -->

<!-- } -->

<!-- # Check dimensions and content of the combined results -->
<!-- dim(spres.all) -->
<!-- table(spres.all$study) -->
<!-- head(spres.all) -->
<!-- tail(spres.all) -->

<!-- # Create a shortened species code for easier reference -->
<!-- spres.all$SpCode6 <- substr(spres.all$species, 1, 6) -->

<!-- #Select only the columns that we need:  -->
<!-- coef_values_df <- spres.all %>%  -->
<!--  # filter(study == "All") %>%  -->
<!--   select(study, species, model1.int, model1.slp) %>%  -->
<!--   separate(species, into = c("species", "study2"), sep = "_") %>%  -->
<!--   select(-study2) -->
<!-- ``` -->

<!-- Plots: -->

<!-- ```{r} -->
<!-- # Set up plotting parameters -->
<!--   op = par(mar = c(5, 5, 3, 1)) -->

<!--   # Fit a simple model for plotting purposes -->
<!--  fit <- glm(ilfm ~ mwp, data = td) -->
<!--  mm <- range(td$mwp, na.rm = TRUE) -->
<!--  summary(fit) -->

<!--   # Generate data for plotting the inverse relationship -->
<!--   xy <- inversePlotData(mm, coefficients(fit)) -->

<!-- pform <- "Reg" -->

<!-- # # Plot the data and model fit -->
<!--   if (pform == 'Reg') { -->
<!--     # Plot regular LFM vs. MWP -->
<!--     plot(lfm ~ mwp, data = td, main = slabel[i], -->
<!--          xlim = c(-8, 0), ylim = c(0, 4), -->
<!--          ylab = 'LFM', xlab = 'MWP') -->
<!--     abline(h = 0.7, lty = 2)  # Add horizontal line at LFM = 0.7 -->
<!--     lines(LFM ~ MWP, data = xy, lwd = 3, col = 'red')  # Add fitted line -->
<!--     points(lfm ~ mwp, data = td, pch = 19, col = 'black')  # Data points -->

<!--     # Add species-specific lines colored by site -->
<!--     for (species in spp) { -->
<!--       species_data <- td[td$species == species, ] -->
<!--       species_fit <- glm -->

<!--       # Add species-specific lines colored by site -->
<!--       for (species in spp) { -->
<!--         species_data <- td[td$species == species, ] -->
<!--         species_fit <- glm(ilfm ~ mwp, data = species_data) -->
<!--         species_xy <- inversePlotData(mm, coefficients(species_fit)) -->
<!--         lines(LFM ~ MWP, data = species_xy, col = unique(species_data$scolors), lwd = 1) -->
<!--       } -->

<!--   #     # Add the legend -->
<!--       legend('topleft', legend = unique(td$study), col = unique(td$scolors), pch = 19) -->
<!--     } -->
<!--   } -->



<!-- #Inverse:  -->

<!-- # Reset graphical parameters -->
<!-- par(op) -->

<!-- pform <- "Inv" -->

<!--   if (pform == 'Inv') { -->
<!--     # Plot regular LFM vs. MWP -->
<!--     plot(ilfm ~ mwp, data = td, main = slabel[i], -->
<!--          xlim = c(-8, 0), ylim = c(0, 4), -->
<!--          ylab = 'iLFM', xlab = 'MWP') -->
<!--     abline(h = 0.7, lty = 2)  # Add horizontal line at LFM = 0.7 -->
<!--     lines(iLFM ~ MWP, data = xy, lwd = 3, col = 'red')  # Add fitted line -->
<!--     points(ilfm ~ mwp, data = td, pch = 19, col = 'black')  # Data points -->

<!--     # Add species-specific lines colored by site -->
<!--     for (species in spp) { -->
<!--       species_data <- td[td$species == species, ] -->
<!--       species_fit <- glm -->

<!--       # Add species-specific lines colored by site -->
<!--       for (species in spp) { -->
<!--         species_data <- td[td$species == species, ] -->
<!--         species_fit <- glm(ilfm ~ mwp, data = species_data) -->
<!--         species_xy <- inversePlotData(mm, coefficients(species_fit)) -->
<!--         lines(iLFM ~ MWP, data = species_xy, col = unique(species_data$scolors), lwd = 1) -->
<!--       } -->

<!--   #     # Add the legend -->
<!--       legend('topleft', legend = unique(td$study), col = unique(td$scolors), pch = 19) -->
<!--     } -->
<!--   } -->
<!-- ``` -->

<!-- DONE -->
<!-- ```{r} -->
<!-- # Prepare for analyses by site -->
<!-- sites <- sort(unique(lwa$study))  # Re-affirm the list of study sites -->
<!-- table(lwa$study)  # Check the distribution of observations -->

<!-- # Create a new logical column indicating if the site is coastal -->
<!-- lwa$coastal <- TRUE -->
<!-- lwa$coastal[which(lwa$study == 'SEKI')] <- FALSE  # Mark 'SEKI' as non-coastal -->

<!-- # Initialize lists and labels for storing results -->
<!-- rsel <- list()  # List to hold row indices for each analysis subset -->
<!-- slabel <- sites  # Labels corresponding to each subset -->

<!-- # Populate 'rsel' with row indices for each site -->
<!-- for (i in 1:length(sites)) { -->
<!--   rsel[[i]] <- which(lwa$study == sites[i]) -->
<!-- } -->

<!-- # Add indices for coastal sites -->
<!-- i <- i + 1 -->
<!-- rsel[[i]] <- which(lwa$coastal) -->

<!-- # Add indices for all data -->
<!-- i <- i + 1 -->
<!-- rsel[[i]] <- 1:nrow(lwa) -->

<!-- # Update labels accordingly -->
<!-- slabel <- c(slabel, 'Coastal', 'All') -->

<!-- # Confirm that 'rsel' and 'slabel' are correctly set up -->
<!-- length(rsel) -->
<!-- slabel -->

<!-- # Initialize data structures to store statistical results -->
<!-- stres <- data.frame( -->
<!--   study = slabel, -->
<!--   Nspec = NA, -->
<!--   Nobs = NA, -->
<!--   BIC.no.int = NA, -->
<!--   common.slope = NA, -->
<!--   BIC.int = NA -->
<!-- ) -->

<!-- spres <- list()  # List to hold species-specific results -->
<!-- scoeff <- list()  # List to hold coefficients from models -->
<!-- pvals <- list()  # List to hold predicted values from models -->

<!-- # Define parameters for model forms and factors -->
<!-- pform <- 'Inv'  # Model form: 'Reg' for regular, could be 'Inv' for inverse -->
<!-- sppFac <- 'Species'  # Species factor, could be 'Species' or 'SpeciesSite' -->
<!-- slpModel <- 'Common'  # Slope model: 'Common' or 'SpSpecific' -->

<!-- # Initialize the loop counter -->
<!-- i = 6 -->

<!-- # Loop through each subset defined in 'rsel' -->
<!-- for (i in 1:length(rsel)) { -->
<!--   # Subset the data for the current selection -->
<!--   td <- lwa[rsel[[i]], ] -->

<!--   # Adjust species factor if necessary so that if species occur at different sites they are treated differently -->
<!--   #if (sppFac == 'SpeciesSite') td$Species <- td$Sp.Site -->

<!--   # Record the number of observations and species -->
<!--   stres$Nobs[i] <- nrow(td) -->
<!--   spp <- sort(unique(td$species)) -->
<!--   stres$Nspec[i] <- length(spp) -->

<!--   # Prepare a dataframe to store species-specific results -->
<!--   spres[[i]] <- data.frame( -->
<!--     study = rep(slabel[i], length(spp)), -->
<!--     species = spp, -->
<!--     Nobs = NA, -->
<!--     minWP = NA, -->
<!--     critWP = NA, -->
<!--     minLFM = NA, -->
<!--     model1.int = NA, -->
<!--     model1.slp = NA, -->
<!--     model2.int = NA, -->
<!--     model2.slp = NA -->
<!--   ) -->

<!--   # Fit a model without interaction to test if species have different intercepts -->
<!--   fit1 <- glm(ilfm ~ mwp * species, data = td) -->
<!--   stres$BIC.no.int[i] <- BIC(fit1)  # Store Bayesian Information Criterion -->
<!--   stres$common.slope[i] <- coefficients(fit1)[2]  # Common slope across species -->
<!--   scoeff[[i]] <- coefficients(fit1)  # Store coefficients -->
<!--   pvals[[i]] <- fit1$fitted.values  # Store fitted values -->

<!-- # Extract and store intercepts for each species -->
<!--   spres[[i]]$model1.int[1] <- coefficients(fit1)[1] -->
<!--   spres[[i]]$model1.int[-1] <- coefficients(fit1)[1] + coefficients(fit1)[-c(1:2)] -->
<!--   spres[[i]]$model1.slp <- coefficients(fit1)[2] -->

<!--   # Fit a model with interaction to test if species have different slopes -->
<!--   fit2 <- glm(ilfm ~ mwp * species, data = td) -->
<!--   stres$BIC.int[i] <- BIC(fit2) -->

<!--   # Set up plotting parameters -->
<!--   op = par(mar = c(5, 5, 3, 1)) -->

<!--   # Fit a simple model for plotting purposes -->
<!--  fit <- glm(ilfm ~ mwp, data = td) -->
<!--  mm <- range(td$mwp, na.rm = TRUE) -->
<!-- summary(fit) -->

<!--   # Generate data for plotting the inverse relationship -->
<!--  xy <- inversePlotData(mm, coefficients(fit)) -->

<!--   # # Plot the data and model fit -->
<!--   if (pform == 'Reg') { -->
<!--   #Plot regular LFM vs. MWP -->
<!--     plot(lfm ~ mwp, data = td, main = slabel[i], -->
<!--          xlim = c(-8, 0), ylim = c(0, 4), -->
<!--          ylab = 'LFM', xlab = 'MWP') -->
<!--     abline(h = 0.7, lty = 2)  # Add horizontal line at LFM = 0.7 -->
<!--     lines(LFM ~ MWP, data = xy, lwd = 3, col = 'red')  # Add fitted line -->
<!--     points(lfm ~ mwp, data = td, pch = 19, col = 'black')  # Data points -->

<!--     # Add species-specific lines colored by site -->
<!--     for (species in spp) { -->
<!--       species_data <- td[td$Species == species, ] -->
<!--       species_fit <- glm -->

<!--       # Add species-specific lines colored by site -->
<!--       for (species in spp) { -->
<!--         species_data <- td[td$species == species, ] -->
<!--         species_fit <- glm(ilfm ~ mwp, data = species_data) -->
<!--         species_xy <- inversePlotData(mm, coefficients(species_fit)) -->
<!--         lines(LFM ~ MWP, data = species_xy, col = unique(species_data$scolors), lwd = 1) -->
<!--       } -->

<!--       # Add the legend -->
<!--       legend('topleft', legend = unique(td$study), col = unique(td$scolors), pch = 19) -->
<!--     } -->
<!--   } -->

<!--   # Increment the counter -->
<!--   i <- i + 1 -->
<!-- } -->

<!-- # Reset graphical parameters -->
<!-- par(op) -->

<!-- # Display the statistical results -->
<!-- stres -->
<!-- spres[[1]]  # Results for the first subset -->
<!-- spres[[4]]  # Results for the fourth subset (i = 4) -->

<!-- # Combine species-specific results into one dataframe -->
<!-- spres.all <- spres[[1]] -->
<!-- for (i in 2:length(spres)) spres.all <- rbind(spres.all, spres[[i]]) -->

<!-- # Check dimensions and content of the combined results -->
<!-- dim(spres.all) -->
<!-- table(spres.all$study) -->
<!-- head(spres.all) -->
<!-- tail(spres.all) -->

<!-- # Create a shortened species code for easier reference -->
<!-- spres.all$SpCode6 <- substr(spres.all$species, 1, 6) -->

<!-- #Select only the columns that we need:  -->
<!-- coef_values_df_common <- spres.all %>%  -->
<!--   filter(study == "All") %>%  -->
<!--   select(study, species, model1.int, model1.slp) %>%  -->
<!--   separate(species, into = c("species", "study2"), sep = "_") %>%  -->
<!--   select(-study2) -->
<!-- ``` -->

<!-- Above chunk is the code to run get the slope and intercepts of linear relationships between Psi and 1/LFM into a dataframe (spres.all).  -->
<!-- ```{r} -->
<!-- # Prepare for analyses by site -->
<!-- sp_site <- sort(unique(lwa$sp_site))  # Re-affirm the list of study species -->
<!-- table(lwa$sp_site)  # Check the distribution of observations -->

<!-- # Create a new logical column indicating if the site is coastal -->
<!-- lwa$coastal <- TRUE -->
<!-- lwa$coastal[which(lwa$study == 'SEKI')] <- FALSE  # Mark 'SEKI' as non-coastal -->

<!-- # Initialize lists and labels for storing results -->
<!-- rsel <- list()  # List to hold row indices for each analysis subset -->
<!-- slabel <- sp_site  # Labels corresponding to each subset -->

<!-- # Populate 'rsel' with row indices for each site -->
<!-- for (i in 1:length(sp_site)) { -->
<!--   rsel[[i]] <- which(lwa$sp_site == sp_site[i]) -->
<!-- } -->

<!-- # Add indices for coastal sites -->
<!-- i <- i + 1 -->
<!-- rsel[[i]] <- which(lwa$coastal) -->

<!-- # Add indices for all data -->
<!-- i <- i + 1 -->
<!-- rsel[[i]] <- 1:nrow(lwa) -->

<!-- # Update labels accordingly -->
<!-- slabel <- c(slabel, 'Coastal', 'All') -->

<!-- # Confirm that 'rsel' and 'slabel' are correctly set up -->
<!-- length(rsel) -->
<!-- slabel -->

<!-- # Initialize data structures to store statistical results -->
<!-- stres <- data.frame( -->
<!--   study = slabel, -->
<!--   Nspec = NA, -->
<!--   Nobs = NA, -->
<!--   BIC.no.int = NA, -->
<!--   common.slope = NA, -->
<!--   BIC.int = NA -->
<!-- ) -->

<!-- spres <- list()  # List to hold species-specific results -->
<!-- scoeff <- list()  # List to hold coefficients from models -->
<!-- pvals <- list()  # List to hold predicted values from models -->

<!-- # Define parameters for model forms and factors -->
<!-- pform <- 'Inv'  # Model form: 'Reg' for regular, could be 'Inv' for inverse -->
<!-- sppFac <- 'Species'  # Species factor, could be 'Species' or 'SpeciesSite' -->
<!-- slpModel <- 'Common'  # Slope model: 'Common' or 'SpSpecific' -->

<!-- # Initialize the loop counter -->
<!-- i = length(sp_site) -->

<!-- # Loop through each subset defined in 'rsel' -->
<!-- for (i in 1:length(rsel)) { -->
<!--   # Subset the data for the current selection -->
<!--   td <- lwa[rsel[[i]], ] -->

<!--   # Adjust species factor if necessary so that if species occur at different sites they are treated differently -->
<!--   #if (sppFac == 'SpeciesSite') td$Species <- td$Sp.Site -->

<!--   # Record the number of observations and species -->
<!--   stres$Nobs[i] <- nrow(td) -->
<!--   spp <- sort(unique(td$species)) -->
<!--   stres$Nspec[i] <- length(spp) -->

<!--   # Prepare a dataframe to store species-specific results -->
<!--   spres[[i]] <- data.frame( -->
<!--     study = rep(slabel[i], length(spp)), -->
<!--     species = spp, -->
<!--     Nobs = NA, -->
<!--     minWP = NA, -->
<!--     critWP = NA, -->
<!--     minLFM = NA, -->
<!--     model1.int = NA, -->
<!--     model1.slp = NA, -->
<!--     model2.int = NA, -->
<!--     model2.slp = NA -->
<!--   ) -->

<!--   # Fit a model without interaction to test if species have different intercepts -->
<!--   fit1 <- glm(ilfm ~ mwp, data = td) -->
<!--   stres$BIC.no.int[i] <- BIC(fit1)  # Store Bayesian Information Criterion -->
<!--   stres$common.slope[i] <- coefficients(fit1)[2]  # Common slope across species -->
<!--   scoeff[[i]] <- coefficients(fit1)  # Store coefficients -->
<!--   pvals[[i]] <- fit1$fitted.values  # Store fitted values -->

<!-- # Extract and store intercepts for each species -->
<!--   spres[[i]]$model1.int[1] <- coefficients(fit1)[1] -->
<!--   spres[[i]]$model1.int[-1] <- coefficients(fit1)[1] + coefficients(fit1)[-c(1:2)] -->
<!--   spres[[i]]$model1.slp <- coefficients(fit1)[2] -->

<!--   # Fit a model with interaction to test if species have different slopes -->
<!--   fit2 <- glm(ilfm ~ mwp, data = td) -->
<!--   stres$BIC.int[i] <- BIC(fit2) -->

<!--   # Set up plotting parameters -->
<!--   op = par(mar = c(5, 5, 3, 1)) -->

<!--   # Fit a simple model for plotting purposes -->
<!--  fit <- glm(ilfm ~ mwp, data = td) -->
<!--  mm <- range(td$mwp, na.rm = TRUE) -->
<!-- summary(fit) -->

<!--   # Generate data for plotting the inverse relationship -->
<!--  xy <- inversePlotData(mm, coefficients(fit)) -->

<!--   # # Plot the data and model fit -->
<!--   if (pform == 'Reg') { -->
<!--   #Plot regular LFM vs. MWP -->
<!--     plot(lfm ~ mwp, data = td, main = slabel[i], -->
<!--          xlim = c(-8, 0), ylim = c(0, 4), -->
<!--          ylab = 'LFM', xlab = 'MWP') -->
<!--     abline(h = 0.7, lty = 2)  # Add horizontal line at LFM = 0.7 -->
<!--     lines(LFM ~ MWP, data = xy, lwd = 3, col = 'red')  # Add fitted line -->
<!--     points(lfm ~ mwp, data = td, pch = 19, col = 'black')  # Data points -->

<!--     # Add species-specific lines colored by site -->
<!--     for (species in spp) { -->
<!--       species_data <- td[td$Species == species, ] -->
<!--       species_fit <- glm -->

<!--       # Add species-specific lines colored by site -->
<!--       for (species in spp) { -->
<!--         species_data <- td[td$species == species, ] -->
<!--         species_fit <- glm(ilfm ~ mwp, data = species_data) -->
<!--         species_xy <- inversePlotData(mm, coefficients(species_fit)) -->
<!--         lines(LFM ~ MWP, data = species_xy, col = unique(species_data$scolors), lwd = 1) -->
<!--       } -->

<!--       # Add the legend -->
<!--       legend('topleft', legend = unique(td$study), col = unique(td$scolors), pch = 19) -->
<!--     } -->
<!--   } -->

<!--   # Increment the counter -->
<!--   i <- i + 1 -->
<!-- } -->

<!-- # Reset graphical parameters -->
<!-- par(op) -->

<!-- # Display the statistical results -->
<!-- stres -->
<!-- spres[[1]]  # Results for the first subset -->
<!-- spres[[4]]  # Results for the fourth subset (i = 4) -->

<!-- # Combine species-specific results into one dataframe -->
<!-- spres.all <- spres[[1]] -->
<!-- for (i in 2:length(spres)) spres.all <- rbind(spres.all, spres[[i]]) -->

<!-- # Check dimensions and content of the combined results -->
<!-- dim(spres.all) -->
<!-- table(spres.all$study) -->
<!-- head(spres.all) -->
<!-- tail(spres.all) -->

<!-- # Create a shortened species code for easier reference -->
<!-- spres.all$SpCode6 <- substr(spres.all$species, 1, 6) -->

<!-- #Select only the columns that we need:  -->
<!-- coef_values_df_common <- spres.all %>%  -->
<!--   filter(study == "All") %>%  -->
<!--   select(study, species, model1.int, model1.slp) %>%  -->
<!--   separate(species, into = c("species", "study2"), sep = "_") %>%  -->
<!--   select(-study2) -->
<!-- ``` -->
