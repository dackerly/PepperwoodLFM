---
title: "Additional analysis"
author: "Indra Boving"
date: "2024-04-03"
output: html_document
---

#Setup
```{r setup, include=FALSE}
rm(list = ls())
library(tidyverse)
library(here)
library(janitor)
source(here("scripts", "figure_info.R"))
library(ggpmisc)
```

```{r}
color_species <- scale_color_manual(
  values = c(
    ABICON = "#17154f",
    ADEFAS = "#2f357c",
    ARBMEN = "#6c5d9e",
    
    ARCGLA = "#9d9cd5",
    ARCPAT = "#b0799a",
    CALDEC = "#59385c",
    CEACUN = "#f6b3b0",
    
    CEAPAR = "#b38711",
    CEASPI = "#e48171",
    CERBET = "#d8b847",
    
    ERIFAS = "#bf3729",
    HETARB = "#e69b00",
    
    MALLAU = "#f5bb50",
    PINJEF = "#ada43b",
    PSEMEN = "#355828",
    
    QUEAGR = "#5b859e",
    QUEBER = "#1e395f",
    QUEDOU = "#75884b",
    
    QUEDUR = "#1e5a46",
    QUEGAR = "#df8d71",
    QUEKEL = "#af4f2f",
    
    SALLEU = "#d48f90",
    SALMEL = "#732f30",
    UMBCAL = "#d8b847"
  ),
  drop = FALSE
)
```

#Data wrangling: 

#####Read in: 

Description of datasets: 

```{r}
df <- read_csv(here::here("data", "all-data-combined.csv")) %>% 
  clean_names() %>% 
  mutate(ilfm = 1/lfm) %>% 
  mutate(tissue_age = case_when(
  tissue_age %in% c(NA, NaN) ~ "both",
  TRUE ~ as.character(tissue_age)
  )) %>% 
  filter(!(sp_site %in% c(#"ABICON_SEKI", 
                          #"PINJEF_SEKI", 
                         # "CALDEC_SEKI" 
                          #"PSEMEN_Pepperwood"
                          ))) #these act really odd, dont include
  # filter(!(sp_site %in% c("ABICON_SEKI", "PINJEF_SEKI") & tissue_age %in% c("old")))

```

#####Outliers? 

```{r}
df %>% 
  filter(study == "SEKI") %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = tissue_age)) + 
  geom_hline(yintercept = 70, linetype = "dotted") +
    geom_point(alpha = .4) +
  labs(x = "Midday Water Poential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Study", 
       shape = "Study") +
  color +
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  facet_wrap(~species, scales = "free")

df %>% 
  filter(study == "Sedgwick") %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = tissue_age)) + 
  geom_hline(yintercept = 70, linetype = "dotted") +
    geom_point(alpha = .4) +
  labs(x = "Midday Water Poential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Study", 
       shape = "Study") +
  color +
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  facet_wrap(~species, scales = "free")


df %>% 
  filter(study == "Pepperwood") %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = tissue_age)) + 
  geom_hline(yintercept = 70, linetype = "dotted") +
    geom_point(alpha = .4) +
  labs(x = "Midday Water Poential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Study", 
       shape = "Study") +
  color +
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  facet_wrap(~species, scales = "free")

df %>% 
  filter(study == "StuntRanch") %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = tissue_age)) + 
  geom_hline(yintercept = 70, linetype = "dotted") +
    geom_point(alpha = .4) +
  labs(x = "Midday Water Poential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Study", 
       shape = "Study") +
  color +
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  facet_wrap(~species, scales = "free")

unique(df$study)
```
model and look for outliers for each site:

```{r}
#SEKI outliers:
df_seki  <- df %>% 
  clean_names() %>% 
  mutate(ilfm = 1/lfm) %>% 
  filter(study == "SEKI")

#model with untransformed LFM: 
mod <- glm(mwp ~ lfm, data = df_seki)
mod
summary(mod)
plot(mod)

#model with transformed LFM: 
mod_inv <- glm(mwp ~ ilfm, data = df_seki)
mod_inv
summary(mod_inv)
plot(mod_inv)
#resid(mod_inv)

AIC(mod_inv)
AIC(mod)

#SEKI shows this the least

df[168,]

mod2 <- glm(mwp ~ lfm, data = df_seki[-168,])
mod2
summary(mod2)
plot(mod2)

AIC(mod, mod2)

coef(mod)
coef(mod2)

#Sedgwick outliers:
df_sedge  <- df %>% 
  clean_names() %>% 
  mutate(ilfm = 1/lfm) %>% 
  filter(study == "Sedgwick")

#model with untransformed LFM: 
mod <- glm(mwp ~ lfm, data = df_sedge)
mod
summary(mod)
plot(mod)

#model with untransformed LFM: 
mod2 <- glm(mwp ~ lfm, data = df_sedge[-231,])
mod2
summary(mod2)
plot(mod2)

AIC(mod, mod2)
coef(mod)
coef(mod2)

df_sedge[231,]

#model with transformed LFM: 
mod_inv <- glm(mwp ~ ilfm, data = df_sedge)
mod_inv
summary(mod_inv)
plot(mod_inv)
#resid(mod_inv)

AIC(mod_inv)
AIC(mod)

#Pepperwood outliers
df_pep  <- df %>% 
  clean_names() %>% 
  mutate(ilfm = 1/lfm) %>% 
  filter(!(study == "Pepperwood"))

#model with untransformed LFM: 
mod <- glm(mwp ~ lfm, data = df_pep)
mod
summary(mod)
plot(mod)

#model with transformed LFM: 
mod_inv <- glm(mwp ~ ilfm, data = df_pep)
mod_inv
summary(mod_inv)
plot(mod_inv)
#resid(mod_inv)

AIC(mod_inv)
AIC(mod)
```

Remove outliers, now this is the dataset we want to use: 
```{r}
df1 <- df %>% 
  filter(!(species %in% c("QUEAGR") & date %in% c("2022-04-27") & study %in% c("Sedgwick"))) %>% 
  mutate(study_nice = case_when(
    study %in% c("Pepperwood") ~ "PwD",
    study %in% c("Sedgwick") ~ "SeR",
    study %in% c("SEKI") ~ "PrC",
    study %in% c("StuntRanch") ~ "StR"
  ))

unique(df1$study)
```

#EVT analysis

Minimum seasonal MPa: 

```{r}
df1 %>% 
  ggplot(aes(x = mwp,
             fill = study)) +
  geom_histogram(
             alpha = 0.5) +
  facet_wrap(~species, scales = "free_y")

#Sample sizes: 

df1 %>% 
  mutate(year = year(date)) %>% 
  group_by(sp_site, year) %>% 
  summarise(count = n()) %>% 
  arrange()
#Pepperwood has n < 20 if grouped by year

df1 %>% 
  group_by(sp_site) %>% 
  summarise(count = n()) %>% 
  arrange(count)
#Pepperwood has n < 20

df1 %>% 
  group_by(species) %>% 
  summarise(count = n()) %>% 
  arrange(count)
#If we ignore site, things get better. Just aggregate to species? 

df1 %>% 
  ggplot(aes(x = mwp,
             fill = study)) +
  geom_histogram() +
  facet_wrap(~species, scales = "free")

write_csv(df1, here("temp_datasets", "df1.csv"))
```

To estimate species-specific minimum water potential (Ψmin), we used a hybrid extreme-value framework following Martínez-Vilalta et al. (2021). For each species (binning site and year to increase sample sizes), we implemented a peaks-over-threshold (POT) approach in which the upper tail of the Ψ distribution was defined using a species-specific threshold corresponding to a high quantile of the data. The threshold probability (pu) was selected adaptively to ensure adequate sampling of the tail, with pu constrained between 0.80 and 0.90 and chosen such that the expected number of exceedances above the threshold was at least 15 observations whenever possible. Exceedances above this threshold were modeled using a generalized Pareto distribution (GPD), fitted by probability-weighted moments. When the fitted GPD was well defined (positive scale parameter) and the number of exceedances met the minimum tail size criterion (≥ 10), Ψmin was estimated as the 99th percentile of the fitted POT-GPD distribution, representing an extreme but statistically estimable lower bound of water potential. For species that did not meet these criteria due to limited sample size or unstable tail fits, Ψmin was instead defined as the most negative observed water potential (Ackerly et al, 2006? check this). This hybrid approach balances statistical robustness and biological realism by using EVT-based extrapolation only where the data support it, while avoiding excessive extrapolation for sparsely sampled species.

```{r}
# ============================================================
# Hybrid Psi-min per species:
#   - EVT POT-GPD Psi-min when tail sample large enough
#   - Observed minimum otherwise
# ============================================================

library(dplyr)
library(purrr)
library(fExtremes)

# --- Load ---
dat <- df1 %>%
  mutate(
    mwp = as.numeric(mwp),
    psi_abs = abs(mwp)
  ) %>%
  filter(is.finite(mwp), is.finite(psi_abs), !is.na(species))

# --- Settings you can tune ---
psi_min_p <- 0.999      # extreme quantile for Psi-min (0.99 more stable than 0.999)
min_tail  <- 5        # minimum tail points required to use EVT
pu_max    <- 0.95      # highest threshold prob
pu_min    <- 0.80      # lowest threshold prob (drop if needed for more tail points)

# --- Vector-safe POT quantile (no qgpd arg issues) ---
pot_quantile <- function(p, u, p_u, xi, beta) {
  if (p <= p_u) return(NA_real_)
  q <- (p - p_u) / (1 - p_u)
  q <- min(max(q, 0), 0.999999)

  if (!is.finite(xi) || !is.finite(beta) || beta <= 0) return(NA_real_)

  # GPD exceedance quantile y
  if (abs(xi) < 1e-12) {
    yq <- -beta * log(1 - q)               # xi -> 0 limit
  } else {
    yq <- (beta/xi) * ((1 - q)^(-xi) - 1)  # general case
  }
  u + yq
}

# --- 1) Adaptive threshold per species to try to reach min_tail ---
u_tbl <- dat %>%
  count(species, name = "n") %>%
  mutate(
    pu = pmin(pu_max, pmax(pu_min, 1 - (min_tail / n)))
  ) %>%
  left_join(dat %>% select(species, psi_abs), by = "species") %>%
  group_by(species, n, pu) %>%
  summarise(
    u = as.numeric(quantile(psi_abs, probs = unique(pu), na.rm = TRUE)),
    .groups = "drop"
  )

# --- 2) Tail extraction + EVT fit (POT-GPD) ---
fits <- u_tbl %>%
  left_join(dat %>% select(species, psi_abs, mwp), by = "species") %>%
  group_by(species, n, pu, u) %>%
  summarise(
    x_tail = list(sort(psi_abs[psi_abs >= u])),
    k_tail = sum(psi_abs >= u),
    psi_min_obs = min(mwp, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    # EVT fit only if enough tail points
    gpd_fit = map2(x_tail, u, ~{
      x <- unlist(.x)
      if (length(x) < min_tail) return(NULL)
      tryCatch(
        fExtremes::gpdFit(x, u = .y, type = "pwm"),
        error = function(e) NULL
      )
    }),
    xi = map_dbl(gpd_fit, ~ if (is.null(.x)) NA_real_ else unname(.x@fit$par.ests["xi"])),
    beta = map_dbl(gpd_fit, ~ if (is.null(.x)) NA_real_ else unname(.x@fit$par.ests["beta"])),

    psi_min_evt_abs = pmap_dbl(list(u, pu, xi, beta), ~{
      if (any(!is.finite(c(..1, ..2, ..3, ..4))) || ..4 <= 0) return(NA_real_)
      pot_quantile(p = psi_min_p, u = ..1, p_u = ..2, xi = ..3, beta = ..4)
    }),
    psi_min_evt = -psi_min_evt_abs,  # back to negative MPa

    # Hybrid decision rule:
    use_evt = is.finite(psi_min_evt) & (k_tail >= min_tail),
    psi_min_hybrid = if_else(use_evt, psi_min_evt, psi_min_obs),
    psi_min_method = if_else(use_evt, "EVT_POT_GPD", "Observed_min")
  ) %>%
  select(species, n, pu, u, k_tail, xi, beta,
         psi_min_obs, psi_min_evt, psi_min_hybrid, psi_min_method)

# --- 3) Output table ---
print(fits %>% arrange(psi_min_method, k_tail))

write.csv(fits, "psi_min_by_species_hybrid.csv", row.names = FALSE)

fits %>% 
ggplot(aes(y = psi_min_hybrid, 
           x = psi_min_obs,
           shape = psi_min_method,
           color = species)) +
  geom_point() +
  geom_abline()

```


Generally sample sizes and groupins are too low to perform EVT, so we should probably just stick with minimum observed. BUT, lets just see how the ones we have compare to published psi min from Mencuccinni et al.: 

```{r}
species = c("ABICON",
            "ERIFAS"
            )

psi_min = c(-3.28,
            -9.05
)
```


####Table 1: (dataset summary)

Table 1. Species names and characteristics and sample sizes across the four studies. Sites: PeW = Pepperwood, StR = Stunt Ranch (Pivovaroff et al. 2019), SeR = Sedgwick Reserve, PrC = Providence Creek Watershed; Dec/Ever = deciduous/evergreen; Growth form = tree or shrub. Sample sizes indicate individual observations (LFM and MPa from a single individual on a single date).

```{r}
#devtools::install_github("ecoinfor/U.Taxonstand")
#install.packages("U.Taxonstand")
#library(Taxonstand)
library(U.Taxonstand)  # If you're using U.Taxonstand instead

SpCodes <- read_csv(here("data", "SpCodes.csv")) %>%
  mutate(species = SpCode6) %>% 
  mutate(family = familyMatch(splist = c(Genus), taxon = "plant")$family)

traits_df <- read_csv(here("data", "traits_rd_20250327.csv")) %>% 
  clean_names() %>% 
  mutate(species = sp_code) %>% 
  select(species, functional_type, growth_form)

sp_info <- merge(traits_df, SpCodes) %>% 
  mutate(sp_code = SpCode6) %>% 
  mutate(dec_ever = case_when(
    species %in% c("QUEDOU",
                   "QUEGAR",
                   "QUEKEL",
                   "SALLEU",
                   "SALMEL") ~ "Dec",
    species %in% c("ERIFAS") ~ "Semi-Dec",
    TRUE ~ as.character("Ever")
  )) %>% 
  mutate(growth_form = case_when(
    species %in% c("CERBET") ~ "tree/shrub",
    TRUE ~ as.character(growth_form)
  ))

table1_df <- merge(df1, sp_info, by = c("species")) %>% 
  group_by(study, species, Genus_species, functional_type, growth_form, family, dec_ever) %>% 
  summarise(n = n()) %>% 
  pivot_wider(names_from = c(study), 
              values_from = n)  %>% 
  mutate(common_name = case_when(
    species %in% c("ADEFAS") ~ "Chamise",
    species %in% c("ARBMEN") ~ "Madrone",
    species %in% c("CEACUN") ~ "Bickbush",
    species %in% c("CEAPAR") ~ "Parry ceanothus",
    species %in% c("HETARB") ~ "Toyon",
    species %in% c("PSEMEN") ~ "Douglas-fir",
    
    species %in% c("ABICON") ~ "Abies concolor",
    species %in% c("PINJEF") ~ "Pinus Jeffreyii",
    species %in% c("CALCED") ~ "Calocedrus decurrens",
    
    species %in% c("QUEAGR") ~ "Live oak",
    species %in% c("QUEDOU") ~ "Blue oak",
    species %in% c("QUEDUR") ~ "Leather oak",
    species %in% c("QUEGAR") ~ "Oregon white oak",
    species %in% c("QUEKEL") ~ "California black oak",
    species %in% c("UMBCAL") ~ "California bay",
    species %in% c("ARCPAT") ~ "Greenleaf manzanita",
    species %in% c("CEACOR") ~ "Whitethorn ceanothus",
    species %in% c("ARCGLA") ~ "Eastwood manzanita",
    species %in% c("CEASPI") ~ "Greenbark ceanothus",
    species %in% c("CERBET") ~ "Mountain mahogany",
    species %in% c("ERIFAS") ~ "California buckwheat",
    species %in% c("MALLAU") ~ "Laurel sumac",
    species %in% c("QUEBER") ~ "Scrub oak",
    species %in% c("SALLEU") ~ "Purple sage",
    species %in% c("SALMEL") ~ "Black sage")) %>% 
  ungroup() %>% 
  dplyr::select(species, Genus_species, common_name, family, growth_form, dec_ever, Pepperwood, SEKI, Sedgwick, StuntRanch) %>% 
  rename(PeW = Pepperwood, 
         PrC = SEKI, 
         StR = StuntRanch, 
         SeR = Sedgwick) %>% 
  arrange(species, Genus_species, common_name, family, growth_form, dec_ever, PeW, PrC, StR, SeR) %>%
  adorn_totals("row") 

# table1_df  %>% 
#   kable(format = "pipe")

write_csv(table1_df, here("results", "figures", "table1.csv"))
```

####Figure 1: (datasets)

```{r}
fig1 <- df1 %>% 
  ggplot(aes(y = lfm*100, x = mwp, color = species)) + 
  geom_hline(yintercept = 60, linetype = "dotted") +
    geom_point(alpha = .8) +
  labs(x = "Midday Water Poential (MPa)", 
       y = "Live Fuel Moisture (%)", 
       color = "Species", 
       shape = "Study") +
    #scale_color_manual(values = cal_palette("sierra1", n = 22, type = "discrete")) +
  color_species + 
  theme(legend.position = "right", 
        legend.position.inside = c(0.1, 0.8)) +
  facet_wrap(~study_nice, nrow = 2)
fig1

ggsave(plot = fig1, here::here("figures", "fig1.jpg"), dpi = 600, height = 4, width = 6, units = "in")
```

```{r}
## Preliminary analysis of 2021 Live Fuel Moisture (LFM) data
  # Remove all objects from the workspace to start fresh

library(ggplot2)  # Load ggplot2 package for advanced plotting capabilities
source(here('scripts', 'lfm_functions.R'))
# Source custom functions from external script

# Read in the combined dataset; 'as.is = TRUE' prevents strings from converting to factors
# 'row.names = 1' uses the first column as row names
lwa <- df1

# Calculate the inverse of LFM for modeling purposes
lwa$ilfm <- 1 / lwa$lfm

# Display the first few rows of the data to check if it's loaded correctly
head(lwa)

# Create a frequency table of the 'study' variable
table(lwa$study)

# Get a sorted list of unique study sites
sites <- sort(unique(lwa$study))

# Verify the number of observations per study
table(lwa$study)

# Check the total number of observations
nrow(lwa)

### Plotting by Site

# Define colors for each site for consistent plotting
scolors <- c("#B9C7E2", "#ECAB99",  "#5B6530", "#9484B1",  "#F1C100")  # Added color for SEKI

# Assign colors to each observation based on the study site
lwa$scolors <- scolors[match(lwa$study, sites)]

# Confirm that colors are assigned correctly
table(lwa$scolors)

# Randomly sample 1000 observations for plotting to avoid overplotting
rsamp <- sample(1:nrow(lwa), 1000)  # Sample from the full dataset

# Set up an empty plot with defined axes and limits
plot(lfm ~ mwp, data = lwa, type = 'n',
     xlab = 'Midday water potential (MPa)',
     ylab = 'Live fuel moisture',
     xlim = c(-8, 0), ylim = c(0, 3.5))

# Plot data points for each study site with different symbols and colors
points(lfm ~ mwp, data = lwa[lwa$study == 'Sedgwick', ],
       pch = 5, cex = 1, col = lwa$scolors[lwa$study == 'Sedgwick'])

points(lfm ~ mwp, data = lwa[lwa$study == 'StuntRanch', ],
       pch = 15, cex = 1, col = lwa$scolors[lwa$study == 'StuntRanch'])

points(lfm ~ mwp, data = lwa[lwa$study == 'Pepperwood', ],
       pch = 19, cex = 1.2, col = lwa$scolors[lwa$study == 'Pepperwood'])

# Include SEKI in the points plotting
points(lfm ~ mwp, data = lwa[lwa$study == 'SEKI', ],
       pch = 17, cex = 1.2, col = lwa$scolors[lwa$study == 'SEKI'])  # Different symbol for SEKI

# Add a legend to the plot
legend(-7, 3, sites, fill = NULL, border = 'white')

# Add custom legend symbols corresponding to each site
points(rep(-6.7, length(sites)), seq(2.84, 2.64 - 0.2 * (length(sites) - 1), length.out = length(sites)),
       pch = c(19, 5, 15, 17), col = scolors, cex = 2)  # Added SEKI symbol
```

#Conceptual Model:


#####Figure 2: (color)
```{r}
## conceptual model
source(here("scripts", "lfm_functions.R"))
spres <- read.csv(here("results", "species-results.csv"))
head(spres)
slp <- -0.198

#MWPvec <- seq(-6,0,length.out=25)
ilfm.sat.vec <- seq(0.25,1.25,length.out=25)
MWPcrit <- c()
for (i in 1:length(ilfm.sat.vec)) MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i],slp),1/0.7)
lfm.sat.vec <- 1/ilfm.sat.vec
plot(MWPcrit,lfm.sat.vec,xlim=c(-8,0),ylim=c(0,4),type='l',lwd=2,xlab='Minimum MWP (MPa)',ylab='LFM @ MWP=0')

for (i in 1:length(ilfm.sat.vec)) MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i],slp),1/0.5)
lfm.sat.vec <- 1/ilfm.sat.vec
lines(MWPcrit,lfm.sat.vec,xlim=c(-8,0),ylim=c(0,4),lwd=1)

for (i in 1:length(ilfm.sat.vec)) MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i],slp),1/1)
lfm.sat.vec <- 1/ilfm.sat.vec
lines(MWPcrit,lfm.sat.vec,xlim=c(-8,0),ylim=c(0,4),lwd=1)

#points(I(1/model1.int)~minWP,data=spres[which(spres$study=='Coastal'),],pch=19)
text(I(1/model1.int)~minWP,data=spres[which(spres$study=='Coastal'),],labels=letters)

# conceptual figure, in inverted space - need to flip to LFM# conceptual figulettersre, in inverted space - need to flip to LFM
lfm.sat <- c(0.9,0.5)
slp <- -0.2
min.MWP <- c(-6,-3)

xy <- inversePlotData(c(min.MWP[1],0),c(lfm.sat[1],slp))
head(xy)
plot(xy$MWP,xy$LFM)

(MWPcrit <- solveForX(c(lfm.sat[2],slp),1/0.7))
#------
(max.iLFM <- lfm.sat + min.MWP*slp)
(min.LFM <- 1/max.iLFM)

op=par(mfrow=c(1,2))
plot(c(-7,0),c(0,3),type='n',xlab='MWP',ylab='1/LFM')
x <- list()
y <- list()
for (i in 1:2) {
  x[[i]] <- c(0,min.MWP[i])
  y[[i]] <- c(lfm.sat[i],max.iLFM[i])
  lines(x[[i]],y[[i]],type='b',cex=2,pch=c(1,19))
}

xy1 <- inversePlotData(c(0,min.MWP[1]),c(lfm.sat[1],slp))
xy2 <- inversePlotData(c(0,min.MWP[2]),c(lfm.sat[2],slp))
plot(c(-7,0),c(0,3),type='n',xlab='MWP',ylab='LFM')
lines(xy1$MWP,xy1$LFM,type='l')
head(xy1)
points(xy1[c(1,100),c('MWP','LFM')],cex=2,pch=c(1,19))
lines(xy2$MWP,xy2$LFM,type='l')
points(xy2[c(1,100),c('MWP','LFM')],cex=2,pch=c(1,19))
par(op)

#-----
# Choose distinct colors for each line
cols <- c("steelblue3", "tomato3")  # i=1 -> cols[1], i=2 -> cols[2]

xy <- inversePlotData(c(min.MWP[1], 0), c(lfm.sat[1], slp))
plot(xy$MWP, xy$LFM)

(MWPcrit <- solveForX(c(lfm.sat[2], slp), 1/0.7))

(max.iLFM <- lfm.sat + min.MWP * slp)
(min.LFM  <- 1 / max.iLFM)

op <- par(mfrow = c(1, 2))

## Panel 1: 1/LFM vs MWP
plot(c(-7, 0), c(0, 3), type = "n", xlab = "MWP", ylab = "1/LFM")
mtext("A", side = 3, adj = 0, line = 1.2, font = 2, cex = 1.2)  # Panel label
x <- vector("list", 2)
y <- vector("list", 2)
for (i in 1:2) {
  x[[i]] <- c(0, min.MWP[i])
  y[[i]] <- c(lfm.sat[i], max.iLFM[i])
  # open circle for first point, filled circle for second
  lines(x[[i]], y[[i]], col = cols[i], lwd = 2)
  points(x[[i]][1], y[[i]][1], pch = 21, bg = "white", col = cols[i], cex = 2, lwd = 2)
  points(x[[i]][2], y[[i]][2], pch = 19, col = cols[i], cex = 2)
}

## Panel 2: LFM vs MWP
xy1 <- inversePlotData(c(0, min.MWP[1]), c(lfm.sat[1], slp))
xy2 <- inversePlotData(c(0, min.MWP[2]), c(lfm.sat[2], slp))
plot(c(-7, 0), c(0, 3), type = "n", xlab = "MWP", ylab = "LFM")
mtext("B", side = 3, adj = 0, line = 1.2, font = 2, cex = 1.2)  # Panel label

lines(xy1$MWP, xy1$LFM, col = cols[1], lwd = 2)
points(xy1[1, c("MWP", "LFM")], pch = 21, bg = "white", col = cols[1], cex = 2, lwd = 2)
points(xy1[100, c("MWP", "LFM")], pch = 19, col = cols[1], cex = 2)

lines(xy2$MWP, xy2$LFM, col = cols[2], lwd = 2)
points(xy2[1, c("MWP", "LFM")], pch = 21, bg = "white", col = cols[2], cex = 2, lwd = 2)
points(xy2[100, c("MWP", "LFM")], pch = 19, col = cols[2], cex = 2)

par(op)

#----
library(dplyr)
library(ggplot2)
library(patchwork)

# Colors mapped consistently across both panels
cols <- c("steelblue3", "tomato3")
names(cols) <- c("1","2")  # map to id "1" and "2"

# --- Data prep ---------------------------------------------------------------

# Panel A (1/LFM vs MWP): two straight line segments with endpoints
max.iLFM <- lfm.sat + min.MWP * slp

dfA_lines <- tibble(
  id = factor(c(1,1, 2,2)),
  MWP = c(0, min.MWP[1], 0, min.MWP[2]),
  invLFM = c(lfm.sat[1], max.iLFM[1], lfm.sat[2], max.iLFM[2])
)

dfA_open <- dfA_lines %>%
  group_by(id) %>%
  slice_head(n = 1) %>%
  ungroup()

dfA_filled <- dfA_lines %>%
  group_by(id) %>%
  slice_tail(n = 1) %>%
  ungroup()

# Panel B (LFM vs MWP): two curves from inversePlotData
xy1 <- inversePlotData(c(0, min.MWP[1]), c(lfm.sat[1], slp)) %>% mutate(id = factor(1))
xy2 <- inversePlotData(c(0, min.MWP[2]), c(lfm.sat[2], slp)) %>% mutate(id = factor(2))
dfB_curve <- bind_rows(xy1, xy2)

dfB_open <- dfB_curve %>%
  group_by(id) %>%
  slice_head(n = 1) %>%
  ungroup()

dfB_filled <- dfB_curve %>%
  group_by(id) %>%
  slice_tail(n = 1) %>%
  ungroup()

# --- Plots -------------------------------------------------------------------

# Panel A: LFM vs MWP
pA <- ggplot(dfB_curve, aes(x = MWP, y = LFM, color = id)) +
  geom_line(linewidth = 1) +
  geom_vline(xintercept = 0, linetype="dotted") +
  geom_point(data = dfB_open,
             aes(x = MWP, y = LFM),
             shape = 21, fill = "white", size = 3.5, stroke = 1.2) +
  geom_point(data = dfB_filled,
             aes(x = MWP, y = LFM),
             shape = 19, size = 3.5) +
  annotate("text", x = -7, y = 3, label = "A", fontface = "bold",
           hjust = 0, vjust = 1, size = 5) +
  coord_cartesian(xlim = c(-7, 0), ylim = c(0, 3)) +
  scale_color_manual(values = cols, guide = "none") +
  labs(x = "Midday Water Potential (MPa)", y = "LFM (%)")

# Panel B: 1/LFM vs MWP
pB <- ggplot() +
  geom_line(data = dfA_lines,
            aes(x = MWP, y = invLFM, group = id, color = id), linewidth = 1) +
  geom_vline(xintercept = 0, linetype="dotted") +
  geom_point(data = dfA_open,
             aes(x = MWP, y = invLFM, color = id),
             shape = 21, fill = "white", size = 3.5, stroke = 1.2) +
  geom_point(data = dfA_filled,
             aes(x = MWP, y = invLFM, color = id),
             shape = 19, size = 3.5) +
  annotate("text", x = -7, y = 3, label = "B", fontface = "bold",
           hjust = 0, vjust = 1, size = 5) +
  coord_cartesian(xlim = c(-7, 0), ylim = c(0, 3)) +
  scale_color_manual(values = cols, guide = "none") +
  labs(x = "Midday Water Potential (MPa)", y = "1/LFM (%)")

# Side-by-side layout (no legend)
pA + pB + plot_layout(ncol = 2)

# Create the combined plot
final_plot <- pA + pB + plot_layout(ncol = 2, 
                                    axis_titles = "collect")
final_plot

# Save it
ggsave(
  filename = here("figures", "Figure2_color.png"),  # or .pdf, .jpg, etc.
  plot     = final_plot,
  width    = 8,     # inches
  height   = 4,     # inches
  dpi      = 300    # high resolution
)
#----
```


#Q1: Slopes and models

Intro/discussion:

1) What are the aggregate and species-level relationships between leaf water potential and live fuel moisture, and how do they compare across studies? We predict that initial LFM and minimum WP will explain variation in minimum LFM observed at the end of the dry season (following the conceptual model in Figure 2), and that these will be largely consistent across species.  


#####Figure SX. (linear fits, 1/lfm vs lfm)
Linear relationship between iLFM and middays: 

```{r}
# Model with untransformed LFM
mod <- glm(mwp ~ lfm, data = df1)
mod_summary <- summary(mod)

# Model with transformed LFM (inverse LFM)
mod_inv <- glm(mwp ~ ilfm, data = df1)
mod_inv_summary <- summary(mod_inv)

# Compare AIC and BIC
aic_values <- c(AIC(mod), AIC(mod_inv))
bic_values <- c(BIC(mod), BIC(mod_inv))
model_names <- c("Untransformed LFM", "Transformed LFM (iLFM)")

# Compute Pseudo R-squared (McFadden's R²)
pseudo_r2 <- function(model) {
  1 - (model$deviance / model$null.deviance)
}

r2_values <- c(pseudo_r2(mod), pseudo_r2(mod_inv))

# Compare residuals
par(mfrow = c(2, 2))  # Set plotting layout for residual diagnostics
plot(mod, main = "Untransformed LFM Model")
plot(mod_inv, main = "Transformed LFM Model")

# Create a summary table for comparison
model_comparison <- data.frame(
  Model = model_names,
  AIC = aic_values,
  BIC = bic_values,
  Pseudo_R2 = r2_values
)

print(model_comparison)

# Determine the better model based on AIC
best_model <- ifelse(AIC(mod_inv) < AIC(mod), "Transformed LFM (iLFM)", "Untransformed LFM")
cat("Best model based on AIC:", best_model, "\n")
```

#####Table SX (slope coefs, nocons)
```{r, models}
df_nocon <- df1 %>% 
  filter(!(species %in% c("ABICON", 
                          "PINJEF",
                          "CALCED",
                          "PSIMEN"
                          )))
#With conifers included: 
library(lme4)

mod_spp_int <- glm(ilfm ~ mwp*species, data = df_nocon, family = gaussian)
#mod_spp_int_lmer <- lmer(ilfm ~ mwp*species + species|study, data = df1, REML = T)
mod_spp_noint <- glm(ilfm ~ mwp + species, data = df_nocon, family = gaussian)
#mod_spp_lmer <- lmer(ilfm ~ mwp + species + 1|study, data = df1)

car::vif(mod_spp_noint)

aic <- AIC(mod_spp_int, mod_spp_noint)
aic
BIC(mod_spp_int, mod_spp_noint)

anova(mod_spp_int, mod_spp_noint)

# AIC(mod_spp_lmer, mod_spp_noint_lmer)
# BIC(mod_spp_lmer, mod_spp_noint_lmer)
# anova(mod_spp_lmer, mod_spp_noint_lmer)

plot(mod_spp_noint)

plot(mod_spp_int)

#r2: 
R2_spp_int <- performance::r2(mod_spp_int)
R2_spp_int

R2_spp_noint <- performance::r2(mod_spp_noint)
R2_spp_noint

#model details: 
coef(summary(mod_spp_int))
summary(mod_spp_int)

summary(mod_spp_noint)

tablesx_coefs <- broom::tidy(mod_spp_noint) %>% 
    dplyr::mutate(across(where(is.numeric), round, 4)) %>% 
  mutate(p.value.stars = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01 & p.value < 0.001 ~ "**",
    p.value < 0.05 & p.value > 0.01 ~ "*", 
    TRUE ~ as.character(" ")
  ))

write_csv(tablesx_coefs, here("results", "figures", "tableSX_coefs.csv"))

tablesx_ints_coefs <- broom::tidy(mod_spp_int) %>% 
    dplyr::mutate(across(where(is.numeric), round, 4)) %>% 
  mutate(p.value.stars = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01 & p.value < 0.001 ~ "**",
    p.value < 0.05 & p.value > 0.01 ~ "*", 
    TRUE ~ as.character(" ")
  ))
tablesx_ints_coefs

write_csv(tablesx_ints_coefs, here("results", "figures", "tableSX_ints_coefs_conifers.csv"))
```

#####Table SX (slope coefs, with cons)
```{r, models}
#With conifers included: 
library(lme4)

mod_spp_int <- glm(ilfm ~ mwp*species, data = df1, family = gaussian)
#mod_spp_int_lmer <- lmer(ilfm ~ mwp*species + species|study, data = df1, REML = T)
mod_spp_noint <- glm(ilfm ~ mwp + species, data = df1, family = gaussian)
#mod_spp_lmer <- lmer(ilfm ~ mwp + species + 1|study, data = df1)

car::vif(mod_spp_noint)

aic <- AIC(mod_spp_int, mod_spp_noint)
aic
BIC(mod_spp_int, mod_spp_noint)

anova(mod_spp_int, mod_spp_noint)

# AIC(mod_spp_lmer, mod_spp_noint_lmer)
# BIC(mod_spp_lmer, mod_spp_noint_lmer)
# anova(mod_spp_lmer, mod_spp_noint_lmer)

plot(mod_spp_noint)

plot(mod_spp_int)

#r2: 
R2_spp_int <- performance::r2(mod_spp_int)
R2_spp_int

R2_spp_noint <- performance::r2(mod_spp_noint)
R2_spp_noint

#model details: 
coef(summary(mod_spp_int))
summary(mod_spp_int)

summary(mod_spp_noint)

tablesx_coefs <- broom::tidy(mod_spp_noint) %>% 
    dplyr::mutate(across(where(is.numeric), round, 4)) %>% 
  mutate(p.value.stars = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01 & p.value < 0.001 ~ "**",
    p.value < 0.05 & p.value > 0.01 ~ "*", 
    TRUE ~ as.character(" ")
  ))

write_csv(tablesx_coefs, here("results", "figures", "tableSX_coefs.csv"))

tablesx_ints_coefs <- broom::tidy(mod_spp_int) %>% 
    dplyr::mutate(across(where(is.numeric), round, 4)) %>% 
  mutate(p.value.stars = case_when(
    p.value < 0.001 ~ "***",
    p.value < 0.01 & p.value < 0.001 ~ "**",
    p.value < 0.05 & p.value > 0.01 ~ "*", 
    TRUE ~ as.character(" ")
  ))
tablesx_ints_coefs

write_csv(tablesx_ints_coefs, here("results", "figures", "tableSX_ints_coefs_conifers.csv"))
```


######Bayesian forest plot: 
```{r}
# ============================================================
# Bayesian species-specific slopes + forest plot (credible intervals)
#   - Model estimates a separate slope for EACH species
#   - Optional random intercept for study
# ============================================================

#install.packages(c("brms", "tidybayes", "dplyr", "ggplot2", "readr", "forcats", "posterior"))
library(brms)
library(tidybayes)
library(dplyr)
library(ggplot2)
library(readr)
library(forcats)
library(posterior)

#install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
#cmdstanr::install_cmdstan()


# ---- load data ----

# ---- (recommended) scale mwp for stability/convergence ----
df1 <- df1 %>%
  mutate(
    species = as.factor(species),
    study   = as.factor(study),
    mwp_z   = as.numeric(scale(mwp))
  )

# ============================================================
# 1) Bayesian model: separate intercept AND slope per species
#    This parameterization avoids a reference species:
#      ilfm ~ 0 + species + 0 + mwp_z:species
#    Optional: + (1|study) for study-to-study shifts
# ============================================================

priors <- c(
  prior(normal(0, 1), class = "b"),          # slopes/intercepts on scaled mwp
  prior(student_t(3, 0, 1), class = "sigma") # residual SD
)

fit_spp_slopes <- brm(
  formula = ilfm ~ 0 + species + 0 + mwp_z:species + (1 | study),
  data    = df1,
  family  = gaussian(),
  prior   = priors,
  chains  = 4, cores = 4, iter = 4000, warmup = 1000,
  seed    = 123,
  control = list(adapt_delta = 0.99, max_treedepth = 15)
)

# quick checks
pp_check(fit_spp_slopes)
summary(fit_spp_slopes)

# ============================================================
# 2) Extract posterior draws for EACH species slope
#    Coefficient names look like: "mwp_z:speciesABCO" etc.
# ============================================================

library(tidybayes)
library(dplyr)
library(ggplot2)

# posterior draws for each species slope
slope_draws <- fit_spp_slopes %>%
  gather_draws(`^b_species.*:mwp_z$`, regex = TRUE) %>%
  mutate(
    species = gsub("^b_species", "", .variable),
    species = gsub(":mwp_z$", "", species)
  )

# summarize to median + 95% credible interval
forest_df <- slope_draws %>%
  group_by(species) %>%
  summarise(
    slope_med = median(.value),
    slope_lo  = quantile(.value, 0.025),
    slope_hi  = quantile(.value, 0.975),
    .groups   = "drop"
  ) %>%
  arrange(slope_med) %>%
  mutate(species = factor(species, levels = species))

# forest plot
draws_long <- slope_draws %>%
  transmute(.draw, species, slope = .value)

# Rebuild wide posterior draws
draws_wide <- draws_long %>%
  select(.draw, species, slope) %>%
  tidyr::pivot_wider(names_from = species, values_from = slope) %>%
  arrange(.draw)


draws_wide <- draws_long %>%
  pivot_wider(names_from = species, values_from = slope) %>%
  arrange(.draw)

# Drop .draw and FORCE numeric matrix
slope_mat <- draws_wide %>%
  select(-.draw) %>%
  as.data.frame() %>%
  mutate(across(everything(), as.numeric)) %>%
  as.matrix()

# sanity check
stopifnot(is.numeric(slope_mat))

sp <- colnames(slope_mat)

# Count NA values per species slope
na_counts <- colSums(is.na(slope_mat))
summary(na_counts)


library(posterior)
library(dplyr)
library(tidyr)
library(stringr)

# 1) Get ALL draws as a draws_df
d <- as_draws_df(fit_spp_slopes)

# 2) Grab the slope columns you showed: b_speciesXXXX:mwp_z
slope_cols <- grep("^b_species.*:mwp_z$", variables(d), value = TRUE)

# 3) Build a clean draws table: rows = posterior draws, cols = species
slope_df <- d %>%
  as.data.frame() 
all_vars <- variables(d)

slope_cols <- grep("^b_species.*:mwp_z$", all_vars, value = TRUE)

slope_cols

slope_df <- d %>%
  as.data.frame() %>%
  select(all_of(slope_cols))

new_names <- gsub("^b_species", "", slope_cols)
new_names <- gsub(":mwp_z$", "", new_names)

colnames(slope_df) <- new_names

slope_mat <- as.matrix(slope_df)
```



```{r}
# install.packages(c("ggridges", "tidybayes", "dplyr", "ggplot2"))
library(tidybayes)
library(dplyr)
library(ggplot2)
library(ggridges)
library(forcats)

# posterior draws for each species slope
slope_draws <- fit_spp_slopes %>%
  gather_draws(`^b_species.*:mwp_z$`, regex = TRUE) %>%
  mutate(
    species = gsub("^b_species", "", .variable),
    species = gsub(":mwp_z$", "", species)
  ) %>%
  select(.draw, species, slope = .value)

# order species by posterior median slope
species_order <- slope_draws %>%
  group_by(species) %>%
  summarise(med = median(slope), .groups = "drop") %>%
  arrange(med) %>%
  pull(species)

slope_draws <- slope_draws %>%
  mutate(species = factor(species, levels = species_order))

# ridgeline posterior plot
ggplot(slope_draws, aes(x = slope, y = species)) +
  geom_vline(xintercept = 0, linetype = 2, linewidth = 0.4) +
  geom_density_ridges(scale = 2.2, rel_min_height = 0.01, alpha = 0.8) +
  labs(
    x = "Posterior of species slope (ilfm ~ mwp_z)",
    y = NULL
  ) +
  theme_classic(base_size = 14)

```


```{r}
# slope_mat: matrix of posterior draws, columns = species slopes
grand_draw <- rowMeans(slope_mat)  # one value per posterior draw
grand_lo   <- quantile(grand_draw, 0.025)
grand_hi   <- quantile(grand_draw, 0.975)
grand_med  <- median(grand_draw)

c(grand_lo = grand_lo, grand_med = grand_med, grand_hi = grand_hi)

library(dplyr)
library(ggplot2)
library(forcats)

# Summarize species slope CrIs from slope_mat
forest_df <- tibble(species = colnames(slope_mat)) %>%
  rowwise() %>%
  mutate(
    slope_med = median(slope_mat[, species]),
    slope_lo  = quantile(slope_mat[, species], 0.025),
    slope_hi  = quantile(slope_mat[, species], 0.975)
  ) %>%
  ungroup() %>%
  mutate(
    # use the UNWEIGHTED grand interval:
    overlaps_grand = !(slope_hi < grand_lo | slope_lo > grand_hi),
    species = fct_reorder(species, slope_med)
  )

ggplot(forest_df, aes(y = species, x = slope_med, color = overlaps_grand)) +
  geom_vline(xintercept = grand_med, linetype = 2, linewidth = 0.4) +
  geom_errorbarh(aes(xmin = slope_lo, xmax = slope_hi), height = 0, linewidth = 0.6) +
  geom_point(size = 2.3) +
  labs(
    x = "Species slope of ilfm ~ mwp_z (posterior median ± 95% CrI)",
    y = NULL
  ) +
  theme_classic(base_size = 14) + theme(legend.position = "none")

```
```{r}
# posterior draws of grand mean (same as you have)
grand_draw <- rowMeans(slope_mat, na.rm = TRUE)

# posterior probability each species is greater than the grand mean
p_gt_grand <- apply(slope_mat, 2, function(x) mean(x > grand_draw, na.rm = TRUE))

# two-sided probability of being different from grand (direction-agnostic)
p_diff_grand <- 2 * pmin(p_gt_grand, 1 - p_gt_grand)

# flag as "different" at 95% posterior probability (analog of p<0.05)
diff_from_grand_95 <- p_diff_grand < 0.05

forest_df <- forest_df %>%
  mutate(
    p_diff_grand = p_diff_grand[as.character(species)],
    diff_from_grand_95 = diff_from_grand_95[as.character(species)]
  )

ggplot(forest_df, aes(y = species, x = slope_med, shape = diff_from_grand_95)) +
  geom_vline(xintercept = median(grand_draw), linetype = 2, linewidth = 0.4) +
  geom_errorbarh(aes(xmin = slope_lo, xmax = slope_hi), height = 0, linewidth = 0.6, color = "black") +
  geom_point(size = 2.3, color = "black") +
  scale_shape_manual(values = c(`FALSE` = 16, `TRUE` = 1)) +  # filled = not different, open = different
  labs(x = "Species slope of ilfm ~ mwp_z (posterior median ± 95% CrI)", y = NULL) +
  theme_classic(base_size = 14) +
  theme(legend.position = "none")

```


Color by leaf habit: 

```{r}
forest_df1 <- forest_df %>%
  left_join(table1_df, by = "species")

leaf_colors <- c(
  Ever = "#1b9e77",
  Dec = "#d95f02",
  "Semi-Dec" = "#7570b3"  # optional
)


forest_df2 <- forest_df %>%
  left_join(table1_df, by = "species") %>%
  mutate(
    species_label = paste0(
      "<span style='color:",
      leaf_colors[as.character(dec_ever)],
      "'>",
      species,
      "</span>"
    ),
    species = fct_reorder(species, slope_med)
  )

# IMPORTANT: named labels (names must match the factor levels in y)
species_labels <- setNames(forest_df2$species_label, forest_df2$species)

ggplot(
  forest_df2,
  aes(y = species, x = slope_med, shape = overlaps_grand)
) +
  geom_vline(xintercept = grand_med, linetype = 2, linewidth = 0.4) +
  geom_errorbarh(
    aes(xmin = slope_lo, xmax = slope_hi),
    height = 0,
    linewidth = 0.6,
    color = "black"
  ) +
  geom_point(size = 2.3, color = "black") +
  scale_shape_manual(values = c(`TRUE` = 16, `FALSE` = 1)) +
  scale_y_discrete(labels = species_labels) +
  labs(x = "Slope (posterior median ± 95% CrI)", y = NULL) +
  theme_classic(base_size = 14) +
  theme(
    legend.position = "none",
    axis.text.y = element_markdown()
  )

```
Color by genus: 
```{r}
forest_df1 <- forest_df %>%
  left_join(table1_df, by = "species")

family_colors <- c(
  Pinaceae      = "darkgreen",
  Cupressaceae  = "darkblue",
  Fagaceae      = "#d95f02",
  Rosaceae      = "#e7298a",
  Ericaceae     = "#7570b3",
  Lauraceae     = "#a6761d",
  Rhamnaceae    = "#1f78b4",
  Polygonaceae  = "#b2df8a",
  Anacardiaceae = "#fb9a99",
  Lamiaceae     = "#cab2d6"
)

library(dplyr)
library(forcats)
library(ggplot2)
library(ggtext)

forest_df2 <- forest_df %>%
  left_join(table1_df, by = "species") %>%
  mutate(
    family = trimws(as.character(family)),
    species_label = paste0(
      "<span style='color:",
      family_colors[family],
      "'>",
      species,
      "</span>"
    ),
    # RECOMPUTE overlap here (must have grand_lo and grand_hi defined)
    overlaps_grand = !(slope_hi < grand_lo | slope_lo > grand_hi),
    # force to two-level factor so both shapes can appear
    overlaps_grand = factor(overlaps_grand, levels = c(FALSE, TRUE)),
    species = fct_reorder(species, slope_med)
  )

species_labels <- setNames(forest_df2$species_label, forest_df2$species)

# quick check: do you actually have both TRUE and FALSE?
table(forest_df2$overlaps_grand, useNA = "ifany")

species_labels <- setNames(forest_df2$species_label, forest_df2$species)


ggplot(forest_df2, aes(y = species, x = slope_med, shape = overlaps_grand)) +
  geom_vline(xintercept = grand_med, linetype = 2, linewidth = 0.4) +
  geom_errorbarh(aes(xmin = slope_lo, xmax = slope_hi),
                 height = 0, linewidth = 0.6, color = "black") +
  geom_point(size = 2.3, color = "black") +
  scale_shape_manual(values = c(`FALSE` = 1, `TRUE` = 16), drop = FALSE) +
  scale_y_discrete(labels = species_labels) +
  labs(x = "Slope (posterior median ± 95% CrI)", y = NULL) +
  theme_classic(base_size = 14) +
  theme(legend.position = "none",
        axis.text.y = element_markdown())

```

Add grand slope without the pinaceae or cade: 

```{r}

# --- Grand slope 1: all species (unweighted mean across species per draw) ---
grand_draw_all <- rowMeans(slope_mat, na.rm = TRUE)
grand_med_all  <- median(grand_draw_all)
grand_lo_all   <- quantile(grand_draw_all, 0.025)
grand_hi_all   <- quantile(grand_draw_all, 0.975)

# --- Grand slope 2: exclude selected species ---
exclude_spp <- c("PINJEF", "ABICON", "CALDEC", "PSEMEN")  # note: you wrote CADEC; your data uses CALDEC
keep_cols <- setdiff(colnames(slope_mat), exclude_spp)

grand_draw_excl <- rowMeans(slope_mat[, keep_cols, drop = FALSE], na.rm = TRUE)
grand_med_excl  <- median(grand_draw_excl)
grand_lo_excl   <- quantile(grand_draw_excl, 0.025)
grand_hi_excl   <- quantile(grand_draw_excl, 0.975)


forest_df2 <- forest_df %>%
  left_join(table1_df, by = "species") %>%
  mutate(
    family = trimws(as.character(family)),
    species_label = paste0(
      "<span style='color:",
      family_colors[family],
      "'>",
      species,
      "</span>"
    ),
    # RECOMPUTE overlap here (must have grand_lo and grand_hi defined)
    overlaps_grand = !(slope_hi < grand_lo_all | slope_lo > grand_hi_all),

    # force to two-level factor so both shapes can appear
    overlaps_grand = factor(overlaps_grand, levels = c(FALSE, TRUE)),
    species = fct_reorder(species, slope_med)
  ) %>%
  mutate(
    overlaps_grand_excl = !(slope_hi < grand_lo_excl | slope_lo > grand_hi_excl),
    overlaps_grand_excl = factor(overlaps_grand_excl, levels = c(FALSE, TRUE))
  )


species_labels <- setNames(forest_df2$species_label, forest_df2$species)

# quick check: do you actually have both TRUE and FALSE?
table(forest_df2$overlaps_grand, useNA = "ifany")

species_labels <- setNames(forest_df2$species_label, forest_df2$species)


ggplot(forest_df2, aes(y = species, x = slope_med, shape = overlaps_grand)) +
  geom_vline(xintercept = grand_med_all,  linetype = 2, linewidth = 0.4) +
  geom_vline(xintercept = grand_med_excl, linetype = 3, linewidth = 0.4) +
  geom_errorbarh(aes(xmin = slope_lo, xmax = slope_hi),
                 height = 0, linewidth = 0.6, color = "black") +
  geom_point(size = 2.3, color = "black") +
  scale_shape_manual(values = c(`FALSE` = 1, `TRUE` = 16), drop = FALSE) +
  scale_y_discrete(labels = species_labels) +
  labs(x = "Slope (posterior median ± 95% CrI)", y = NULL) +
  theme_classic(base_size = 14) +
  theme(
    legend.position = "none",
    axis.text.y = element_markdown()
  )

ggplot(forest_df2, aes(y = species, x = slope_med)) +
  geom_vline(xintercept = grand_med_all,  linetype = 2, linewidth = 0.4) +
  geom_vline(xintercept = grand_med_excl, linetype = 3, linewidth = 0.4) +
  geom_errorbarh(aes(xmin = slope_lo, xmax = slope_hi),
                 height = 0, linewidth = 0.6, color = "black") +
  geom_point(
    aes(
      shape = overlaps_grand,
      color = overlaps_grand_excl
    ),
    size = 2.3,
    stroke = 1.1,
    fill = "white"   # so only outline color matters
  ) +
  scale_shape_manual(values = c(`FALSE` = 1, `TRUE` = 16), drop = FALSE) +
  scale_color_manual(values = c(`FALSE` = "black", `TRUE` = "dodgerblue3"), drop = FALSE) +
  scale_y_discrete(labels = species_labels) +
  labs(x = "Slope (posterior median ± 95% CrI)", y = NULL) +
  theme_classic(base_size = 14) +
  theme(
    legend.position = "none",
    axis.text.y = element_markdown()
  )

```





#####DF with slopes and intercepts: 

```{r}
library(dplyr)
library(broom)
library(tidyr)
library(purrr)

# Fit the models
mod_common_slope <- glm(ilfm ~ mwp + species, data = df1, family = gaussian)
mod_species_interaction <- glm(ilfm ~ mwp * species, data = df1, family = gaussian)
mod_species_study <- glm(ilfm ~ mwp * sp_site, data = df1, family = gaussian)

# Helper to extract coefficients and label the model
extract_model_info <- function(model, model_name) {
  tidy(model) %>%
    mutate(model = model_name)
}

# Combine all model coefficients
model_coeffs <- bind_rows(
  extract_model_info(mod_common_slope, "common_slope"),
  extract_model_info(mod_species_interaction, "species_interaction"),
  extract_model_info(mod_species_study, "species_site_interaction")
)

# Utility to get baseline level of factor variable (alphabetical if not set)
baseline_level <- function(var) levels(factor(var))[1]

# Function to compute slope and intercept per group
compute_group_terms <- function(model, group_var, model_type) {
  group_list <- unique(df1[[group_var]])
  base_group <- baseline_level(df1[[group_var]])

  map_dfr(group_list, function(grp) {
    # Start with base intercept and slope
    intercept <- coef(model)[["(Intercept)"]]
    slope <- coef(model)[["mwp"]]

    if (grp != base_group) {
      int_term <- paste0(group_var, grp)
      slope_term <- paste0("mwp:", group_var, grp)

      if (int_term %in% names(coef(model))) {
        intercept <- intercept + coef(model)[[int_term]]
      }

      if (slope_term %in% names(coef(model))) {
        slope <- slope + coef(model)[[slope_term]]
      }
    }

    tibble(
      group = grp,
      intercept = intercept,
      slope = slope,
      model = model_type
    )
  })
}

# Get results for each model
coefs_common <- compute_group_terms(mod_common_slope, "species", "common_slope") %>% rename(species = group)

coefs_species_int <- compute_group_terms(mod_species_interaction, "species", "species_interaction") %>% rename(species = group)

coefs_species_study <- compute_group_terms(mod_species_study, "sp_site", "species_site_interaction") %>% rename(sp_study = group)%>% 
  separate_wider_delim(sp_study, names = c("species", "study"), "_") 
  


# Combine into one dataframe
coef_compare_df  <- bind_rows(coefs_common, coefs_species_int, coefs_species_study) %>% 
  mutate(group = case_when(
    model %in% c("species_interaction") ~ "species",
    model %in% c("common_slope") ~ "grand",
    model %in% c("species_site_interaction") ~ "sp_study",
  )) %>% 
  select(-study)

range(coefs_species_int$slope)

#compare:
coef_compare_df %>% 
  ggplot(aes(y = slope, 
             x = intercept,
             color = group)) +
  geom_point(alpha = .4)


summary(coef_compare_df
        )

concept_both_df <- merge(coef_compare_df, df1, by = c("species"), all = T) %>% 
  filter(!(model == "species_site_interaction")) %>% 
  merge(sp_info) %>% 
  clean_names()

concept_study_df <- merge(coef_compare_df, df1, by = c("species"), all = T) %>% 
  filter(model == "species_site_interaction")  %>% 
  merge(sp_info)%>% 
  clean_names()

concept_df_all <- bind_rows(concept_both_df, concept_study_df)  %>% 
  merge(sp_info)%>% 
  clean_names()

concept_df <- concept_df_all %>% 
  filter(group == "grand")  %>% 
  merge(sp_info)%>% 
  clean_names()

```

predict with species-specific slope:
```{r, predict}
# Predict water potential (mwp) for each sp_site
df_pred <- df1 %>%
  left_join(coefs_species_int, by = "species") %>%  # Merge coefficients, using separate slope and intercept per species
  mutate(
    mwp_pred = (ilfm - intercept) / slope,  # Solve for mwp using linear equation
   # lfm_pred = 1 / ilfm,  # Transform ilfm back to lfm
    lfm_pred = 1/(slope * mwp + intercept)  # Transform ilfm back to lfm
  ) 
  
# Plot predicted vs original lfm
ggplot(df_pred, aes(x = mwp, y = mwp_pred, color = sp_site)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original Water Potential",
    y = "Predicted Water Potential",
    title = "Predicted vs Original Water Potential"
  ) +
  theme_minimal()

# Plot predicted vs original lfm
ggplot(df_pred, aes(x = lfm, y = lfm_pred, color = sp_site)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original LFM",
    y = "Predicted LFM",
    title = "Predicted vs Original LFM"
  ) +
  theme_minimal()
```
predict with species and study-specific slope:
```{r, predict}
# Predict water potential (mwp) for each sp_site
df_pred <- df1 %>%
  left_join(coefs_species_study, by = "species") %>%  # Merge coefficients, using separate slope and intercept per species
  mutate(
    mwp_pred = (ilfm - intercept) / slope,  # Solve for mwp using linear equation
   # lfm_pred = 1 / ilfm,  # Transform ilfm back to lfm
    lfm_pred = 1/(slope * mwp + intercept)  # Transform ilfm back to lfm
  ) 
  
# Plot predicted vs original lfm
ggplot(df_pred, aes(x = mwp, y = mwp_pred, color = sp_site)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original Water Potential",
    y = "Predicted Water Potential",
    title = "Predicted vs Original Water Potential"
  ) +
  theme_minimal()

# Plot predicted vs original lfm
ggplot(df_pred, aes(x = lfm, y = lfm_pred, color = sp_site)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original LFM",
    y = "Predicted LFM",
    title = "Predicted vs Original LFM"
  ) +
  theme_minimal()
```

Predict with common slope:

```{r, predict}
#-----------
# Predict water potential (mwp) for each sp_site
df_pred <- df1 %>%
  left_join(coefs_common, by = "species") %>%  # Merge coefficients, using separate slope and intercept per species
  mutate(
    mwp_pred = (ilfm - intercept) / slope,  # Solve for mwp using linear equation
   # lfm_pred = 1 / ilfm,  # Transform ilfm back to lfm
    lfm_pred = 1/(slope * mwp + intercept)  # Transform ilfm back to lfm
  ) 
  
# Plot predicted vs original lfm
ggplot(df_pred, aes(x = mwp, y = mwp_pred, color = species, label = species)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original Water Potential",
    y = "Predicted Water Potential",
    title = "Predicted vs Original Water Potential"
  ) +
  theme_minimal()

# Plot predicted vs original lfm
ggplot(df_pred, aes(x = lfm, y = lfm_pred, color = species,
                    label = species)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "black") +  # 1:1 reference line
  labs(
    x = "Original LFM",
    y = "Predicted LFM",
    title = "Predicted vs Original LFM"
  ) +
  theme_minimal()
```


#####Figure 3. (models)
```{r, fig.height=5, fig.width=7}
# Define color palette for sites (color-blind friendly)
color_manual <- scale_color_manual(values  = c(
  "Pepperwood" = "#009E73",  # Green
  "StuntRanch" = "#E69F00",  # Orange
  "SEKI"       = "#56B4E9",  # Blue
  "Sedgwick"   = "#D55E00"))   # Red

# Identify the least negative (maximum) observed mwp per species
species_thresholds <- concept_both_df %>%
  filter(group == "grand") %>%
  group_by(species) %>%
  summarise(min_mwp = max(mwp, na.rm = TRUE), .groups = "drop")

# Generate model-predicted lines for each species and study
model_lines <- concept_df %>%
  filter(group == "grand") %>% 
  distinct(species, study, intercept, slope) %>%  
  group_by(species, study) %>%
  tidyr::expand_grid(mwp = seq(min(concept_df$mwp, na.rm = TRUE), max(concept_df$mwp, na.rm = TRUE), length.out = 100)) %>%
  left_join(species_thresholds, by = "species") %>%  
  mutate(
    ilfm_pred = intercept + slope * mwp,  
    line_type = ifelse(mwp > min_mwp, "dashed", "solid")  
  ) %>%
  ungroup()

# Separate data for solid and dashed lines
model_lines_solid <- model_lines %>% filter(line_type == "solid")
model_lines_dashed <- model_lines %>% filter(line_type == "dashed")

# Scatter plot of ilfm vs mwp with model lines
fig3a <- ggplot(concept_df %>%
  filter(group == "grand"), aes(x = -1 * mwp, y = ilfm)) +
  geom_point(aes(color = species), alpha = 0.3, color = "black") +  
  geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = ilfm_pred, color = study, group = interaction(species, study)), size = 0.5) +  
  geom_line(data = model_lines_dashed, aes(x = -1 * mwp, y = ilfm_pred, color = study, group = interaction(species, study)), size = 0.5, linetype = "dashed") +  
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    color = "Study"
  ) +
  color_manual +
  theme(legend.position = "none")

# Scatter plot of lfm vs mwp with model lines
fig3b <- ggplot(concept_df %>%
  filter(group == "grand"), aes(x = -1 * mwp, y = lfm)) +
  geom_point(aes(color = species), alpha = 0.3, color = "black") +  
  geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = interaction(species, study)), size = 0.5) +  
  geom_line(data = model_lines_dashed, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = interaction(species, study)), size = 0.5, linetype = "dashed") +  
  labs(
    x = "Water Potential (MPa)",
    y = "LFM",
    color = "Study"
  ) +
  color_manual +
  theme(legend.position = "none")

# Extract legend
legend <- cowplot::get_legend(
  ggplot(concept_df %>%
    filter(group == "grand"), aes(x = -1 * mwp, y = lfm)) +
    geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = interaction(species, study)), size = 0.5) +
    geom_line(data = model_lines_dashed, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = interaction(species, study)), size = 0.5, linetype = "dashed") +
    labs(color = "Study") +
    color_manual
)

# Combine plots
fig3.1 <- cowplot::plot_grid(fig3a, fig3b, nrow = 2)
fig3 <- cowplot::plot_grid(fig3.1, legend, nrow = 1, rel_widths = c(1, 0.25))
fig3

ggsave(plot = fig3, here::here("figures", "fig3.jpg"), dpi = 600, height = 4, width = 6, units = "in")
```


```{r, figure1}



# Generate model-predicted lines for each species
model_lines <- concept_df %>%
  filter(group == "grand") %>% 
  distinct(species,intercept, slope) %>%  # Get unique specie
  group_by(species) %>%
  summarise(
    mwp = seq(min(concept_df$mwp, na.rm = TRUE), max(concept_df$mwp, na.rm = TRUE), length.out = 100), # Generate x values
    ilfm_pred = intercept + slope * mwp,  # Compute predicted y values
    species = unique(species),  # Retain study info for coloring
    .groups = "drop"
  ) 


# Scatter plot of ilfm vs mwp with model lines
fig3a <- ggplot(concept_df %>%
  filter(group == "grand"), aes(x = -1*mwp, y = ilfm)) +
  geom_point(aes(color = species), alpha = 0.5) +  # Scatter points colored by species
  geom_line(data = model_lines, aes(x = -1*mwp, y = ilfm_pred, color = species), size = 0.5) +  # Model lines colored by study
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    title = "Model fits with species intercept and common slope",
    color = "Study"
  ) +
  color_species + 
  #theme_minimal() +
  theme(legend.position = "false") 

# Scatter plot of ilfm vs mwp with model lines
fig3b <- ggplot(concept_df %>%
  filter(group == "grand"), aes(x = -1*mwp, y = lfm)) +
  geom_point(aes(color = species), alpha = 0.5) +  # Scatter points colored by species
  geom_line(data = model_lines, aes(x = -1*mwp, y = 1/ilfm_pred, color = species), size = .5) +  # Model lines colored by study
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    #title = "Model fits with species intercept and common slope",
    color = "Study"
  ) +
  #theme_minimal() +
  color_species + 
  theme(legend.position = "false")

fig3 <- cowplot::plot_grid(fig3a, fig3b, nrow = 2)
fig3


# Extract legend
legend <- cowplot::get_legend(
  ggplot(concept_df %>%
    filter(group == "grand"), aes(x = -1 * mwp, y = lfm)) +
    geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = species, group = interaction(species, study)), size = 0.5) +
    labs(color = "Study") +
    color_species
)

# Combine plots
fig3.1 <- cowplot::plot_grid(fig3a, fig3b, nrow = 2)
fig3.1 <- cowplot::plot_grid(fig3.1, legend, nrow = 1, rel_widths = c(1, 0.5))
fig3.1

ggsave(plot = fig3.1, here::here("figures", "figSX_species.jpg"), dpi = 600, height = 4, width = 6, units = "in")
```


####Figure S1a, colored by f type

```{r}
concept_slopes_df <- concept_both_df %>%
  filter(group == "species")

# Model-predicted lines per species (but we will COLOR by functional_type)
model_lines <- concept_slopes_df %>%
  distinct(species, intercept, slope, functional_type) %>%
  left_join(
    concept_slopes_df %>%
      group_by(species) %>%
      summarise(
        abs_min = min(abs(mwp), na.rm = TRUE),
        abs_max = max(abs(mwp), na.rm = TRUE),   # <-- cap at highest absolute value
        sign_mwp = sign(stats::median(mwp, na.rm = TRUE)),
        .groups = "drop"
      ) %>%
      mutate(sign_mwp = if_else(sign_mwp == 0, -1, sign_mwp)), # fallback if median==0
    by = "species"
  ) %>%
  rowwise() %>%
  mutate(abs_mwp = list(seq(abs_min, abs_max, length.out = 100))) %>%
  tidyr::unnest(abs_mwp) %>%
  ungroup() %>%
  mutate(
    mwp = sign_mwp * abs_mwp,
    ilfm_pred = intercept + slope * mwp
  ) 

# ---- Panel A: iLFM ----
figSXa <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = ilfm)) +
  geom_point(aes(color = functional_type), alpha = 0.4) +
  # 1) Angiosperm lines (drawn first, underneath)
  geom_line(
    data = dplyr::filter(model_lines, functional_type == "angiosperm"),
    aes(x = -1*mwp, y = ilfm_pred, color = functional_type, group = species),
    linewidth = 0.5
  ) +
  # 2) Gymnosperm lines (drawn second, on top)
  geom_line(
    data = dplyr::filter(model_lines, functional_type == "gymnosperm"),
    aes(x = -1*mwp, y = ilfm_pred, color = functional_type, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    color = "Functional type"
  ) +
  theme(legend.position = "none") +
  scale_color_manual(
  values = c(
    "angiosperm" = "#E69F00",  # orange
    "gymnosperm" = "#0072B2"   # blue
  )
)

# ---- Panel B: LFM ----
figSXb <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = lfm)) +
  geom_point(aes(color = functional_type), alpha = 0.4) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = 1 / ilfm_pred, color = functional_type, group = species),
    linewidth = 0.5
  ) +
  geom_line(
    data = dplyr::filter(model_lines, functional_type == "angiosperm"),
    aes(x = -1*mwp, y = 1/ilfm_pred, color = functional_type, group = species),
    linewidth = 0.5
  ) +
  geom_line(
    data = dplyr::filter(model_lines, functional_type == "gymnosperm"),
    aes(x = -1*mwp, y = 1/ilfm_pred, color = functional_type, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    color = "Functional type"
  ) +
  theme(legend.position = "none") +
  scale_color_manual(
  values = c(
    "angiosperm" = "#E69F00",  # orange
    "gymnosperm" = "#0072B2"   # blue
  )
)

# ---- Legend (functional_type colors, but still one line per species) ----
legend <- cowplot::get_legend(
  ggplot(model_lines, aes(x = -1 * mwp, y = 1 / ilfm_pred,
                          color = functional_type, group = species)) +
    geom_line(linewidth = 0.6) +
    labs(color = "Functional type") +
    theme_minimal() +
    scale_color_manual(
  values = c(
    "angiosperm" = "#E69F00",  # orange
    "gymnosperm" = "#0072B2"   # blue
  )
)
  # + your_functional_type_scale_here
  # e.g., + scale_color_manual(values = ft_cols)
)

# Combine + save
figSX <- cowplot::plot_grid(figSXa, figSXb, nrow = 2)
figSX <- cowplot::plot_grid(figSX, legend, nrow = 1, rel_widths = c(1, 0.35))

figSX

ggsave(
  plot = figSX,
  filename = here::here("figures", "figSX_species_lines_colored_by_functional_type.jpg"),
  dpi = 600, height = 4, width = 6, units = "in"
)

```
####Figure S1a, colored by genus

```{r}
concept_slopes_df <- concept_both_df %>%
  filter(group == "species") 

model_lines <- concept_slopes_df%>%
  distinct(species, genus, intercept, slope) %>%
  left_join(
    concept_slopes_df %>%
      group_by(species) %>%
      summarise(
       abs_min = min(abs(mwp), na.rm = TRUE),
        abs_max = max(abs(mwp), na.rm = TRUE),   # <-- cap at highest absolute value
        sign_mwp = sign(stats::median(mwp, na.rm = TRUE)),
        .groups = "drop"
      ) %>%
      mutate(sign_mwp = if_else(sign_mwp == 0, -1, sign_mwp)), # fallback if median==0
    by = "species"
  ) %>%
  rowwise() %>%
  mutate(abs_mwp = list(seq(abs_min, abs_max, length.out = 100))) %>%
  tidyr::unnest(abs_mwp) %>%
  ungroup() %>%
  mutate(
    mwp = sign_mwp * abs_mwp,
    ilfm_pred = intercept + slope * mwp
  )

# ---- Panel A: iLFM ----
figSXa <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = ilfm)) +
  geom_point(aes(color = genus), alpha = 0.5) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = ilfm_pred, color = genus, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    color = "Genus"
  ) +
  theme(legend.position = "none")


# ---- Panel B: LFM ----
figSXb <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = lfm)) +
  geom_point(aes(color = genus), alpha = 0.5) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = 1 / ilfm_pred, color = genus, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    color = "Genus"
  ) +
  theme(legend.position = "none")


# ---- Legend (functional_type colors, but still one line per species) ----
legend <- cowplot::get_legend(
  ggplot(model_lines,
         aes(x = -1 * mwp, y = 1 / ilfm_pred,
             color = genus, group = species)) +
    geom_line(linewidth = 0.6) +
    labs(color = "Genus") +
    theme_minimal()
  # + scale_color_manual(values = genus_cols)  # if you have one
)


# Combine + save
figSX <- cowplot::plot_grid(figSXa, figSXb, nrow = 2)
figSX <- cowplot::plot_grid(figSX, legend, nrow = 1, rel_widths = c(1, 0.35))

figSX

ggsave(
  plot = figSX,
  filename = here::here("figures", "figSX_species_lines_colored_by_genus.jpg"),
  dpi = 600, height = 4, width = 6, units = "in"
)

```
####Figure S1a, colored by family

```{r}
concept_slopes_df <- concept_both_df %>%
  filter(group == "species") 

model_lines <- concept_slopes_df %>%
  distinct(species, family, intercept, slope)  %>%
  left_join(
    concept_slopes_df %>%
      group_by(species) %>%
      summarise(
        abs_min = min(abs(mwp), na.rm = TRUE),
        abs_max = max(abs(mwp), na.rm = TRUE),   # <-- cap at highest absolute value
        sign_mwp = sign(stats::median(mwp, na.rm = TRUE)),
        .groups = "drop"
      ) %>%
      mutate(sign_mwp = if_else(sign_mwp == 0, -1, sign_mwp)), # fallback if median==0
    by = "species"
  ) %>%
  rowwise() %>%
  mutate(abs_mwp = list(seq(abs_min, abs_max, length.out = 100))) %>%
  tidyr::unnest(abs_mwp) %>%
  ungroup() %>%
  mutate(
    mwp = sign_mwp * abs_mwp,
    ilfm_pred = intercept + slope * mwp
  ) 

# ---- Panel A: iLFM ----
figSXa <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = ilfm)) +
  geom_point(aes(color = family), alpha = 0.5) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = ilfm_pred, color = family, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    color = "family"
  ) +
  theme(legend.position = "none")


# ---- Panel B: LFM ----
figSXb <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = lfm)) +
  geom_point(aes(color = family), alpha = 0.5) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = 1 / ilfm_pred, color = family, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    color = "family"
  ) +
  theme(legend.position = "none")


# ---- Legend (functional_type colors, but still one line per species) ----
legend <- cowplot::get_legend(
  ggplot(model_lines,
         aes(x = -1 * mwp, y = 1 / ilfm_pred,
             color = family, group = species)) +
    geom_line(linewidth = 0.6) +
    labs(color = "family") +
    theme_minimal()
  # + scale_color_manual(values = family_cols)  # if you have one
)


# Combine + save
figSX <- cowplot::plot_grid(figSXa, figSXb, nrow = 2)
figSX <- cowplot::plot_grid(figSX, legend, nrow = 1, rel_widths = c(1, 0.35))

figSX

ggsave(
  plot = figSX,
  filename = here::here("figures", "figSX_species_lines_colored_by_family.jpg"),
  dpi = 600, height = 4, width = 6, units = "in"
)

```

####Figure S1., colored by species
```{r, figure1}
concept_slopes_df <- concept_both_df %>%
  filter(group == "species") 

# Generate model-predicted lines for each species
model_lines <- concept_slopes_df  %>% 
  merge(table1_df)%>% 
  distinct(species, intercept, slope, family)  %>%
  left_join(
    concept_slopes_df %>%
      group_by(species) %>%
      summarise(
        abs_min = min(abs(mwp), na.rm = TRUE),
        abs_max = max(abs(mwp), na.rm = TRUE),   # <-- cap at highest absolute value
        sign_mwp = sign(stats::median(mwp, na.rm = TRUE)),
        .groups = "drop"
      ) %>%
      mutate(sign_mwp = if_else(sign_mwp == 0, -1, sign_mwp)), # fallback if median==0
    by = "species"
  ) %>%
  rowwise() %>%
  mutate(abs_mwp = list(seq(abs_min, abs_max, length.out = 100))) %>%
  tidyr::unnest(abs_mwp) %>%
  ungroup() %>%
  mutate(
    mwp = sign_mwp * abs_mwp,
    ilfm_pred = intercept + slope * mwp
  ) 

# Scatter plot of ilfm vs mwp with model lines
figSXa <- ggplot(concept_slopes_df , aes(x = -1*mwp, y = ilfm)) +
  geom_point(aes(color = species), alpha = 0.5) +  # Scatter points colored by species
  geom_line(data = model_lines, aes(x = -1*mwp, y = ilfm_pred, color = species), size = 0.5) +  # Model lines colored by study
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
   # title = "Model fits with species intercept and slope",
    color = "Study"
  ) +
  color_species + 
  #theme_minimal() +
  theme(legend.position = "false")

# Scatter plot of ilfm vs mwp with model lines
figSXb <- ggplot(concept_slopes_df , aes(x = -1*mwp, y = lfm)) +
  geom_point(aes(color = species), alpha = 0.5) +  # Scatter points colored by species
  geom_line(data = model_lines, aes(x = -1*mwp, y = 1/ilfm_pred, color = species), size = .5) +  # Model lines colored by study
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    #title = "Model fits with species intercept and slope",
    color = "Study"
  ) +
  #theme_minimal() +
  color_species + 
  theme(legend.position = "false")


# Extract legend
legend <- cowplot::get_legend(
  ggplot(concept_df %>%
    filter(group == "grand"), aes(x = -1 * mwp, y = lfm)) +
    geom_line(data = model_lines_solid, aes(x = -1 * mwp, y = 1 / ilfm_pred, color = species, group = interaction(species, study)), size = 0.5) +
    labs(color = "Species") +
    color_species
)

# Combine plots
figSX <- cowplot::plot_grid(figSXa, figSXb, nrow = 2)
figSX
figSX <- cowplot::plot_grid(figSX, legend, nrow = 1, rel_widths = c(1, 0.5))
figSX

ggsave(plot = figSX, here::here("figures", "figSX_fgroup_sppint.jpg"), dpi = 600, height = 4, width = 6, units = "in")
```

###Figure S1., colored by study
```{r, figure1}
concept_slopes_df <- concept_both_df %>%
  filter(group == "species") 

model_lines <- concept_slopes_df %>%
  distinct(species, study, intercept, slope)  %>%
  left_join(
    concept_slopes_df %>%
      group_by(species) %>%
      summarise(
        abs_min = min(abs(mwp), na.rm = TRUE),
        abs_max = max(abs(mwp), na.rm = TRUE),   # <-- cap at highest absolute value
        sign_mwp = sign(stats::median(mwp, na.rm = TRUE)),
        .groups = "drop"
      ) %>%
      mutate(sign_mwp = if_else(sign_mwp == 0, -1, sign_mwp)), # fallback if median==0
    by = "species"
  ) %>%
  rowwise() %>%
  mutate(abs_mwp = list(seq(abs_min, abs_max, length.out = 100))) %>%
  tidyr::unnest(abs_mwp) %>%
  ungroup() %>%
  mutate(
    mwp = sign_mwp * abs_mwp,
    ilfm_pred = intercept + slope * mwp
  ) 

# ---- Panel A: iLFM ----
figSXa <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = ilfm)) +
  geom_point(aes(color = study), alpha = 0.5) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = ilfm_pred, color = study, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "iLFM",
    color = "study"
  ) +
  theme(legend.position = "none")


# ---- Panel B: LFM ----
figSXb <- ggplot(concept_slopes_df, aes(x = -1 * mwp, y = lfm)) +
  geom_point(aes(color = study), alpha = 0.5) +
  geom_line(
    data = model_lines,
    aes(x = -1 * mwp, y = 1 / ilfm_pred, color = study, group = species),
    linewidth = 0.5
  ) +
  labs(
    x = "Water Potential (MWP)",
    y = "LFM",
    color = "study"
  ) +
  theme(legend.position = "none")


# ---- Legend (functional_type colors, but still one line per species) ----
legend <- cowplot::get_legend(
  ggplot(model_lines,
         aes(x = -1 * mwp, y = 1 / ilfm_pred,
             color = study, group = species)) +
    geom_line(linewidth = 0.6) +
    labs(color = "study") +
    theme_minimal()
  # + scale_color_manual(values = study_cols)  # if you have one
)


# Combine + save
figSX <- cowplot::plot_grid(figSXa, figSXb, nrow = 2)
figSX <- cowplot::plot_grid(figSX, legend, nrow = 1, rel_widths = c(1, 0.35))

figSX

ggsave(
  plot = figSX,
  filename = here::here("figures", "figSX_species_lines_colored_by_study.jpg"),
  dpi = 600, height = 4, width = 6, units = "in"
)

```

#####Figure SX (differences across studies)
```{r, slopes}
model <- lm(ilfm ~ mwp * sp_site, data = df1)
summary(model)

coef_sp_site_dupes <- coefs_species_study %>% 
  group_by(species) %>% 
  filter(n() >= 2)

spp_dupes <- list(unique(coef_sp_site_dupes$species))
spp_dupes

df2 <- df %>% 
  filter(species %in% c("ADEFAS", "HETARB", "QUEAGR", "QUEDOU", "QUEKEL"))

# Step 1: Run interaction models for each species
interaction_results <- df2 %>%
  group_by(species) %>%
  group_modify(~ {
    model <- lm(ilfm ~ mwp * sp_site, data = .x)
    interaction_p <- anova(model)[["Pr(>F)"]][which(rownames(anova(model)) == "mwp:sp_site")]
    tibble(interaction_p = interaction_p)
  }) %>%
  mutate(sig_interaction = interaction_p < 0.05)

df_plot <- df2 %>%
  left_join(interaction_results, by = "species")

# 1) Build a little df with one row per facet containing the star label + position
#    Assumes df_plot has a logical column sig_interaction per species (TRUE/FALSE)
star_df <- df_plot %>%
  group_by(species) %>%
  summarise(
    sig = any(sig_interaction, na.rm = TRUE),
    x_pos = max(mwp, na.rm = TRUE),
    y_pos = max(ilfm, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    star = ifelse(sig, "Sig. site effect", ""),
    # nudge in from the upper-right corner a bit
    x_pos = x_pos - 0.03 * (x_pos - min(df_plot$mwp, na.rm = TRUE)),
    y_pos = y_pos - 0.03 * (y_pos - min(df_plot$ilfm, na.rm = TRUE))
  )

# 2) Plot: constant line size + add stars in upper right of each panel
figSX_studydiffs <- ggplot(df_plot, aes(x = mwp, y = ilfm, color = study, group = sp_site)) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 0.7) +   # all same thickness
  geom_text(
    data = star_df,
    aes(x = x_pos, y = y_pos, label = star),
    inherit.aes = FALSE,
    hjust = 1, vjust = 1,
    size = 3,
    color = "black"
  ) +
  facet_wrap(~ species, scales = "free") +
  labs(
    x = "Minimum Water Potential (MPa)",
    y = "1/LFM",
    color = "Site"
  ) +
  theme(
    legend.position = "right",
    strip.text = element_text(face = "bold"),
    plot.title = element_text(face = "bold", size = 16)
  ) +
  theme(
  legend.position = c(0.95, 0.05),   # lower right
  legend.justification = c(1, 0),    # anchor legend box at its bottom-right
  strip.text = element_text(face = "bold"),
  plot.title = element_text(face = "bold", size = 16)
) +
  scale_color_manual(values  = c(
    "Pepperwood" = "#009E73",
    "StuntRanch" = "#E69F00",
    "SEKI"       = "#56B4E9",
    "Sedgwick"   = "#D55E00"
  ))

figSX_studydiffs

ggsave(plot =figSX_studydiffs, 
        filename = here::here("figures", "figSX_studydiffs.jpg"), 
       dpi = 600, width = 9, height = 5)

```
#Q2: 
```{r}
color_species <- scale_color_manual(
  values = c(
    ABICON = "#17154f",
    ADEFAS = "#2f357c",
    ARBMEN = "#6c5d9e",
    
    ARCGLA = "#9d9cd5",
    ARCPAT = "#b0799a",
    CALDEC = "#59385c",
    CEACUN = "#f6b3b0",
    
    CEAPAR = "#b38711",
    CEASPI = "#e48171",
    CERBET = "#d8b847",
    
    ERIFAS = "#bf3729",
    HETARB = "#e69b00",
    
    MALLAU = "#f5bb50",
    PINJEF = "#ada43b",
    PSEMEN = "#355828",
    
    QUEAGR = "#5b859e",
    QUEBER = "#1e395f",
    QUEDOU = "#75884b",
    
    QUEDUR = "#1e5a46",
    QUEGAR = "#df8d71",
    QUEKEL = "#af4f2f",
    
    SALLEU = "#d48f90",
    SALMEL = "#732f30",
    UMBCAL = "#d8b847"
  ),
  drop = FALSE
)
```


Question: Across species, what are the contributions of initial LFM and minimum WP to explain variation in minimum LFM observed at the end of the dry season (following the conceptual model in Figure 2)? 

```{r, minwpvsmaxlfm}
concept_params_df <- concept_both_df %>% 
  clean_names() %>% 
  group_by(species) %>% 
  mutate(minlfm = min(lfm, na.rm = T),
         maxlfm = max(lfm, na.rm = T),
         minwp = min(mwp, na.rm = T), 
         maxwp = max(mwp, na.rm = T),
         minilfm = 1/minlfm, 
         intercept_lfm = 1/intercept,
         maxlfm_minwp = -1*minwp + maxlfm
         ) %>% 
  merge(sp_info) %>% 
  clean_names()
```


```{r, minwpvsmaxlfm}
#species vs. grand intercepts: 
concept_df_wide <- concept_params_df %>% 
  rename(spp_code = species) %>% 
  select(spp_code, group, intercept) %>% 
  distinct() %>%  # Ensure unique rows
  pivot_wider(names_from = group, values_from = intercept, names_repair = "unique")

concept_df_wide %>% 
ggplot(aes(x = grand, 
           y = species, 
           color = spp_code)) +
  geom_abline() +
  geom_point()


df <- concept_params_df %>% filter(group == "species")

q2mod <- lmer(minlfm ~ maxlfm + minwp + (1|species) + (1|study), data = df)
q2mod
summary(q2mod)

head(concept_params_df)
```

For species-interaction model, are there sig relationships? 

```{r}
params_test_df <- concept_params_df %>% 
  select(species, intercept, intercept_lfm, slope, minlfm, minwp, minilfm, group, maxlfm, maxwp, 
         genus, functional_type) %>% 
  unique()

fig4a <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = intercept_lfm, 
             x = minlfm, 
            )) +
  geom_point(aes( color = species)) +
  geom_smooth(method = "lm", se  = F) +
  color_species +
  stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4a
#initial LFM does not well explain end of season LFM

fig4b <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = intercept, 
             x = minlfm, 
            )) +
  geom_point(aes( color = species)) +
  geom_smooth(method = "lm", se  = F) +
   stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4b
#Initial 1/lfm does seem to kinda explain how low water potentials eventually go... 


fig4c <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = intercept, 
             x = minwp, 
            )) +
  geom_abline()+
  geom_point(aes(color = species)) +
  geom_smooth(method = "lm", se  = F, color = "black") +
  stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4c
#Intercept is related to but not totally teh same as the intercept


fig4d <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = minwp, 
             x = maxlfm, 
            )) +
  geom_point(aes( color = species)) +
  geom_smooth(method = "lm", se  = F) +
stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4d

fig4e <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = maxwp, 
             x = minlfm, 
            )) +
  geom_point(aes( color = species)) +
  geom_smooth(method = "lm", se  = F) +
stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4e
#Intercept is related to but not totally teh same as the intercept

fig4f <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = minwp, 
             x = minlfm, 
            )) +
  geom_point(aes( color = species)) +
 # geom_smooth(method = "lm", se  = F) +
  color_species +
stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4f

fig4g <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = slope, 
             x = minlfm, 
            )) +
  geom_point(aes( color = species)) +
 # geom_smooth(method = "lm", se  = F) +
  color_species +
stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4g


fig4g <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = slope, 
             x = maxlfm, 
            )) +
  geom_point(aes( color = species)) +
 # geom_smooth(method = "lm", se  = F) +
  color_species +
stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4g

fig4h <- params_test_df %>% 
  filter(group == "species") %>% 
  ggplot(aes(y = slope, 
             x = minwp, 
            )) +
  geom_point(aes( color = species)) +
 # geom_smooth(method = "lm", se  = F) +
  color_species +
stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
fig4h

# fig4h <- params_test_df %>% 
#   filter(group == "species") %>% 
#   ggplot(aes(y = maxlfm_minwp, 
#              x = minlfm, 
#             )) +
#   geom_point(aes( color = species)) +
#  # geom_smooth(method = "lm", se  = F) +
#   color_species +
#   stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
#   stat_poly_line()
# fig4h

```
#### Figure 4a (param correlations):
```{r}
make_lm_plot <- function(df, xvar, yvar, xlab, ylab, eq_x = NULL, eq_y = NULL, eq_col = "black") {
  model <- lm(reformulate(xvar, yvar), data = df)
  eqn <- paste0(
    "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3),
    "\nR² = ", round(summary(model)$r.squared, 3),
    "\np = ", signif(summary(model)$coefficients[2, 4], 3)
  )
  
  # Default to upper left corner unless overridden
  if (is.null(eq_x)) eq_x <- min(df[[xvar]], na.rm = TRUE)
  if (is.null(eq_y)) eq_y <- max(df[[yvar]], na.rm = TRUE)

  ggplot(df, aes_string(x = xvar, 
                        y = yvar, 
                       # shape = "functional type",
                        color = "species")) +
    geom_point(size = 2) +
    geom_smooth(method = "lm", se = FALSE, color = eq_col) +
    annotate("text", x = eq_x, y = eq_y, label = eqn, hjust = 0, vjust = 1,
             size = 3.5, color = eq_col, fontface = "italic") +
    color_species +
    labs(x = xlab, y = ylab, color = "Species") +
   # theme_minimal(base_size = 12) +
    theme(legend.position = "right")
}

df_plot <- params_test_df %>% filter(group == "species")

fig4a <- make_lm_plot(df_plot, "minlfm", "intercept_lfm", "Minimum LFM (%)", "Intercept LFM")
fig4b <- make_lm_plot(df_plot, "minlfm", "intercept", "Minimum LFM (%)", "Model Intercept (1/LFM)")
fig4c <- make_lm_plot(df_plot, "minwp", "intercept", "Minimum WP (MPa)", "Model Intercept (1/LFM)")
fig4d <- make_lm_plot(df_plot, "maxlfm", "minwp", "Maximum LFM (%)", "Minimum WP (MPa)")
fig4e <- make_lm_plot(df_plot, "minlfm", "maxwp", "Minimum LFM (%)", "Maximum WP (MPa)")
fig4f <- make_lm_plot(df_plot, "minlfm", "minwp", "Minimum LFM (%)", "Minimum WP (MPa)")
fig4g <- make_lm_plot(df_plot, "minlfm", "slope", "Minimum LFM (%)", "Model Slope")
fig4h <- make_lm_plot(df_plot, "maxlfm", "slope", "Maximum LFM (%)", "Model Slope")
fig4i <- make_lm_plot(df_plot, "minwp", "slope", "Minimum WP (MPa)", "Model Slope")
fig4j <- make_lm_plot(df_plot, "maxwp", "slope", "Maximum WP (MPa)", "Model Slope")


library(cowplot)

legend <- get_legend(
  fig4a + theme(legend.box.margin = margin(0, 0, 5, 0))
)

plots_figsx_param_corrs <- plot_grid(
  fig4a + theme(legend.position = "none"),
  fig4b + theme(legend.position = "none"),
  fig4c + theme(legend.position = "none"),
  fig4d + theme(legend.position = "none"),
  fig4e + theme(legend.position = "none"),
  fig4f + theme(legend.position = "none"),
  fig4g + theme(legend.position = "none"),
  fig4h + theme(legend.position = "none"), 
  fig4i + theme(legend.position = "none"),
  fig4j + theme(legend.position = "none"),
  ncol = 3,
  
  labels = LETTERS[1:9]
)

plots_figsx_param_corrs_final <- plot_grid(plots_figsx_param_corrs, legend, rel_widths = c(1, .25), nrow = 1)
plots_figsx_param_corrs_final


ggsave(plot =plots_figsx_param_corrs_final, 
        filename = here::here("figures", "figsx_param_corrs.jpg"), 
       dpi = 600, width = 12, height = 10)

#Save only the significant ones:
```


```{r}
plots_fig4a <- plot_grid(
  #fig4a + theme(legend.position = "none"),
  #fig4b + theme(legend.position = "none"),
 # fig4c + theme(legend.position = "none"),
 # fig4d + theme(legend.position = "none"),
 # fig4e + theme(legend.position = "none"),
  fig4f + theme(legend.position = "none"),
  fig4g + theme(legend.position = "none"),
 # fig4i + theme(legend.position = "none"),
  nrow = 1,
  labels = LETTERS[1:2]
)

plots_fig4a_final <- plot_grid(plots_fig4a, legend, rel_widths = c(1, .25), nrow = 1)
plots_fig4a_final


ggsave(plot =plots_fig4a_final, 
        filename = here::here("figures", "fig4a.jpg"), 
       dpi = 600, width = 9, height = 3.5)

```



Chat rewrite to get same y axis: 

```{r}
#### Figure 4a (param correlations): significant ones, y = Minimum LFM (shared across panels)


make_lm_plot <- function(df, xvar, yvar, xlab, ylab,
                         eq_x = NULL, eq_y = NULL, eq_col = "black") {

  model <- lm(reformulate(xvar, yvar), data = df)
  eqn <- paste0(
    "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3),
    "\nR² = ", round(summary(model)$r.squared, 3),
    "\np = ", signif(summary(model)$coefficients[2, 4], 3)
  )

  # defaults: upper-left-ish in data space
  if (is.null(eq_x)) eq_x <- min(df[[xvar]], na.rm = TRUE)
  if (is.null(eq_y)) eq_y <- max(df[[yvar]], na.rm = TRUE)

 ggplot(df, aes(
  x = .data[[xvar]],
  y = .data[[yvar]]*100,
  color = species
)) +

    geom_point(size = 2, aes(shape = functional_type)) +
    geom_smooth(method = "lm", se = FALSE, color = eq_col) +
    annotate(
      "text", x = eq_x, y = eq_y, label = eqn,
      hjust = 0, vjust = 1, size = 3.5,
      color = eq_col, fontface = "italic"
    ) +
    color_species +
   scale_shape_manual(
  values = c(
    "angiosperm" = 16,  # filled circle
    "gymnosperm" = 17   # filled triangle
  )
) +
    labs(x = xlab, y = ylab, color = "Species", shape = "Functional Type") +
    theme(legend.position = "right") +
   theme(
  legend.text  = element_text(size = 8),
  legend.title = element_text(size = 9),
  legend.key.size = unit(0.5, "lines")
)
}

library(dplyr)
library(cowplot)

df_plot <- params_test_df %>% filter(group == "species")

# Shared y-limits across both panels (Minimum LFM)
ylims_minlfm <- range(df_plot$minlfm*100, na.rm = TRUE)

# --- Panel A: Minimum LFM vs Minimum WP ---
fig4f_yminlfm <- make_lm_plot(
  df_plot,
  xvar = "minwp",
  yvar = "minlfm",
  xlab = "Minimum WP (MPa)",
  ylab = "Minimum LFM (%)"
) +
  coord_cartesian(ylim = ylims_minlfm)

# --- Panel B: Minimum LFM vs Model Slope ---
fig4g_yminlfm <- make_lm_plot(
  df_plot,
  xvar = "slope",
  yvar = "minlfm",
  xlab = "Model Slope",
  ylab = "Minimum LFM (%)"
) +
  coord_cartesian(ylim = ylims_minlfm)

# Legend (same as before)
legend <- get_legend(
  fig4f_yminlfm + theme(legend.box.margin = margin(0, 0, 5, 0))
)

# Combine with shared y scale + single y-axis labeling
plots_fig4a <- plot_grid(
  fig4f_yminlfm +
    theme(legend.position = "none"),
  fig4g_yminlfm +
    theme(legend.position = "none") +
    theme(axis.title.y = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank()),
  nrow = 1,
  labels = LETTERS[1:2],
  align = "v",
  axis = "l"
)

plots_fig4a_final <- plot_grid(plots_fig4a, legend, rel_widths = c(1, .25), nrow = 1)
plots_fig4a_final

ggsave(
  plot = plots_fig4a_final,
  filename = here::here("figures", "fig4a.jpg"),
  dpi = 600, width = 9, height = 3.5
)

```

####Figure 4. (isocline)

Using common slope for all species: 

```{r, fig.height=4, fig.width=6}
# Read species results
# spres_old <- read.csv(here('results', 'species-results.csv'))

# Ensure 'spres' has all the necessary columns from the previous steps
spres <- concept_params_df %>% 
  filter(group == "grand") %>% 
  mutate(model1.int = intercept,
         model1.slp = slope,  # Ensure slope is named 'model1.slp'
         SpCode6 = species, 
         minWP = minwp)

# Inspect the modified dataframe
head(spres)

# Generate a sequence of inverse LFM saturation values
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)

# Initialize an empty list to store critical MWP values for each species
MWPcrit_list <- list()

# Loop through each unique species and calculate the critical MWP using species-specific slopes
for (sp in unique(spres$species)) {
  
  # Get the species-specific slope from 'spres'
  species_slope <- spres %>% 
    filter(species == sp) %>% 
    pull(model1.slp)
  
  # Initialize a vector to hold critical MWP values for the current species
  MWPcrit <- c()
  
  # Calculate critical MWP for the current species
  for (i in 1:length(ilfm.sat.vec)) {
    MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.7)  # Use species-specific slope
  }
  
  # Store the results for each species in the list
  MWPcrit_list[[sp]] <- MWPcrit
}

# Convert inverse LFM saturation values back to LFM
lfm.sat.vec <- 1 / ilfm.sat.vec

# Step 7: Plot the conceptual model curve
plot(MWPcrit, lfm.sat.vec, 
     xlim = c(-8, 0), ylim = c(0, 4),
     type = 'l', lwd = 0, col = "blue",
     xlab = 'Minimum Minimum Water Potential (MPa)', 
     ylab = 'LFM @ Midday Water Potential = 0')

# Step 8: Repeat the calculations for different LFM thresholds

# 60% LFM
for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.62)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, lwd = 1, col = "maroon")
text(MWPcrit[length(MWPcrit)], lfm.sat.vec[length(lfm.sat.vec)], labels = "60% LFM", pos = 4, col = "maroon", cex = 0.8)

# 77% LFM
for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.77)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, lwd = 1, col = "goldenrod")
text(MWPcrit[length(MWPcrit)], lfm.sat.vec[length(lfm.sat.vec)], labels = "77% LFM", pos = 3, col = "goldenrod", cex = 0.8)

# Step 9: Add species data points to the conceptual model plot
# text(I(1 / model1.int) ~ minWP,
#      data = spres,
#      labels = spres$SpCode6,
#      pos = 4,
#      cex = 0.6) # Reduced text size to prevent overlap

# Assign unique letters to unique species
unique_species <- unique(spres$SpCode6)
species_letters <- setNames(letters[1:length(unique_species)], unique_species)

# Add a new column in 'spres' mapping species to their assigned letters
spres$Letter <- species_letters[spres$SpCode6]

# Create a letter-to-species lookup table
letter_mapping <- data.frame(
  Letter = spres$Letter,
  Species = spres$SpCode6
) %>% distinct()  # Ensure each species appears only once

# Define color palette for species
color_species = c(
    ABICON = "#17154f",
    ADEFAS = "#2f357c",
    ARBMEN = "#6c5d9e",
    
    ARCGLA = "#9d9cd5",
    ARCPAT = "#b0799a",
    CALDEC = "#59385c",
    CEACUN = "#f6b3b0",
    
    CEAPAR = "#b38711",
    CEASPI = "#e48171",
    CERBET = "#d8b847",
    
    ERIFAS = "#bf3729",
    HETARB = "#e69b00",
    
    MALLAU = "#f5bb50",
    PINJEF = "#ada43b",
    PSEMEN = "#355828",
    
    QUEAGR = "#5b859e",
    QUEBER = "#1e395f",
    QUEDOU = "#75884b",
    
    QUEDUR = "#1e5a46",
    QUEGAR = "#df8d71",
    QUEKEL = "#af4f2f",
    
    SALLEU = "#d48f90",
    SALMEL = "#732f30",
    UMBCAL = "#d8b847"
  )

# Ensure we have enough colors for all unique species
color_species <- setNames(color_species[1:length(unique_species)], unique_species)

# Add species-specific labels at the correct locations
text(spres$minWP, 1 / spres$model1.int,  # (x, y) coordinates
     labels = spres$Letter,               # Assign unique letters instead of species codes
     col = color_species[spres$SpCode6],  # Assign colors by species
     #pos = 5,                              # Adjust text positioning
     cex = 1)                            # Adjust text size to avoid overlap

```
To save the isocline: 
```{r}
# Save base R plot as high-resolution JPEG
jpeg(filename = here::here("figures", "fig4.jpg"), 
     width = 5, height = 4, units = "in", res = 600)

# Reduce whitespace: bottom, left, top, right margins
par(mar = c(3.5, 3.5, 1, 1), mgp = c(2, 0.6, 0))  # mgp controls label spacing
# Re-run the plotting code below to draw inside the jpeg device

# Step 7: Plot the conceptual model curve
plot(MWPcrit, lfm.sat.vec, 
     xlim = c(-8, 0), ylim = c(0, 4),
     type = 'l', lwd = 0, col = "blue",
     xlab = 'Minimum Minimum Water Potential (MPa)', 
     ylab = 'LFM @ Midday Water Potential = 0')

# 60% LFM line
for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.62)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, lwd = 1, col = "maroon")
text(MWPcrit[length(MWPcrit)], lfm.sat.vec[length(lfm.sat.vec)], labels = "60% LFM", pos = 4, col = "maroon", cex = 0.8)

# 77% LFM line
for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.77)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, lwd = 1, col = "goldenrod")
text(MWPcrit[length(MWPcrit)], lfm.sat.vec[length(lfm.sat.vec)], labels = "77% LFM", pos = 3, col = "goldenrod", cex = 0.8)

# Add species labels (letters)
text(spres$minWP, 1 / spres$model1.int,
     labels = spres$Letter,
     col = color_species[spres$SpCode6],
     cex = 1)

# Close the jpeg device
dev.off()

# Print letter-to-species mapping table
print(letter_mapping)

# Load necessary package
library(knitr)

# Print the letter-to-species mapping as a formatted table
letter_mapping %>% 
  kable(format = "pipe", col.names = c("Letter", "Species"))

write.csv(letter_mapping, file = here::here("figures", "letter_mapping.csv"), row.names = FALSE)
```
To save isocline labels: 

```{r}
library(dplyr)
library(knitr)
library(kableExtra)
library(here)

# Create the colored table
letter_mapping_colored <- letter_mapping %>%
  mutate(Letter = paste0("<span style='color:", color_species[Species], "'>", Letter, "</span>"))

# Generate the HTML table
table_html <- letter_mapping_colored %>%
  kable("html", escape = FALSE, col.names = c("Letter", "Species")) %>%
  kable_styling(full_width = FALSE, position = "left")

# Build full HTML page with styling for 2-column layout and smaller text
html_page <- paste0(
  "<!DOCTYPE html>
  <html>
  <head>
    <meta charset='UTF-8'>
    <title>Letter Mapping</title>
    <style>
      body {
        font-size: 0.85em;
        column-count: 2;
        column-gap: 2em;
        font-family: sans-serif;
      }
      table {
        margin-bottom: 1em;
        break-inside: avoid;
      }
    </style>
  </head>
  <body>",
  table_html,
  "</body>
  </html>"
)

# Save to file
writeLines(html_page, here("figures", "letter_mapping.html"))
```

####Figure 4, (genus)
```{r}
library(dplyr)

# ----------------------------
# Build spres from parameters
# ----------------------------
spres <- concept_params_df %>% 
  filter(group == "grand") %>% 
  mutate(
    model1.int = intercept,
    model1.slp = slope,      # slope column for convenience
    SpCode6    = species, 
    minWP      = minwp
  )

# ----------------------------
# Join Genus info (REQUIRED)
#   - Replace `species_key_df` with your actual table name
#   - Must contain columns: SpCode6, Genus
# ----------------------------
spres <- spres %>%
  left_join(SpCodes %>% select(SpCode6, Genus), by = "SpCode6")

# Optional check for any species missing a Genus
if (any(is.na(spres$Genus))) {
  warning("Some SpCode6 have no Genus in species_key_df.")
}

# ----------------------------
# Generate conceptual curves
# ----------------------------
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)

# If you truly want species-specific MWPcrit per species, your list builder is fine.
# Keeping for completeness (not used directly in the plot below):

MWPcrit_list <- list()
for (sp in unique(spres$species)) {
  species_slope <- spres %>% filter(species == sp) %>% pull(model1.slp)
  MWPcrit <- numeric(length(ilfm.sat.vec))
  for (i in seq_along(ilfm.sat.vec)) {
    MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.7)
  }
  MWPcrit_list[[sp]] <- MWPcrit
}

# Use a "typical" slope for drawing the conceptual lines (so code below is robust).
# If you prefer a different summary (mean, a specific species, etc.), change here:
species_slope <- median(spres$model1.slp, na.rm = TRUE)

# ----------------------------
# Plot open: 
# ----------------------------

# Open JPEG device
jpeg(
  filename = here::here("figures", "Fig2_genus.jpg"),
  width    = 7,   
  height   = 4.5,     
  units    = "in",
  res      = 300    # high resolution
)


## 1) Make room on the right (set before plotting)

op <- par(no.readonly = TRUE)                  # save current par
# Tight margins + space for legend in right margin
par(mar = c(4, 4, 0.5, 6), mgp = c(2.2, 0.6, 0), xpd = TRUE) # add right margin & allow drawing in margins

# ----------------------------
# Colors by Genus (CHANGE HERE)
# ----------------------------
# Okabe–Ito palette; expand if more genera than base colors
okabe_ito <- c("#17154f", "#f6b3b0",  "#732f30", "#e69b00", "#5b859e", "#b38711", "#6c5d9e",  "#1e395f", "#e48171", "#bf3729",  "#355828", "#ab84a5","#9d9cd5", "#ada43b", "#5b859e", "#75884b", "#df8d71", "#af4f2f", "#d48f90", "#59385c", "#d8b847")

genus_levels <- sort(unique(spres$Genus))
ng <- length(genus_levels)
genus_colors <- if (ng > length(okabe_ito)) {
  grDevices::colorRampPalette(okabe_ito)(ng)
} else {
  okabe_ito[seq_len(ng)]
}
genus_cols <- setNames(genus_colors, genus_levels)
# ----------------------------
# Base curve at 70% (reference), multiplied by 100
# ----------------------------
# --- Build the base (70%) reference once, then scale y to percent for plotting
MWPcrit <- numeric(length(ilfm.sat.vec))
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.7)
}
lfm_pct <- (1 / ilfm.sat.vec) * 100  # scale to percent for plotting

plot(
  MWPcrit, lfm_pct,
  xlim = c(-8, 0.1), ylim = c(0, 400),
  type = "l", lwd = 0, col = "blue",
  xlab = "Minimum Minimum Water Potential (MPa)",
  ylab = "LFM (%) @ Midday Water Potential = 0",
  yaxt = "n"
)
axis(2, at = seq(0, 400, 100), labels = seq(0, 400, 100), las = 1)

# --- 60% LFM curve (x depends on threshold; y is the same lfm_pct scale)
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.62)
}
lines(MWPcrit, lfm_pct, lwd = 1.5, col = "maroon")
text(tail(MWPcrit, 1), tail(lfm_pct, 1), labels = "60% LFM", pos = 1, col = "maroon", cex = 0.9)

# --- 77% LFM curve
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.77)
}
lines(MWPcrit, lfm_pct, lwd = 1.5, col = "goldenrod")
text(tail(MWPcrit, 1), tail(lfm_pct, 1), labels = "77% LFM", pos = 3, col = "goldenrod", cex = 0.9)

# --- Species letters (also scaled to percent on y)
text(
  x = spres$minWP,
  y = (1 / spres$model1.int) * 100,
  labels = spres$Letter,
  col = genus_cols[spres$Genus],
  cex = 1
)

# ----------------------------
# Assign unique letters per species (unchanged)
# ----------------------------
unique_species <- unique(spres$SpCode6)
species_letters <- setNames(letters[seq_along(unique_species)], unique_species)
spres$Letter <- species_letters[spres$SpCode6]

# Lookup (if needed elsewhere)
letter_mapping <- data.frame(
  Letter  = spres$Letter,
  Species = spres$SpCode6
) %>% distinct()



# ----------------------------
# Plot species letters colored by Genus (REPLACEMENT)
# ----------------------------
text(
  x = spres$minWP,
  y = 1 / spres$model1.int * 100,
  labels = spres$Letter,
  col = genus_cols[spres$Genus],
  cex = 1
)

# Optional legend:
# Build the legend text: "a - Abies concolor"
## 2) Legend: outside plot border, inside device
# Build unique mapping (as before)
legend_df <- data.frame(
  Letter  = spres$Letter,
  Species = spres$SpCode6,
  Genus   = spres$Genus
) %>% distinct()

legend_text   <- paste0(legend_df$Letter, " - ", legend_df$Species)
legend_colors <- genus_cols[legend_df$Genus]

# Place legend using user coords just beyond the top-right plot corner
usr <- par("usr")  # c(xmin, xmax, ymin, ymax)
x_off <- diff(usr[1:2]) * 0.02   # 2% of x-range to the right of plot box
y_off <- diff(usr[3:4]) * 0.02   # 01% down from the top

legend(
  x = usr[2] + x_off,            # a touch to the right of the plot border
  y = usr[4] - y_off,            # a touch below the top border
  xjust = 0, yjust = 1,          # anchor legend’s top-left corner
  legend = legend_text,
  text.col = legend_colors,
  pch = 15, col = legend_colors,
  bty = "n", cex = 0.8,
  y.intersp = 0.9
)

## 3) (Optional) restore par when done
# par(op)

# Restore par settings
par(op)

# Close device to write file
dev.off()
 
```

With genus in legend: 

```{r, eval = F}
# ----------------------------
# Plot open: 
# ----------------------------

jpeg(
  filename = here::here("figures", "Fig2_genus.jpg"),
  width    = 7,
  height   = 4.5,
  units    = "in",
  res      = 300
)

op <- par(no.readonly = TRUE)
# Keep margins normal; we'll put both legends *inside* the plot area
par(mar = c(4, 4, 0.5, 0.5), mgp = c(2.2, 0.6, 0), xpd = FALSE)

# ----------------------------
# Colors by Genus
# ----------------------------
okabe_ito <- c(
  "#17154f", "#5b859e", "#6c5d9e", "#9d9cd5", "#732f30",
  "#f6b3b0", "#e48171", "#bf3729", "#e69b00", "#ab84a5",
  "#355828", "#ada43b", "#5b859e", "#1e395f", "#75884b",
  "#df8d71", "#af4f2f", "#d48f90", "#59385c", "#d8b847",
  "#b38711"
)

genus_levels <- sort(unique(spres$Genus))
ng <- length(genus_levels)
genus_colors <- if (ng > length(okabe_ito)) {
  grDevices::colorRampPalette(okabe_ito)(ng)
} else {
  okabe_ito[seq_len(ng)]
}
genus_cols <- setNames(genus_colors, genus_levels)

# ----------------------------
# Base curve at 70% (reference), multiplied by 100
# ----------------------------
MWPcrit <- numeric(length(ilfm.sat.vec))
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.7)
}
lfm_pct <- (1 / ilfm.sat.vec) * 100

plot(
  MWPcrit, lfm_pct,
  xlim = c(-8, 0.1), ylim = c(0, 400),
  type = "n",  # set up axes, no line yet
  xlab = "Minimum Minimum Water Potential (MPa)",
  ylab = "LFM (%) @ Midday Water Potential = 0",
  yaxt = "n"
)
axis(2, at = seq(0, 400, 100), labels = seq(0, 400, 100), las = 1)

# --- 60% LFM curve
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.62)
}
lines(MWPcrit, lfm_pct, lwd = 1.5, col = "maroon")
text(tail(MWPcrit, 1), tail(lfm_pct, 1),
     labels = "60% LFM", pos = 1, col = "maroon", cex = 0.9)

# --- 77% LFM curve
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.77)
}
lines(MWPcrit, lfm_pct, lwd = 1.5, col = "goldenrod")
text(tail(MWPcrit, 1), tail(lfm_pct, 1),
     labels = "77% LFM", pos = 3, col = "goldenrod", cex = 0.9)

# ----------------------------
# Assign unique letters per species
# ----------------------------
unique_species  <- unique(spres$SpCode6)
species_letters <- setNames(letters[seq_along(unique_species)], unique_species)
spres$Letter    <- species_letters[spres$SpCode6]

# ----------------------------
# Plot species letters colored by Genus
# ----------------------------
text(
  x = spres$minWP,
  y = (1 / spres$model1.int) * 100,
  labels = spres$Letter,
  col = genus_cols[spres$Genus],
  cex = 1
)

# ----------------------------
# Build legend data
# ----------------------------
legend_df <- data.frame(
  Letter  = spres$Letter,
  Species = spres$SpCode6,
  Genus   = spres$Genus
) %>% distinct()

letter_text   <- paste0(legend_df$Letter, " - ", legend_df$Species)
letter_colors <- genus_cols[legend_df$Genus]

# ----------------------------
# Place legends INSIDE plot, side-by-side
# ----------------------------
usr   <- par("usr")
x_min <- usr[1]; x_max <- usr[2]
y_min <- usr[3]; y_max <- usr[4]

x_range <- x_max - x_min
y_range <- y_max - y_min

# y position slightly below top
y_top <- y_max - 0.05 * y_range

# letter legend towards upper-right, but not all the way
x_letter <- x_min + 0.55 * x_range
# genus legend further right
x_genus  <- x_min + 0.83 * x_range

# 1) Letter–Species legend
legend(
  x      = x_letter,
  y      = y_top,
  xjust  = 0, yjust = 1,
  legend = letter_text,
  text.col = letter_colors,
  pch    = 15,
  col    = letter_colors,
  bty    = "n",
  cex    = 0.75,
  y.intersp = 0.9,
  title  = "Species (letters)"
)

# 2) Genus legend just to the right
legend(
  x      = x_genus,
  y      = y_top,
  xjust  = 0, yjust = 1,
  legend = genus_levels,
  pch    = 15,
  col    = genus_cols[genus_levels],
  bty    = "n",
  cex    = 0.75,
  y.intersp = 0.9,
  title  = "Genus"
)

par(op)
dev.off()

```


####Label just some: 

```{r}
library(dplyr)
library(here)

# ----------------------------
# Build spres from parameters
# ----------------------------
spres <- concept_params_df %>% 
  filter(group == "grand") %>% 
  mutate(
    model1.int = intercept,
    model1.slp = slope,
    SpCode6    = species, 
    minWP      = minwp
  )

# ----------------------------
# Join Genus info (optional; not required for species-colored points)
# ----------------------------
spres <- spres %>%
  left_join(SpCodes %>% select(SpCode6, Genus), by = "SpCode6")

if (any(is.na(spres$Genus))) {
  warning("Some SpCode6 have no Genus in SpCodes.")
}

# ----------------------------
# Generate conceptual curves
# ----------------------------
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)

# Use a "typical" slope for drawing the conceptual lines
species_slope <- median(spres$model1.slp, na.rm = TRUE)

# Base y scale (percent)
lfm_pct <- (1 / ilfm.sat.vec) * 100

# Helper to make curve for a given LFM threshold
make_MWPcrit <- function(thresh, ilfm_vec, slope) {
  out <- numeric(length(ilfm_vec))
  for (i in seq_along(ilfm_vec)) {
    out[i] <- solveForX(c(ilfm_vec[i], slope), 1 / thresh)
  }
  out
}

MWPcrit_60 <- make_MWPcrit(0.62, ilfm.sat.vec, species_slope)
MWPcrit_77 <- make_MWPcrit(0.77, ilfm.sat.vec, species_slope)

# ----------------------------
# Colors by Species (you already have this object)
# ----------------------------
# IMPORTANT: color_species is a ggplot2 scale.
# For base R, we need a named vector of colors that matches species levels.
species_levels <- sort(unique(spres$SpCode6))
species_cols <- setNames(
  rep(color_species$palette(length(species_levels)), length.out = length(species_levels)),
  species_levels
)

# ----------------------------
# Plot open
# ----------------------------
jpeg(
  filename = here::here("figures", "Fig2_species.jpg"),
  width    = 7,   
  height   = 4.5,     
  units    = "in",
  res      = 300
)

op <- par(no.readonly = TRUE)
par(mar = c(4, 4, 0.5, 4), mgp = c(2.2, 0.6, 0), xpd = TRUE)

# ----------------------------
# Set up plot (axes only)
# ----------------------------
plot(
  x = MWPcrit_60, y = lfm_pct,
  xlim = c(-8, 0.1), ylim = c(0, 400),
  type = "n",
  xlab = "Minimum Midday Water Potential (MPa)",
  ylab = "LFM (%) @ Midday Water Potential = 0",
  yaxt = "n"
)
axis(2, at = seq(0, 400, 100), labels = seq(0, 400, 100), las = 1)

# ----------------------------
# Draw conceptual curves
# ----------------------------
lines(MWPcrit_60, lfm_pct, lwd = 1.5, col = "maroon")
text(tail(MWPcrit_60, 1), tail(lfm_pct, 1), labels = "60% LFM",
     pos = 1, col = "maroon", cex = 0.9)

lines(MWPcrit_77, lfm_pct, lwd = 1.5, col = "goldenrod")
text(tail(MWPcrit_77, 1), tail(lfm_pct, 1), labels = "77% LFM",
     pos = 3, col = "goldenrod", cex = 0.9)

# ----------------------------
# Plot points (COLORED BY SPECIES, not letters)
# ----------------------------
points(
  x = spres$minWP,
  y = (1 / spres$model1.int) * 100,
  pch = 16,
  cex = 1.1,
  col = species_cols[spres$SpCode6]
)

# ----------------------------
# Add small labels for selected species
# ----------------------------
# ----------------------------
# Add small labels for selected species
#   - ensure 1 label per species
#   - special placement for PIJE / PINJEF (above point, centered)
# ----------------------------
label_spp <- c("PSEMEN", "UMBCAL", "ABCO", "PIJE", "PINJEF", "ABICON", "MALLAU", "CEACOR", "QUEKEL", "ARBMEN", "CALDEC")
special  <- c("PIJE", "PINJEF", "CALDEC", "QUEKEL", "CEACOR")

spres_lab <- spres %>%
  filter(SpCode6 %in% label_spp) %>%
  mutate(
    x = minWP,
    y = (1 / model1.int) * 100
  ) %>%
  group_by(SpCode6) %>%
  slice(1) %>%              # <-- prevents duplicate labels if species appears multiple times
  ungroup()

# All labels EXCEPT the special one(s): to the right
spres_lab_other <- spres_lab %>% filter(!SpCode6 %in% special)

text(
  x = spres_lab_other$x,
  y = spres_lab_other$y,
  labels = spres_lab_other$SpCode6,
  pos = 4,
  offset = 0.3,
  cex = 0.75,
  col = species_cols[spres_lab_other$SpCode6]
)

# Special label (PIJE / PINJEF): above point, centered
spres_lab_special <- spres_lab %>% filter(SpCode6 %in% special)

if (nrow(spres_lab_special) > 0) {
  text(
    x = spres_lab_special$x,
    y = spres_lab_special$y,
    labels = spres_lab_special$SpCode6,
    pos = 3,
    offset = 0.45,
    adj = c(0.5, 0),   # center horizontally
    cex = 0.75,
    col = species_cols[spres_lab_special$SpCode6]
  )
}
# ----------------------------
# Optional: legend for species colors (can be big if many species)
# ----------------------------
# ----------------------------
# Move species legend ~1 inch to the RIGHT
# ----------------------------
usr <- par("usr")   # c(xmin, xmax, ymin, ymax)
pin <- par("pin")   # plot dimensions in inches

# Convert 1 inch to x-axis units
x_per_inch <- diff(usr[1:2]) / pin[1]
x_shift    <- .025 * x_per_inch   # 1 inch to the right

legend(
  x = usr[2] + x_shift,        # push legend right by ~1 inch
  y = usr[4],                  # align with top of plot
  xjust = 0, yjust = 1,
  legend = species_levels,
  pch = 16,
  col = species_cols[species_levels],
  bty = "n",
  cex = 0.7,
  title = "Species"
)

par(op)
dev.off()
```
#Dynamic groups: 
```{r}

library(dplyr)
library(here)

# ============================================================
# CHOOSE WHAT TO COLOR BY (one place to change)
#   examples: "SpCode6", "Genus", "Family", "functional_type", etc.
# ============================================================
color_by <- "functional_type"

# Optional: where to pull classification columns from (set to NULL if already in spres)
# Must include SpCode6 + any columns you want to color by (Genus/Family/functional_type/etc.)
tax_table <- SpCodes

# ----------------------------
# Build spres from parameters
# ----------------------------
spres <- concept_params_df %>% 
  filter(group == "grand") %>% 
  mutate(
    model1.int = intercept,
    model1.slp = slope,
    SpCode6    = species, 
    minWP      = minwp
  )

# ----------------------------
# Join taxonomy / grouping columns (if needed)
# ----------------------------
if (!is.null(tax_table)) {
  spres <- spres %>%
    left_join(tax_table, by = "SpCode6")
}

# sanity check: does color_by exist?
if (!color_by %in% names(spres)) {
  stop(paste0("`color_by` = '", color_by, "' is not a column in `spres` after joins."))
}

# ----------------------------
# Generate conceptual curves
# ----------------------------
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)
species_slope <- median(spres$model1.slp, na.rm = TRUE)
lfm_pct <- (1 / ilfm.sat.vec) * 100

make_MWPcrit <- function(thresh, ilfm_vec, slope) {
  out <- numeric(length(ilfm_vec))
  for (i in seq_along(ilfm_vec)) {
    out[i] <- solveForX(c(ilfm_vec[i], slope), 1 / thresh)
  }
  out
}

MWPcrit_60 <- make_MWPcrit(0.62, ilfm.sat.vec, species_slope)
MWPcrit_77 <- make_MWPcrit(0.77, ilfm.sat.vec, species_slope)

# ----------------------------
# Build colors for chosen grouping variable
# ----------------------------
# Grab the grouping values (as character) so they index cleanly
spres <- spres %>%
  mutate(color_group = as.character(.data[[color_by]]))

group_levels <- sort(unique(spres$color_group))
group_levels <- group_levels[!is.na(group_levels)]  # drop NA from legend keys

# Base palette (Okabe–Ito-ish, expanded if needed)
okabe_ito <- c(
  "#17154f", "#5b859e", "#6c5d9e", "#9d9cd5", "#732f30",
  "#f6b3b0", "#e48171", "#bf3729", "#e69b00", "#ab84a5",
  "#355828", "#ada43b", "#1e395f", "#75884b", "#df8d71",
  "#af4f2f", "#d48f90", "#59385c", "#d8b847", "#b38711", "pink"
)

group_colors <- if (length(group_levels) > length(okabe_ito)) {
  grDevices::colorRampPalette(okabe_ito)(length(group_levels))
} else {
  okabe_ito[seq_len(length(group_levels))]
}
group_cols <- setNames(group_colors, group_levels)

# ----------------------------
# Plot open
# ----------------------------
jpeg(
  filename = here::here("figures", paste0("Fig2_colored_by_", color_by, ".jpg")),
  width    = 7,
  height   = 4.5,
  units    = "in",
  res      = 300
)

op <- par(no.readonly = TRUE)
par(mar = c(4, 4, 0.5, 4), mgp = c(2.2, 0.6, 0), xpd = TRUE)

# ----------------------------
# Set up plot (axes only)
# ----------------------------
plot(
  x = MWPcrit_60, y = lfm_pct,
  xlim = c(-8, 0.1), ylim = c(0, 400),
  type = "n",
  xlab = "Minimum Midday Water Potential (MPa)",
  ylab = "LFM (%) @ Midday Water Potential = 0",
  yaxt = "n"
)
axis(2, at = seq(0, 400, 100), labels = seq(0, 400, 100), las = 1)

# ----------------------------
# Draw conceptual curves
# ----------------------------
lines(MWPcrit_60, lfm_pct, lwd = 1.5, col = "maroon")
text(tail(MWPcrit_60, 1), tail(lfm_pct, 1), labels = "60% LFM",
     pos = 1, col = "maroon", cex = 0.9)

lines(MWPcrit_77, lfm_pct, lwd = 1.5, col = "goldenrod")
text(tail(MWPcrit_77, 1), tail(lfm_pct, 1), labels = "77% LFM",
     pos = 3, col = "goldenrod", cex = 0.9)

# ----------------------------
# Plot points (colored by chosen grouping column)
# ----------------------------
points(
  x = spres$minWP,
  y = (1 / spres$model1.int) * 100,
  pch = 16,
  cex = 1.1,
  col = group_cols[spres$color_group]
)

# ----------------------------
# Add small labels for selected species (labels always by SpCode6)
#   - ensure 1 label per species
#   - special placement for PIJE / PINJEF (above point, centered)
#   - label color matches the chosen color_by mapping
# ----------------------------
label_spp <- c("PSEMEN", "UMBCAL", "ABCO", "PIJE", "PINJEF", "ABICON", "CALDEC")
special   <- c("PIJE", "PINJEF", "CALDEC")

spres_lab <- spres %>%
  filter(SpCode6 %in% label_spp) %>%
  mutate(
    x = minWP,
    y = (1 / model1.int) * 100
  ) %>%
  group_by(SpCode6) %>%
  slice(1) %>%
  ungroup()

spres_lab_other <- spres_lab %>% filter(!SpCode6 %in% special)

text(
  x = spres_lab_other$x,
  y = spres_lab_other$y,
  labels = spres_lab_other$SpCode6,
  pos = 4,
  offset = 0.3,
  cex = 0.75,
  col = group_cols[spres_lab_other$color_group]
)

spres_lab_special <- spres_lab %>% filter(SpCode6 %in% special)

if (nrow(spres_lab_special) > 0) {
  text(
    x = spres_lab_special$x,
    y = spres_lab_special$y,
    labels = spres_lab_special$SpCode6,
    pos = 3,
    offset = 0.45,
    adj = c(0.5, 0),
    cex = 0.75,
    col = group_cols[spres_lab_special$color_group]
  )
}

# ----------------------------
# Legend (for chosen color_by groups)
#   moved slightly right
# ----------------------------
usr <- par("usr")
pin <- par("pin")
x_per_inch <- diff(usr[1:2]) / pin[1]
x_shift    <- 0.025 * x_per_inch

legend(
  x = usr[2] + x_shift,
  y = usr[4],
  xjust = 0, yjust = 1,
  legend = group_levels,
  pch = 16,
  col = group_cols[group_levels],
  bty = "n",
  cex = 0.7,
  title = color_by
)

par(op)
dev.off()

```


####Figure 4, (family)
```{r}
#### Figure 4 (NEW isocline colored by FAMILY) ####
library(dplyr)
library(here)

# ----------------------------
# Build spres from parameters
# ----------------------------
spres <- concept_params_df %>% 
  filter(group == "grand") %>% 
  mutate(
    model1.int = intercept,
    model1.slp = slope,      # slope column for convenience
    SpCode6    = species, 
    minWP      = minwp
  )

# ----------------------------
# Assign unique letters per species (do this early)
# ----------------------------
unique_species   <- unique(spres$SpCode6)
species_letters  <- setNames(letters[seq_along(unique_species)], unique_species)
spres$Letter     <- species_letters[spres$SpCode6]

# ----------------------------
# Join FAMILY info (from sp_info)
#   - sp_info must contain: SpCode6, family  (lowercase)
# ----------------------------
spres <- spres %>%
  left_join(sp_info %>% select(sp_code, family) %>% 
              mutate(SpCode6 = sp_code), by = "SpCode6")

# Optional check for any species missing a Family
if (any(is.na(spres$family))) {
  warning("Some SpCode6 have no family in sp_info.")
}

# ----------------------------
# Generate conceptual curves
# ----------------------------
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)

# (Optional, not used directly in the plot below)
MWPcrit_list <- list()
for (sp in unique(spres$species)) {
  species_slope <- spres %>% filter(species == sp) %>% pull(model1.slp)
  MWPcrit <- numeric(length(ilfm.sat.vec))
  for (i in seq_along(ilfm.sat.vec)) {
    MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.7)
  }
  MWPcrit_list[[sp]] <- MWPcrit
}

# Use a "typical" slope for drawing the conceptual lines
species_slope <- median(spres$model1.slp, na.rm = TRUE)

# ----------------------------
# Open device + layout params
# ----------------------------
jpeg(
  filename = here("figures", "Fig2_family.jpg"),
  width    = 7,   
  height   = 4.5,     
  units    = "in",
  res      = 300
)

op <- par(no.readonly = TRUE)
par(mar = c(4, 4, 0.5, 6), mgp = c(2.2, 0.6, 0), xpd = TRUE)

# ----------------------------
# Base curve at 70% (reference), plotted as percent on y
# ----------------------------
MWPcrit <- numeric(length(ilfm.sat.vec))
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.7)
}
lfm_pct <- (1 / ilfm.sat.vec) * 100  # scale to percent for plotting

plot(
  MWPcrit, lfm_pct,
  xlim = c(-8, 0.1), ylim = c(0, 400),
  type = "l", lwd = 0, col = "blue",
  xlab = "Minimum Minimum Water Potential (MPa)",
  ylab = "LFM (%) @ Midday Water Potential = 0",
  yaxt = "n"
)
axis(2, at = seq(0, 400, 100), labels = seq(0, 400, 100), las = 1)

# ----------------------------
# 60% LFM curve (x depends on threshold; y uses lfm_pct scale)
# ----------------------------
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.62)
}
lines(MWPcrit, lfm_pct, lwd = 1.5, col = "maroon")
text(tail(MWPcrit, 1), tail(lfm_pct, 1), labels = "60% LFM", pos = 1, col = "maroon", cex = 0.9)

# ----------------------------
# 77% LFM curve
# ----------------------------
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.77)
}
lines(MWPcrit, lfm_pct, lwd = 1.5, col = "goldenrod")
text(tail(MWPcrit, 1), tail(lfm_pct, 1), labels = "77% LFM", pos = 3, col = "goldenrod", cex = 0.9)

# ----------------------------
# Colors by FAMILY
# ----------------------------
# (Palette can be any set; this starts with ~20 distinct colors and expands if needed)
base_palette <- c(
  "#17154f", "#5b859e", "#6c5d9e", "#732f30", "#f6b3b0", "#e48171",
"#e69b00", "#ab84a5", "#355828", "#ada43b", "#1e395f", "#75884b",
  "#df8d71", "#af4f2f", "#d48f90", "#59385c", "#d8b847", "#b38711"
)
family_levels <- sort(unique(spres$family))
nf <- length(family_levels)
family_colors <- if (nf > length(base_palette)) {
  grDevices::colorRampPalette(base_palette)(nf)
} else {
  base_palette[seq_len(nf)]
}
family_cols <- setNames(family_colors, family_levels)

# ----------------------------
# Species letters (y scaled to %) colored by FAMILY
# ----------------------------
text(
  x = spres$minWP,
  y = (1 / spres$model1.int) * 100,
  labels = spres$Letter,
  col = family_cols[spres$family],
  cex = 1
)

# ----------------------------
# Legend: letter - species code, colored by FAMILY
#   (outside plot border, inside device)
# ----------------------------
legend_df <- spres %>%
  select(Letter, Species = SpCode6, family) %>%
  distinct()

legend_text   <- paste0(legend_df$Letter, " - ", legend_df$Species)
legend_colors <- family_cols[legend_df$family]

usr  <- par("usr")                # c(xmin, xmax, ymin, ymax)
xoff <- diff(usr[1:2]) * 0.02
yoff <- diff(usr[3:4]) * 0.02

legend(
  x = usr[2] + xoff,             # a touch to the right of the plot border
  y = usr[4] - yoff,             # a touch below the top border
  xjust = 0, yjust = 1,
  legend = legend_text,
  text.col = legend_colors,
  pch = 15, col = legend_colors,
  bty = "n", cex = 0.8,
  y.intersp = 0.7
)

# ----------------------------
# Close device and restore par
# ----------------------------
par(op)
dev.off()

```

####Figure 4, (growth form)
```{r}
#### Figure 4 (NEW isocline colored by FAMILY) ####
library(dplyr)
library(here)

# ----------------------------
# Build spres from parameters
# ----------------------------
spres <- concept_params_df %>% 
  filter(group == "grand") %>% 
  mutate(
    model1.int = intercept,
    model1.slp = slope,      # slope column for convenience
    SpCode6    = species, 
    minWP      = minwp
  )

# ----------------------------
# Assign unique letters per species (do this early)
# ----------------------------
unique_species   <- unique(spres$SpCode6)
species_letters  <- setNames(letters[seq_along(unique_species)], unique_species)
spres$Letter     <- species_letters[spres$SpCode6]

# ----------------------------
# Join FAMILY info (from sp_info)
#   - sp_info must contain: SpCode6, family  (lowercase)
# ----------------------------
spres <- spres %>%
  left_join(sp_info %>% select(sp_code, growth_form) %>% 
              mutate(SpCode6 = sp_code), by = "SpCode6")

# Optional check for any species missing a Family
if (any(is.na(spres$family))) {
  warning("Some SpCode6 have no family in sp_info.")
}

# ----------------------------
# Generate conceptual curves
# ----------------------------
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)

# (Optional, not used directly in the plot below)
MWPcrit_list <- list()
for (sp in unique(spres$species)) {
  species_slope <- spres %>% filter(species == sp) %>% pull(model1.slp)
  MWPcrit <- numeric(length(ilfm.sat.vec))
  for (i in seq_along(ilfm.sat.vec)) {
    MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.7)
  }
  MWPcrit_list[[sp]] <- MWPcrit
}

# Use a "typical" slope for drawing the conceptual lines
species_slope <- median(spres$model1.slp, na.rm = TRUE)

# ----------------------------
# Open device + layout params
# ----------------------------
jpeg(
  filename = here("figures", "Fig2_form.jpg"),
  width    = 7,   
  height   = 4.5,     
  units    = "in",
  res      = 300
)

op <- par(no.readonly = TRUE)
par(mar = c(4, 4, 0.5, 6), mgp = c(2.2, 0.6, 0), xpd = TRUE)

# ----------------------------
# Base curve at 70% (reference), plotted as percent on y
# ----------------------------
MWPcrit <- numeric(length(ilfm.sat.vec))
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.7)
}
lfm_pct <- (1 / ilfm.sat.vec) * 100  # scale to percent for plotting

plot(
  MWPcrit, lfm_pct,
  xlim = c(-8, 0.1), ylim = c(0, 400),
  type = "l", lwd = 0, col = "blue",
  xlab = "Minimum Minimum Water Potential (MPa)",
  ylab = "LFM (%) @ Midday Water Potential = 0",
  yaxt = "n"
)
axis(2, at = seq(0, 400, 100), labels = seq(0, 400, 100), las = 1)

# ----------------------------
# 60% LFM curve (x depends on threshold; y uses lfm_pct scale)
# ----------------------------
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.62)
}
lines(MWPcrit, lfm_pct, lwd = 1.5, col = "maroon")
text(tail(MWPcrit, 1), tail(lfm_pct, 1), labels = "60% LFM", pos = 1, col = "maroon", cex = 0.9)

# ----------------------------
# 77% LFM curve
# ----------------------------
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.77)
}
lines(MWPcrit, lfm_pct, lwd = 1.5, col = "goldenrod")
text(tail(MWPcrit, 1), tail(lfm_pct, 1), labels = "77% LFM", pos = 3, col = "goldenrod", cex = 0.9)

# ----------------------------
# Colors by FORM
# ----------------------------
# (Palette can be any set; this starts with ~20 distinct colors and expands if needed)
base_palette <- c(
  "#17154f",  "#e48171",
"#e69b00", "#ab84a5", "#355828", "#ada43b", "#1e395f", "#75884b",
  "#df8d71", "#af4f2f", "#d48f90", "#59385c", "#d8b847", "#b38711"
)
family_levels <- sort(unique(spres$growth_form))
nf <- length(family_levels)
family_colors <- if (nf > length(base_palette)) {
  grDevices::colorRampPalette(base_palette)(nf)
} else {
  base_palette[seq_len(nf)]
}
family_cols <- setNames(family_colors, family_levels)

# ----------------------------
# Species letters (y scaled to %) colored by FAMILY
# ----------------------------
text(
  x = spres$minWP,
  y = (1 / spres$model1.int) * 100,
  labels = spres$Letter,
  col = family_cols[spres$growth_form],
  cex = 1
)

# ----------------------------
# Legend: letter - species code, colored by FAMILY
#   (outside plot border, inside device)
# ----------------------------
legend_df <- spres %>%
  select(Letter, Species = SpCode6, growth_form) %>%
  distinct()

legend_text   <- paste0(legend_df$Letter, " - ", legend_df$Species)
legend_colors <- family_cols[legend_df$growth_form]

usr  <- par("usr")                # c(xmin, xmax, ymin, ymax)
xoff <- diff(usr[1:2]) * 0.02
yoff <- diff(usr[3:4]) * 0.02

legend(
  x = usr[2] + xoff,             # a touch to the right of the plot border
  y = usr[4] - yoff,             # a touch below the top border
  xjust = 0, yjust = 1,
  legend = legend_text,
  text.col = legend_colors,
  pch = 15, col = legend_colors,
  bty = "n", cex = 0.8,
  y.intersp = 0.7
)

# ----------------------------
# Close device and restore par
# ----------------------------
par(op)
dev.off()

```

####Figure 4, (leaf habit)
```{r}
#### Figure 4 (NEW isocline colored by FAMILY) ####
library(dplyr)
library(here)

# ----------------------------
# Build spres from parameters
# ----------------------------
spres <- concept_params_df %>% 
  filter(group == "grand") %>% 
  mutate(
    model1.int = intercept,
    model1.slp = slope,      # slope column for convenience
    SpCode6    = species, 
    minWP      = minwp
  )

# ----------------------------
# Assign unique letters per species (do this early)
# ----------------------------
unique_species   <- unique(spres$SpCode6)
species_letters  <- setNames(letters[seq_along(unique_species)], unique_species)
spres$Letter     <- species_letters[spres$SpCode6]

# ----------------------------
# Join FAMILY info (from sp_info)
#   - sp_info must contain: SpCode6, family  (lowercase)
# ----------------------------
spres <- spres %>%
  left_join(sp_info %>% select(sp_code, dec_ever) %>% 
              mutate(SpCode6 = sp_code), by = "SpCode6")

# Optional check for any species missing a Family
if (any(is.na(spres$dec_ever))) {
  warning("Some SpCode6 have no family in sp_info.")
}

# ----------------------------
# Generate conceptual curves
# ----------------------------
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)

# (Optional, not used directly in the plot below)
MWPcrit_list <- list()
for (sp in unique(spres$species)) {
  species_slope <- spres %>% filter(species == sp) %>% pull(model1.slp)
  MWPcrit <- numeric(length(ilfm.sat.vec))
  for (i in seq_along(ilfm.sat.vec)) {
    MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.7)
  }
  MWPcrit_list[[sp]] <- MWPcrit
}

# Use a "typical" slope for drawing the conceptual lines
species_slope <- median(spres$model1.slp, na.rm = TRUE)

# ----------------------------
# Open device + layout params
# ----------------------------
jpeg(
  filename = here("figures", "Fig2_form.jpg"),
  width    = 7,   
  height   = 4.5,     
  units    = "in",
  res      = 300
)

op <- par(no.readonly = TRUE)
par(mar = c(4, 4, 0.5, 6), mgp = c(2.2, 0.6, 0), xpd = TRUE)

# ----------------------------
# Base curve at 70% (reference), plotted as percent on y
# ----------------------------
MWPcrit <- numeric(length(ilfm.sat.vec))
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.7)
}
lfm_pct <- (1 / ilfm.sat.vec) * 100  # scale to percent for plotting

plot(
  MWPcrit, lfm_pct,
  xlim = c(-8, 0.1), ylim = c(0, 400),
  type = "l", lwd = 0, col = "blue",
  xlab = "Minimum Minimum Water Potential (MPa)",
  ylab = "LFM (%) @ Midday Water Potential = 0",
  yaxt = "n"
)
axis(2, at = seq(0, 400, 100), labels = seq(0, 400, 100), las = 1)

# ----------------------------
# 60% LFM curve (x depends on threshold; y uses lfm_pct scale)
# ----------------------------
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.62)
}
lines(MWPcrit, lfm_pct, lwd = 1.5, col = "maroon")
text(tail(MWPcrit, 1), tail(lfm_pct, 1), labels = "60% LFM", pos = 1, col = "maroon", cex = 0.9)

# ----------------------------
# 77% LFM curve
# ----------------------------
for (i in seq_along(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1/0.77)
}
lines(MWPcrit, lfm_pct, lwd = 1.5, col = "goldenrod")
text(tail(MWPcrit, 1), tail(lfm_pct, 1), labels = "77% LFM", pos = 3, col = "goldenrod", cex = 0.9)

# ----------------------------
# Colors by FORM
# ----------------------------
# (Palette can be any set; this starts with ~20 distinct colors and expands if needed)
base_palette <- c(
  "#17154f",  "#e48171","#e69b00", "#ab84a5", "#355828", "#ada43b", "#1e395f", "#75884b",
  "#df8d71", "#af4f2f", "#d48f90", "#59385c", "#d8b847", "#b38711", "#59385c", "#d8b847", "#b38711"
)
family_levels <- sort(unique(spres$dec_ever))
nf <- length(family_levels)
family_colors <- if (nf > length(base_palette)) {
  grDevices::colorRampPalette(base_palette)(nf)
} else {
  base_palette[seq_len(nf)]
}
family_cols <- setNames(family_colors, family_levels)

# ----------------------------
# Species letters (y scaled to %) colored by leaf habit
# ----------------------------
text(
  x = spres$minWP,
  y = (1 / spres$model1.int) * 100,
  labels = spres$Letter,
  col = family_cols[spres$dec_ever],
  cex = 1
)

# ----------------------------
# Legend: letter - species code, colored by FAMILY
#   (outside plot border, inside device)
# ----------------------------
legend_df <- spres %>%
  select(Letter, Species = SpCode6,  dec_ever) %>%
  distinct()

legend_text   <- paste0(legend_df$Letter, " - ", legend_df$Species)
legend_colors <- family_cols[legend_df$dec_ever]

usr  <- par("usr")                # c(xmin, xmax, ymin, ymax)
xoff <- diff(usr[1:2]) * 0.02
yoff <- diff(usr[3:4]) * 0.02

legend(
  x = usr[2] + xoff,             # a touch to the right of the plot border
  y = usr[4] - yoff,             # a touch below the top border
  xjust = 0, yjust = 1,
  legend = legend_text,
  text.col = legend_colors,
  pch = 15, col = legend_colors,
  bty = "n", cex = 0.8,
  y.intersp = 0.7
)

# ----------------------------
# Close device and restore par
# ----------------------------
par(op)
dev.off()

```



####Figure S2.

Separate slopes for isoclines per species (probably not what we want to do though, v messy looking):

```{r, eval = F}
# Source custom functions if needed
source(here('scripts', 'lfm_functions.R'))

# Read species results
#spres_old <- read.csv(here('results', 'species-results.csv'))

# Ensure 'spres' has all the necessary columns from the previous steps
spres <- concept_params_df %>% 
  filter(slope_type == "species") %>% 
  mutate(model1.int = intercept,
         model1.slp = slope,  # Ensure slope is named 'model1.slp'
         #model2.int = int_sppstudy, 
        # model2_slp = slope_sppstudy, 
         SpCode6 = species, 
         minWP = minwp)

# Inspect the modified dataframe
head(spres)

# Generate a sequence of inverse LFM saturation values
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)

# Initialize an empty list to store critical MWP values for each species
MWPcrit_list <- list()

# Loop through each unique species and calculate the critical MWP using species-specific slopes
for (sp in unique(spres$species)) {
  
  # Get the species-specific slope from 'spres'
  species_slope <- spres %>% 
    filter(species == sp) %>% 
    pull(model1.slp)
  
  # Initialize a vector to hold critical MWP values for the current species
  MWPcrit <- c()
  
  # Calculate critical MWP for the current species
  for (i in 1:length(ilfm.sat.vec)) {
    MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.7)  # Use species-specific slope
  }
  
  # Store the results for each species in the list
  MWPcrit_list[[sp]] <- MWPcrit
}

# Example: Extract MWPcrit for a specific species (e.g., "species1")
# MWPcrit_list[["species1"]]

# Convert inverse LFM saturation values back to LFM
lfm.sat.vec <- 1 / ilfm.sat.vec

# Plot the conceptual model for each species using its own slope
plot(MWPcrit_list[[1]], lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4),
     type = 'l', lwd = 2, xlab = 'Minimum MWP (MPa)', ylab = 'LFM @ MWP = 0')

# Add lines for each species
for (sp in unique(spres$species)) {
  lines(MWPcrit_list[[sp]], lfm.sat.vec, lwd = 1)  # Add lines for each species
}

# Add species data points to the conceptual model plot
text(I(1 / model1.int) ~ minWP, data = spres,
     labels = spres$species, col = 'blue')  # Add species codes as labels
```

```{r, isocline_fig, eval = F}
# Source custom functions if needed
source(here('scripts', 'lfm_functions.R'))

# Read species results
#spres_old <- read.csv(here('results', 'species-results.csv'))

# Ensure 'spres' has all the necessary columns from the previous steps
spres <- traits_df %>% 
  filter(slope_type == "grand") %>% 
  mutate(model1.int = intercept,
         model1.slp = slope,  # Ensure slope is named 'model1.slp'
         #model2.int = int_sppstudy, 
        # model2_slp = slope_sppstudy, 
         SpCode6 = species, 
         minWP = minwp)

# Inspect the modified dataframe
head(spres)

# Generate a sequence of inverse LFM saturation values
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 31)

# Initialize an empty list to store critical MWP values for each species
MWPcrit_list <- list()

# Loop through each unique species and calculate the critical MWP using species-specific slopes
for (sp in unique(spres$species)) {
  
  # Get the species-specific slope from 'spres'
  species_slope <- spres %>% 
    filter(species == sp) %>% 
    pull(model1.slp)
  
  # Initialize a vector to hold critical MWP values for the current species
  MWPcrit <- c()
  
  # Calculate critical MWP for the current species
  for (i in 1:length(ilfm.sat.vec)) {
    MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.7)  # Use species-specific slope
  }
  
  # Store the results for each species in the list
  MWPcrit_list[[sp]] <- MWPcrit
}

# Example: Extract MWPcrit for a specific species (e.g., "species1")
# MWPcrit_list[["species1"]]

# Convert inverse LFM saturation values back to LFM
lfm.sat.vec <- 1 / ilfm.sat.vec

# Step 7: Plot the conceptual model curve
# This plot visualizes the relationship between minimum MWP and LFM based on the estimated slope and intercept
plot(MWPcrit, lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4),  # Set plot limits for axes
     type = 'l', lwd = .1, col = "blue",                                # Line plot with a thick line width
     xlab = 'Minimum MWP (MPa)',                            # X-axis label (MWP in MPa)
     ylab = 'LFM @ MWP = 0')                                # Y-axis label (LFM when MWP = 0)



# Step 8: Repeat the calculations for different LFM thresholds
# Here, different thresholds are used (e.g., 0.5, 1.0) to simulate how the relationship changes with LFM.


for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.62)  #60% LFM
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4), lwd = 1, col = "maroon")  # Add a line to the plot for this threshold



for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], species_slope), 1 / 0.77)    # New threshold of 1/.77 (e.g., 77% LFM)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4), lwd = 1, col = "goldenrod")  # Add a line for this threshold

# Step 9: Add species data points to the conceptual model plot
# The points represent observed data for different species and their corresponding MWP and LFM.
# Here, you can filter data by study or other criteria and plot them.
# Replace 'letters' with actual labels or data as needed
# You might filter by 'Coastal' or other specific groups depending on your dataset
# points(I(1 / model1.int) ~ minWP, data = spres[which(spres$study == 'Coastal'), ], pch = 19)

# # Add labels for species points to the plot (use species codes or other identifiers)
# text(I(1 / model1.int) ~ minWP, data = spres,   # Text labels instead of points for clarity
#      labels = letters)                          # Replace 'letters' with actual species labels or codes

#Add points
#points(I(1 / model1.int) ~ minWP, data = spres, pch = 19)

#-----------
# Plot species-specific data points
# We are using the 'minWP' (Minimum MWP) for each species and inverting the model intercepts (1 / model1.int) for plotting.
# Replace the 'letters' argument with the species codes from the 'SpCode6' column in 'spres' dataframe.


text(I(1 / model1.int) ~ minWP,  # Inverse of intercept plotted against minimum MWP
     data = spres,               # Data from the spres dataframe
     labels = spres$SpCode6,     # Use species codes from the SpCode6 column for labeling
     pos = 4, 
     size = .24)

#-----------
# Create a mapping of letters to species codes
letter_mapping <- data.frame(
  letter = letters[1:nrow(spres)],  # Use the first 'n' letters based on the number of rows in 'spres'
  species_code = spres$SpCode6     # Corresponding species codes from the 'SpCode6' column
)
```

#Q3: trait correlations

Question: How strongly are the species parameters associated with critical plant traits related to drought tolerance and access to water: Leaf Dry Matter Content (LDMC), water potential at 50% loss of conductivity (Ψ50), osmotic potential at turgor loss point (πTLP), and rooting depth?.

Set up plotting and data: 
```{r, warning = F}
#read in trait df.
#Data is mean from TRY, 
traits_df <- read_csv(here("data", "traits_rd_20250327.csv")) %>% 
  mutate(swc_g_calc = 1 - ldmc, #If ldmc is g(SW)/g(DW), then 1 - g(SW)/g(DW) = water component. 
         sla_calc = 1/lma
         ) 
```


```{r, warning = F}
#Attach trait data to model data: 
q3_df1 <- merge(traits_df, concept_params_df, #by = c("species", "sp_code", "growth_form"), 
                all = T) %>% 
 # select(-study) %>% 
  filter(group == "species") %>% 
 # filter(group == "grand") %>% 
  mutate(int_spp = intercept,
         intercept_lfm = 1/intercept,
         slope_spp = slope,
         min_lfm = minlfm,
         max_lfm = maxlfm, 
         min_mwp = minwp, 
         max_mwp = maxwp
         ) %>% 
  select(-date, -mwp, -lfm, -ilfm, -x1, -sp_site, -tissue_age) %>% 
  distinct()
```


How closely are observed min mpas matched to published means?

```{r, warning = F}
q3_df1 %>% 
  ggplot(aes(y = min_mwp, 
             x = psimin_pd)) +
  geom_point() +
  labs(y = "Observed minimum PD", 
       x = "Minimum PD from TRY") +
  geom_abline()
```


```{r, warning = F}
pds_q3_df_raw <- read_csv(here('data', 'all-data-combined-predawns.csv')) %>% 
  clean_names() 

pds_q3_df_raw %>% 
  filter(time %in% c("pd")) %>% 
  ggplot(aes(y = wp, x = lfm, color = species, shape = study)) +
  geom_point()
```


```{r, warning = F}
pds_q3_df <- pds_q3_df_raw %>% 
  group_by(species) %>% 
  filter(time %in% "pd") %>% 
  mutate(min_pd = min(wp, na.rm = T),
         max_pd = max(wp, na.rm = T)) %>% 
  select(-wp, -date, -lfm, -x1) %>% 
  distinct()
#add in predawns:
q3_df <- merge(q3_df1, pds_q3_df, by = c("species", "study"), all = T) %>% 
  select(-study, -study_nice, -sp_site, -tissue_age, -time, -mwp_z) %>% 
  group_by(species) %>% 
  fill(c("min_pd", "max_pd"), .direction = "downup") %>% 
  distinct()
```


```{r, warning = F}
#Function to view each relationship: 
library(ggplot2)
library(ggpmisc) # For stat_poly_eq
library(dplyr)
library(plotly)

# Define function to create plots for multiple y-variables
# Define function to create interactive plots
plot_all_relationships <- function(data, x_var, y_vars) {
  plots <- lapply(y_vars, function(y_var) {
    # Fit linear model
    model <- lm(reformulate(x_var, y_var), data = data)
    eqn <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "<br>R² = ", round(summary(model)$r.squared, 3), 
      "<br>p = ", signif(summary(model)$coefficients[2, 4], 3)
    )
    
    # Create ggplot
    p <- ggplot(data, aes_string(x = x_var, y = y_var)) +
      geom_point(aes(color = species, text = species)) +
      geom_smooth(method = "lm", se = FALSE) +
      labs(x = x_var, y = y_var, title = y_var) +
      theme_minimal()
    
    # # Convert to Plotly and add annotation
    # ggplotly(p, tooltip = "text") %>%
    #   layout(annotations = list(
    #     x = 0.05, y = 0.95, xref = "paper", yref = "paper",
    #     text = eqn, showarrow = FALSE, align = "left"
    #   ))
  })
  
  return(plots)
}

# Define y-variables
y_variables <- c("slope", "intercept", "intercept_lfm", "min_lfm", "min_mwp", "maxlfm", "max_lfm", "min_mwp", "max_mwp")

#remove outlider Salvias: 
q3_df_outs <- q3_df %>% 
  filter(!(species %in% c("SALMEL", "SALLEU")))
```

Is TLP related to any model params?
```{r, warning = F}
# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "psi_tlp", y_variables)

# Display the plots
for (plot in plots) print(plot)

lm(max_lfm ~ psi_tlp, data = q3_df) %>% summary
lm(max_lfm ~ psi_tlp, data = q3_df_outs) %>% summary
```




```{r, warning = F}
plots <- plot_all_relationships(q3_df_outs, "psi_tlp", y_variables)

# Display the plots
for (plot in plots) print(plot)
```

Is P50 related to any model params?
```{r, warning = F}

# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "plc50_stem", y_variables)

# Display the plots
for (plot in plots) print(plot)

plots <- plot_all_relationships(q3_df_outs, "plc50_stem", y_variables)

# Display the plots
for (plot in plots) print(plot)
```

Is LDMC related to any model params?
```{r, warning = F}

# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "ldmc", y_variables)

# Display the plots
for (plot in plots) print(plot)

plots <- plot_all_relationships(q3_df_outs, "ldmc", y_variables)

# Display the plots
for (plot in plots) print(plot)
```

Is SLA related to any model params?
```{r, warning = F}

# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df %>% filter(sla < 20), "sla", y_variables)

# Display the plots
for (plot in plots) print(plot)

plots <- plot_all_relationships(q3_df_outs, "sla", y_variables)

# Display the plots
for (plot in plots) print(plot)
```

Is rooting depth related to any model params?
```{r, warning = F}

# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "max_rooting_depth_m", y_variables)

# Display the plots
for (plot in plots) print(plot)

plots <- plot_all_relationships(q3_df_outs, "max_rooting_depth_m", y_variables)
# Display the plots
for (plot in plots) print(plot)
```

Is rooting depth related to any traits? (Just try for fun)
```{r, warning = F}
y_variables <- c("ldmc", "plc50_stem", "psi_tlp", "sla", "minwp", "maxwp", "min_pd", "max_pd")
# Generate and store plots with psi_tlp as the x-axis
plots <- plot_all_relationships(q3_df, "max_rooting_depth_m", y_variables)

# Display the plots
for (plot in plots) print(plot)

#remove QUDO, hard to measure P50 and its driving the relationship. 
q3_df_outs <- q3_df %>% 
  filter(!(species %in% c("QUEDOU")))

plots <- plot_all_relationships(q3_df_outs, "max_rooting_depth_m", y_variables)

# Display the plots
for (plot in plots) print(plot)
#Doesnt make a difference. 
```

Is TLP related to P50?
```{r}
q3_df %>% ggplot(aes(y = plc50_stem, x = psi_tlp)) +
  geom_point() +
  stat_poly_eq(use_label("R2", "F", "P", "n", sep = "*\"; \"*")) +
  stat_poly_line()
```

####Table SX. (traits)
```{r}
tablesx <- read_csv(here("data", "traits_rd_20250327.csv"))
tablesx

nrd <- tablesx %>% 
  select(max_rooting_depth_m) %>% 
  drop_na() %>% 
  count()
nrd

nplc50 <- tablesx %>% 
  select(plc50_stem) %>% 
  drop_na() %>% 
  count()
nplc50

n<- tablesx %>% 
  select(5) %>% 
  drop_na() %>% 
  count()
n
  
write_csv(tablesx, here("results", "figures", "tableSX_traits.csv"))
```

####Figure 5.* (P50 x model parameters)
```{r}
# --- keep your color scale + data splits exactly as-is ---
color_species <- scale_color_manual(
  values = c(
    ABICON = "#17154f",
    ADEFAS = "#2f357c",
    ARBMEN = "#6c5d9e",

    ARCGLA = "#9d9cd5",
    ARCPAT = "#b0799a",
    CALDEC = "#59385c",
    CEACUN = "#f6b3b0",

    CEAPAR = "#b38711",
    CEASPI = "#e48171",
    CERBET = "#d8b847",

    ERIFAS = "#bf3729",
    HETARB = "#e69b00",

    MALLAU = "#f5bb50",
    PINJEF = "#ada43b",
    PSEMEN = "#355828",

    QUEAGR = "#5b859e",
    QUEBER = "#1e395f",
    QUEDOU = "#75884b",

    QUEDUR = "#1e5a46",
    QUEGAR = "#df8d71",
    QUEKEL = "#af4f2f",

    SALLEU = "#d48f90",
    SALMEL = "#732f30",
    UMBCAL = "#d8b847"
  ),
  drop = FALSE
)

q3_df_salvias <- q3_df %>% filter(species %in% c("SALLEU", "SALMEL"))
q3_df_outs    <- q3_df %>% filter(!(species %in% c("SALLEU", "SALMEL")))

# ----------------------------
# Bigger font, keep rest same
# ----------------------------
big_theme <- #theme_minimal(base_size = 15) +
  theme(
    axis.title = element_text(size = 14),
    axis.text  = element_text(size = 12),
    legend.title = element_text(size = 14),
    legend.text  = element_text(size = 12),
    plot.margin = margin(6, 6, 6, 6)
  )

# ============================
# Panel A (SWAPPED axes): x = min_mwp, y = plc50_stem
# ============================
model <- lm(plc50_stem ~ min_mwp, data = q3_df)

fig5a <- ggplot() +
  geom_point(data = q3_df, aes(x = min_mwp, y = plc50_stem, color = species)) +
  color_species +
  geom_smooth(data = q3_df, aes(x = min_mwp, y = plc50_stem),
              method = "lm", se = FALSE, color = "black") +
  labs(
    x = "Min. Midday Water Potential (MPa)",   # now x
    y = NULL,                                    # shared y label (set below)
    color = "Species"
  ) +
  big_theme

# ============================
# Panel B (SWAPPED axes): x = min_lfm, y = plc50_stem
# ============================
model <- lm(plc50_stem ~ min_lfm, data = q3_df)

fig5b <- ggplot() +
  geom_point(data = q3_df, aes(x = min_lfm, y = plc50_stem, color = species)) +
  color_species +
  geom_smooth(data = q3_df, aes(x = min_lfm, y = plc50_stem),
              method = "lm", se = FALSE, color = "black") +
  labs(
    x = "Min. Seasonal LFM (%)",               # now x
    y = NULL,                                    # shared y label
    color = "Species"
  ) +
  # keep your LFM tick labels (now on x, because we swapped axes)
  scale_x_continuous(
    breaks = c(0.4, 0.6, 0.8, 1.0),
    labels = c(40, 60, 80, 100)
  ) +
  big_theme +
  theme(axis.title = element_blank,
        axis.text  = element_blank)

# ----------------------------
# Shared Y-axis label (applies to BOTH panels)
# ----------------------------
ylab <- cowplot::ggdraw() +
  cowplot::draw_label(
    "P50 (MPa)",
    angle = 90,
    size = 16,            # match big_theme axis title size
    fontface = "plain",
    hjust = 0.5,
    vjust = 0.5
  )

# ----------------------------
# Legend (keep your styling)
# ----------------------------
legend <- cowplot::get_legend(
  fig5a +
    theme(
      legend.position = "right",
      legend.key = element_blank(),
      legend.background = element_blank(),
      legend.box.background = element_blank()
    )
)

# ----------------------------
# Combine: [shared y label | two panels] + legend
#   (also reduces excess left whitespace)
# ----------------------------
plots <- cowplot::plot_grid(
  ylab,
  cowplot::plot_grid(
    fig5a + theme(legend.position = "none"),
    fig5b + theme(legend.position = "none"),
    nrow = 1,
    labels = c("A", "B"),
    label_fontface = "bold",
    label_size = 16,
    label_x = 0.02,
    label_y = 0.98,
    hjust = 0, vjust = 1
  ),
  nrow = 1,
  rel_widths = c(0.06, 1)  # small column for shared y label
)

plots_legend_grandint <- cowplot::plot_grid(
  plots,
  legend,
  nrow = 1,
  rel_widths = c(1, 0.275)
)

plots_legend_grandint

ggsave(
  plot = plots_legend_grandint,
  filename = here::here("figures", "fig5.jpg"),
  dpi = 600,
  width = 10,
  height = 4
)

```


```{r}
color_species <- scale_color_manual(
  values = c(
    ABICON = "#17154f",
    ADEFAS = "#2f357c",
    ARBMEN = "#6c5d9e",
    
    ARCGLA = "#9d9cd5",
    ARCPAT = "#b0799a",
    CALDEC = "#59385c",
    CEACUN = "#f6b3b0",
    
    CEAPAR = "#b38711",
    CEASPI = "#e48171",
    CERBET = "#d8b847",
    
    ERIFAS = "#bf3729",
    HETARB = "#e69b00",
    
    MALLAU = "#f5bb50",
    PINJEF = "#ada43b",
    PSEMEN = "#355828",
    
    QUEAGR = "#5b859e",
    QUEBER = "#1e395f",
    QUEDOU = "#75884b",
    
    QUEDUR = "#1e5a46",
    QUEGAR = "#df8d71",
    QUEKEL = "#af4f2f",
    
    SALLEU = "#d48f90",
    SALMEL = "#732f30",
    UMBCAL = "#d8b847"
  ),
  drop = FALSE
)

q3_df_salvias <- q3_df %>% 
  filter(species %in% c("SALLEU", "SALMEL"))

q3_df_outs <- q3_df %>% 
  filter(!(species %in% c("SALLEU", "SALMEL")))

# P50 x Min MPA
model <- lm(min_mwp ~ plc50_stem, data = q3_df)
eqn_salv <- paste0(
  "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
  "\nR² = ", round(summary(model)$r.squared, 3), 
  "\np = ", signif(summary(model)$coefficients[2, 4], 3)
)

model_nosalv <- lm(min_mwp ~ plc50_stem, data = q3_df_outs)
eqn_nosalv <- paste0(
  "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
  "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
  "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
)

fig5a <- ggplot() +
  geom_point(data = q3_df, aes(y = min_mwp, x = plc50_stem, color = species)) +
  # geom_point(data = q3_df_salvias, aes(y = min_mwp, x = plc50_stem, color = species),
  #            shape = 1, size = 6) +
  color_species +
  geom_smooth(data = q3_df, aes(y = min_mwp, x = plc50_stem),
              method = "lm", se = FALSE, color = "black") +
  # geom_smooth(data = q3_df_outs, aes(y = min_mwp, x = plc50_stem),
  #             method = "lm", se = FALSE, color = "#bf3729") +
  # annotate("text", x = -9.75, y = -3.25, label = eqn_salv, color = "#ab84a5",
  #          size = 3.5, hjust = 0) +
  # annotate("text", x = -9.75, y = -4.5, label = eqn_nosalv, color = "#bf3729",
  #          size = 3.5, hjust = 0) +
  labs(y = "Minimum Midday Water Potential (MPa)",
       x = "P50 (MPa)",
       color = "Species")

# P50 x Min LFM
model <- lm(min_lfm ~ plc50_stem, data = q3_df)
eqn_salv <- paste0(
  "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
  "\nR² = ", round(summary(model)$r.squared, 3), 
  "\np = ", signif(summary(model)$coefficients[2, 4], 3)
)

model_nosalv <- lm(min_lfm ~ plc50_stem, data = q3_df_outs)
eqn_nosalv <- paste0(
  "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
  "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
  "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
)

fig5b <- ggplot() +
  geom_point(data = q3_df, aes(y = min_lfm, x = plc50_stem, color = species)) +
  color_species +
  geom_smooth(data = q3_df, aes(y = min_lfm, x = plc50_stem),
              method = "lm", se = FALSE, color = "black") +
  # annotate("text", x = -9.75, y = 1.05, label = eqn_salv, color = "#ab84a5",
  #          size = 3.5, hjust = 0) +
  labs(y = "Minimum Seasonal LFM (%)",
       x = "P50 (MPa)",
       color = "Species") +
  # Show axis ticks as 40, 60, 80, 100 while data stays 0.4–1.0
  scale_y_continuous(breaks = c(0.4, 0.6, 0.8, 1.0),
                     labels = c(40, 60, 80, 100))

# Extract legend
legend <- cowplot::get_legend(
  fig5a + theme(legend.box.margin = margin(0, 0, 5, 0))  +
  theme(
    legend.position = "right",
    legend.key = element_blank(),
    legend.background = element_blank(),
    legend.box.background = element_blank()
  ))

# Combine with panel labels A, B in the upper-left of each panel
plots <- cowplot::plot_grid(
  fig5a + theme(legend.position = "none"),
  fig5b + theme(legend.position = "none"),
  nrow = 1,
  labels = c("A", "B"),
  label_fontface = "bold",
  label_size = 14,
  label_x = 0.02,  # near left edge of each panel
  label_y = 0.98,  # near top of each panel
  hjust = 0, vjust = 1
)

plots_legend_grandint <- cowplot::plot_grid(
  plots,
  legend,
  nrow = 1,
  rel_widths = c(1, 0.275)
)

plots_legend_grandint

ggsave(plot = plots_legend_grandint, filename = here::here("figures", "fig5.jpg"), dpi = 600,
  width = 10,   # make wider
  height = 4)    # keep height reasonable)

```



####Figure 6. (traits, leaf-level)

q3_df_salvias <- q3_df %>% 
  filter(species %in% c("SALLEU", "SALMEL"))

q3_df_outs <- q3_df %>% 
  filter(!(species %in% c("SALLEU", "SALMEL")))
  
```{r}
#TLP x MaxLFM
model <- lm(max_lfm ~ psi_tlp, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(max_lfm ~ psi_tlp, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5a <- ggplot() +
  geom_point(data = q3_df, aes(y = max_lfm, x = psi_tlp, color = species)) +
  geom_point(data = q3_df_salvias, aes(y = max_lfm, x = psi_tlp, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(y = max_lfm, x = psi_tlp), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_outs, aes(y = max_lfm, x = psi_tlp), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = -3.525, y = 2.1, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = -3.525, y = 2.5, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Maximum LFM (observed)",
       x = "Turgor Loss Point (Mpa)", 
       color = "Species") 
fig5a
```


```{r}
#P50 x Min MPA
model <- lm(min_mwp ~ plc50_stem, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(min_mwp ~ plc50_stem, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5b <- ggplot() +
  geom_point(data = q3_df, aes(y = min_mwp, x = plc50_stem, color = species)) +
  geom_point(data = q3_df_salvias, aes(y = min_mwp, x = plc50_stem, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(y = min_mwp, x = plc50_stem), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_outs, aes(y = min_mwp, x = plc50_stem), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = -9.75, y = -3.25, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = -9.75, y = -4.5, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Minimum Midday Water Potential (MPa)",
       x = "P50 (MPa)", 
       color = "Species") 
fig5b

#P50 x Min LFM
model <- lm(min_lfm ~ plc50_stem, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(min_lfm ~ plc50_stem, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5c <- ggplot() +
  geom_point(data = q3_df, aes(y = min_lfm, x = plc50_stem, color = species)) +
  # geom_point(data = q3_df_salvias, aes(y = min_lfm, x = plc50_stem, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(y = min_lfm, x = plc50_stem), method = "lm", se = F, color = "#ab84a5") +
  # geom_smooth(data = q3_df_outs, aes(y = min_lfm, x = plc50_stem), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = -9.75, y = 1.05, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  # annotate("text", x = -9.75, y = .9, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Minimum Seasonal LFM (%)",
       x = "P50 (MPa)", 
       color = "Species") 
fig5c
```


```{r}
#LDMC x Max LFM
model <- lm(intercept_lfm ~ ldmc, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(intercept_lfm ~ ldmc, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5d <- ggplot() +
  geom_point(data = q3_df, aes(y = intercept_lfm, x = ldmc, color = species)) +
  geom_point(data = q3_df_salvias, aes(intercept_lfm, x = ldmc, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(intercept_lfm, x = ldmc), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_outs, aes(intercept_lfm, x = ldmc), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = .375, y = 4.25, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = .375, y = 3.25, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Maximum LFM (Model Intercept)",
       x = "LDMC (g)", 
       color = "Species") 
fig5d
```
```{r}
#LDMC x Max LFM
model <- lm(max_lfm ~ ldmc, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(max_lfm ~ ldmc, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5d <- ggplot() +
  geom_point(data = q3_df, aes(y = max_lfm, x = ldmc, color = species)) +
  geom_point(data = q3_df_salvias, aes(max_lfm, x = ldmc, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(max_lfm, x = ldmc), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_outs, aes(max_lfm, x = ldmc), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = .375, y = 4.25, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = .375, y = 3.25, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Maximum LFM (Observed)",
       x = "LDMC (g)", 
       color = "Species") 
fig5d
```
```{r}
#LDMC x Max LFM
model <- lm(min_lfm ~ ldmc, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(min_lfm ~ ldmc, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5d <- ggplot() +
  geom_point(data = q3_df, aes(y = min_lfm, x = ldmc, color = species)) +
  geom_point(data = q3_df_salvias, aes(min_lfm, x = ldmc, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(min_lfm, x = ldmc), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_outs, aes(min_lfm, x = ldmc), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = .375, y = 4.25, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = .375, y = 3.25, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Maximum LFM (Observed)",
       x = "LDMC (g)", 
       color = "Species") 
fig5d
```

```{r}
#slope x SLA
model <- lm(slope ~ sla, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(slope ~ sla, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5e <- ggplot() +
  geom_point(data = q3_df, aes(y = slope, x = sla, color = species)) +
  geom_point(data = q3_df_salvias, aes(y = slope, x = sla, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df, aes(y = slope, x = sla), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_outs, aes(y = slope, x = sla), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = 9.75, y = -.025, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = 9.75, y = -.095, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Slope",
       x = "SLA (cm2/g)", 
       color = "Species") +
  xlim(4.5, 14) +
  ylim(-.25, 0)

fig5e
```


```{r}
q3_df_filtered <- q3_df %>% 
              filter(sla < 20)

q3_df_filtered_outs <- q3_df_outs %>% 
              filter(sla < 20)

q3_df_filtered_salvias <- q3_df_salvias%>% 
              filter(sla < 20)
#Max LFM and SLA
model <- lm(intercept_lfm ~ sla, data = q3_df_filtered %>% 
              filter(sla < 20))
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(intercept_lfm ~ sla, data = q3_df_filtered_outs %>% 
              filter(sla < 20))
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5f <- ggplot() +
  geom_point(data = q3_df_filtered, aes(y = intercept_lfm, x = sla, color = species)) +
  geom_point(data = q3_df_filtered_salvias, aes(y = intercept_lfm, x = sla, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df_filtered, aes(y = intercept_lfm, x = sla), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_filtered_outs, aes(y = intercept_lfm, x = sla), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df_filtered, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = 4, y = 4.2, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = 4, y = 3.2, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Maximum LFM (Model Intercept)",
       x = "SLA (cm2/g)", 
       color = "Species") 
fig5f
```
```{r}
q3_df_filtered <- q3_df %>% 
              filter(sla < 20)

q3_df_filtered_outs <- q3_df_outs %>% 
              filter(sla < 20)

q3_df_filtered_salvias <- q3_df_salvias%>% 
              filter(sla < 20)
#Max LFM and SLA
model <- lm(intercept_lfm ~ sla, data = q3_df_filtered %>% 
              filter(sla < 20))
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(max_lfm ~ sla, data = q3_df_filtered_outs %>% 
              filter(sla < 20))
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5f <- ggplot() +
  geom_point(data = q3_df_filtered, aes(y = max_lfm, x = sla, color = species)) +
  geom_point(data = q3_df_filtered_salvias, aes(y = max_lfm, x = sla, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df_filtered, aes(y = max_lfm, x = sla), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_filtered_outs, aes(y = max_lfm, x = sla), method = "lm", se = F, color =  "#bf3729") +
  #stat_poly_line(data = q3_df_filtered, aes(y = intercept_lfm, x = psi_tlp)) +
  annotate("text", x = 4, y = 2.2, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = 4, y = 3.2, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Maximum LFM (Observed)",
       x = "SLA (cm2/g)", 
       color = "Species") 
fig5f
```


```{r}
#slope and psi_tlp
model <- lm(slope ~ psi_tlp, data = q3_df)
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(slope ~ psi_tlp, data = q3_df_outs)
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5g <- ggplot() +
  geom_point(data = q3_df_filtered, aes(y = slope, x = psi_tlp, color = species)) +
  geom_point(data = q3_df_filtered_salvias, aes(y = slope, x = psi_tlp, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df_filtered, aes(y = slope, x = psi_tlp), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_filtered_outs, aes(y = slope, x = psi_tlp), method = "lm", se = F, color =  "#bf3729") +
  # #stat_poly_line(data = q3_df_filtered, aes(y = slope, x = slope)) +
  annotate("text", x = -3.5, y = 0.08, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = -3.5, y = 0, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Slope",
       x = "TLP (MPa)", 
       color = "Species") 
fig5g
```

```{r}
#slope and ldmc
model <- lm(slope ~ ldmc, data = q3_df_filtered %>% 
              filter(ldmc < 20))
eqn_salv <- paste0(
      "y = ", round(coef(model)[2], 3), "x + ", round(coef(model)[1], 3), 
      "\nR² = ", round(summary(model)$r.squared, 3), 
      "\np = ", signif(summary(model)$coefficients[2, 4], 3)
    )

model_nosalv <- lm(slope ~ ldmc, data = q3_df_filtered_outs %>% 
              filter(ldmc < 20))
eqn_nosalv <- paste0(
      "y = ", round(coef(model_nosalv)[2], 3), "x + ", round(coef(model_nosalv)[1], 3), 
      "\nR² = ", round(summary(model_nosalv)$r.squared, 3), 
      "\np = ", signif(summary(model_nosalv)$coefficients[2, 4], 3)
    )

fig5h <- ggplot() +
  geom_point(data = q3_df_filtered, aes(y = slope, x = ldmc, color = species)) +
  geom_point(data = q3_df_filtered_salvias, aes(y = slope, x = ldmc, color = species), shape = c(1), size = 6 ) +
  color_species +
    geom_smooth(data = q3_df_filtered, aes(y = slope, x = ldmc), method = "lm", se = F, color = "#ab84a5") +
  geom_smooth(data = q3_df_filtered_outs, aes(y = slope, x = ldmc), method = "lm", se = F, color =  "#bf3729") +
  # #stat_poly_line(data = q3_df_filtered, aes(y = slope, x = slope)) +
  annotate("text", x = 0.15, y = 0.08, label = eqn_salv, color = "#ab84a5", size = 3.5, hjust = 0)+
  annotate("text", x = 0.15, y = 0, label = eqn_nosalv, color =  "#bf3729", size = 3.5, hjust = 0) +
  labs(y = "Slope",
       x = "LDMC (g)", 
       color = "Species") 
fig5h
```

####Combine:
```{r}
legend <- cowplot::get_legend(
  # create some space to the left of the legend
  fig5f + theme(legend.box.margin = margin(0, 0, 0, 0))
)

plots <- cowplot::plot_grid(fig5a + theme(legend.position = "none"), 
                   #fig5b + theme(legend.position = "none"), 
                   #fig5c + theme(legend.position = "none"), 
                   fig5d + theme(legend.position = "none"), 
                   fig5e + theme(legend.position = "none"), 
                   fig5f + theme(legend.position = "none"),
                   fig5g + theme(legend.position = "none"),
                   nrow = 2)

plots <- cowplot::plot_grid(
  fig5a + theme(legend.position = "none"),
  # fig5b + theme(legend.position = "none"),
  # fig5c + theme(legend.position = "none"),
  fig5d + theme(legend.position = "none"),
  #fig5e + theme(legend.position = "none"),
  fig5f + theme(legend.position = "none"),
  fig5g + theme(legend.position = "none"),
  nrow = 2,
  labels = c("A", "B", "C", "D"),     # <---- add labels here
  label_size = 14,                    # adjust size as needed
  label_fontface = "bold"             # optional
)
plots_legend_int <- cowplot::plot_grid(plots,
                   legend,
                   rel_widths = c(1,.35))
plots_legend_int
ggsave(plot = plots_legend_int, here::here("figures", "figsx_spptraits.jpg"), dpi = 600, height = 6.4, width = 8.5)
```
#New Figure 6. 

Stats: 
```{r}

```


```{r}
library(ggplot2)
library(dplyr)
library(cowplot)
library(here)

# ----------------------------
# Helper: p-value -> linetype
# ----------------------------
get_lm_p <- function(df, y, x) {
  d <- df %>%
    select(all_of(c(y, x))) %>%
    filter(is.finite(.data[[y]]), is.finite(.data[[x]]))

  if (nrow(d) < 3 || dplyr::n_distinct(d[[x]]) < 2) return(NA_real_)
  summary(lm(reformulate(x, y), data = d))$coefficients[2, 4]
}

lt_from_p <- function(p, alpha = 0.05) {
  ifelse(is.na(p), "dotted", ifelse(p < alpha, "solid", "dotted"))
}

# ----------------------------
# Data (SLA-filtered)
# ----------------------------
q3_df_filtered <- q3_df %>% filter(sla < 20)
q3_df_filtered_outs <- q3_df_outs %>% filter(sla < 20)
q3_df_filtered_salvias <- q3_df_salvias %>% filter(sla < 20)

# ----------------------------
# Linetypes (match each panel)
# ----------------------------
lt_A_salv   <- lt_from_p(get_lm_p(q3_df_filtered,      "intercept_lfm", "sla"))
lt_A_nosalv <- lt_from_p(get_lm_p(q3_df_filtered_outs, "intercept_lfm", "sla"))

lt_B_salv   <- lt_from_p(get_lm_p(q3_df,      "intercept_lfm", "ldmc"))
lt_B_nosalv <- lt_from_p(get_lm_p(q3_df_outs, "intercept_lfm", "ldmc"))

lt_C_salv   <- lt_from_p(get_lm_p(q3_df_filtered,      "slope", "sla"))
lt_C_nosalv <- lt_from_p(get_lm_p(q3_df_filtered_outs, "slope", "sla"))

# ----------------------------
# Shared styling: consistent axis title sizes + more room for panel labels
# ----------------------------
axis_title_size <- 10
axis_text_size  <- 9

base_theme <-
  theme(
    base_size = axis_text_size,
    axis.title.x = element_text(size = axis_title_size),
    axis.title.y = element_text(size = axis_title_size),
    axis.text    = element_text(size = axis_text_size),

    # give a bit more space at the top for A/B/C labels
    plot.margin = margin(t = 10, r = 4, b = 4, l = 2),

    legend.title = element_text(size = axis_title_size),
    legend.text  = element_text(size = axis_text_size)
  )

# ----------------------------
# Panels
# ----------------------------
figA <- ggplot() +
  geom_point(data = q3_df_filtered,
             aes(x = sla, y = intercept_lfm*100, color = species),
             size = 1.6, alpha = 0.8) +
  geom_point(data = q3_df_filtered_salvias,
             aes(x = sla, y = intercept_lfm*100, color = species),
             shape = 1, size = 5) +
  color_species +
  geom_smooth(data = q3_df_filtered,
              aes(x = sla, y = intercept_lfm*100),
              method = "lm", se = FALSE, color = "#ab84a5", linetype = lt_A_salv) +
  geom_smooth(data = q3_df_filtered_outs,
              aes(x = sla, y = intercept_lfm*100),
              method = "lm", se = FALSE, color = "#bf3729", linetype = lt_A_nosalv) +
  labs(x = "SLA (cm2/g)", y = NULL, color = "Species") +
  base_theme

figB <- ggplot() +
  geom_point(data = q3_df,
             aes(x = ldmc, y = intercept_lfm*100, color = species),
             size = 1.6, alpha = 0.8) +
  geom_point(data = q3_df_salvias,
             aes(x = ldmc, y = intercept_lfm*100, color = species),
             shape = 1, size = 5) +
  color_species +
  geom_smooth(data = q3_df,
              aes(x = ldmc, y = intercept_lfm*100),
              method = "lm", se = FALSE, color = "#ab84a5", linetype = lt_B_salv) +
  geom_smooth(data = q3_df_outs,
              aes(x = ldmc, y = intercept_lfm*100),
              method = "lm", se = FALSE, color = "#bf3729", linetype = lt_B_nosalv) +
  labs(x = "LDMC (g)", y = NULL, color = "Species") +
  base_theme

figC <- ggplot() +
  geom_point(data = q3_df_filtered,
             aes(x = sla, y = slope, color = species),
             size = 1.6, alpha = 0.8) +
  geom_point(data = q3_df_filtered_salvias,
             aes(x = sla, y = slope, color = species),
             shape = 1, size = 5) +
  color_species +
  geom_smooth(data = q3_df_filtered,
              aes(x = sla, y = slope),
              method = "lm", se = FALSE, color = "#ab84a5", linetype = lt_C_salv) +
  geom_smooth(data = q3_df_filtered_outs,
              aes(x = sla, y = slope),
              method = "lm", se = FALSE, color = "#bf3729", linetype = lt_C_nosalv) +
  labs(x = "SLA (cm2/g)", y = NULL, color = "Species") +
  base_theme

# ----------------------------
# Legend: force 3 columns
# ----------------------------
legend_plot <- figA +
  guides(color = guide_legend(ncol = 3, byrow = TRUE)) +
  theme(
    legend.position = "right",
    legend.key = element_blank(),
    legend.background = element_blank(),
    legend.box.background = element_blank()
  )

legend <- cowplot::get_legend(legend_plot)
# ----------------------------
# Shared y-axis labels (row-level) using same font size as axis titles
# ----------------------------
ylab_top <- cowplot::ggdraw() +
  cowplot::draw_label("Max LFM (%)",
                      angle = 90, size = axis_title_size,
                      hjust = 0.3, vjust = 0.5)

ylab_bottom <- cowplot::ggdraw() +
  cowplot::draw_label("Slope",
                      angle = 90, size = axis_title_size,
                      hjust = 0.3, vjust = 0.5)

# ----------------------------
# Layout:
# Top row:   A | B
# Bottom row: C | Legend (legend where panel D was)
# Fix label collisions: nudge label positions inside each panel + add top margin
# ----------------------------
label_x <- -0.02   # push labels slightly right
label_y <- 0.985  # keep at very top

top_row <- cowplot::plot_grid(
  ylab_top,
  cowplot::plot_grid(
    figA + theme(legend.position = "none"),
    figB + theme(legend.position = "none"),
    nrow = 1,
    labels = c("A", "B"),
    label_size = 12,
    label_fontface = "bold",
    label_x = label_x,
    label_y = label_y
  ),
  nrow = 1,
  rel_widths = c(0.06, 1)
)

bottom_row <- cowplot::plot_grid(
  ylab_bottom,
  cowplot::plot_grid(
    figC + theme(legend.position = "none"),
    cowplot::ggdraw(legend),
    nrow = 1,
    labels = c("C", ""),
    label_size = 12,
    label_fontface = "bold",
    label_x = label_x,
    label_y = label_y
  ),
  nrow = 1,
  rel_widths = c(0.06, 1)
)

final_fig <- cowplot::plot_grid(
  top_row,
  bottom_row,
  ncol = 1,
  rel_heights = c(1, 1)
)

final_fig

ggsave(
  plot = final_fig,
  filename = here::here("figures", "fig5_spptraits_siglines_noD.jpg"),
  dpi = 600,
  height = 5,
  width = 6
)
```
```{r}

```

#-----
#Sub-Q: 

Can we repeat Jolly or Nolan's analyses? 
Jolly, need: 
- RWC, SVA, k

PV Curve, need: 
- PV curve parameters

#-------

##---------
```{r, eval = F}
## Preliminary analysis of 2021 Live Fuel Moisture (LFM) data

rm(list = ls())  # Remove all objects from the workspace to start fresh

library(ggplot2)  # Load ggplot2 package for advanced plotting capabilities
source(here('scripts', 'lfm_functions.R'))
# Source custom functions from external script

# Read in the combined dataset; 'as.is = TRUE' prevents strings from converting to factors
# 'row.names = 1' uses the first column as row names
lwa <- read.csv(here('data', 'all-data-combined.csv'))

# Calculate the inverse of LFM for modeling purposes
lwa$ilfm <- 1 / lwa$lfm

# Display the first few rows of the data to check if it's loaded correctly
head(lwa)

# Create a frequency table of the 'study' variable
table(lwa$study)

# Get a sorted list of unique study sites
sites <- sort(unique(lwa$study))

# Verify the number of observations per study
table(lwa$study)

# Check the total number of observations
nrow(lwa)

### Plotting by Site

# Define colors for each site for consistent plotting
scolors <- c("#B9C7E2", "#ECAB99",  "#5B6530", "#9484B1",  "#F1C100")  # Added color for SEKI

# Assign colors to each observation based on the study site
lwa$scolors <- scolors[match(lwa$study, sites)]

# Confirm that colors are assigned correctly
table(lwa$scolors)

# Randomly sample 1000 observations for plotting to avoid overplotting
rsamp <- sample(1:nrow(lwa), 1000)  # Sample from the full dataset

# Set up an empty plot with defined axes and limits
plot(lfm ~ mwp, data = lwa, type = 'n',
     xlab = 'Midday water potential (MPa)',
     ylab = 'Live fuel moisture',
     xlim = c(-8, 0), ylim = c(0, 3.5))

# Plot data points for each study site with different symbols and colors
points(lfm ~ mwp, data = lwa[lwa$study == 'Sedgwick', ],
       pch = 5, cex = 1, col = lwa$scolors[lwa$study == 'Sedgwick'])

points(lfm ~ mwp, data = lwa[lwa$study == 'StuntRanch', ],
       pch = 15, cex = 1, col = lwa$scolors[lwa$study == 'StuntRanch'])

points(lfm ~ mwp, data = lwa[lwa$study == 'Pepperwood', ],
       pch = 19, cex = 1.2, col = lwa$scolors[lwa$study == 'Pepperwood'])

# Include SEKI in the points plotting
points(lfm ~ mwp, data = lwa[lwa$study == 'SEKI', ],
       pch = 17, cex = 1.2, col = lwa$scolors[lwa$study == 'SEKI'])  # Different symbol for SEKI

# Add a legend to the plot
legend(-7, 3, sites, fill = NULL, border = 'white')

# Add custom legend symbols corresponding to each site
points(rep(-6.7, length(sites)), seq(2.84, 2.64 - 0.2 * (length(sites) - 1), length.out = length(sites)),
       pch = c(19, 5, 15, 17), col = scolors, cex = 2)  # Added SEKI symbol





# Prepare for analyses by site and species
sites <- sort(unique(lwa$Sp.Site))  # Re-affirm the list of species at each site
table(lwa$study)  # Check the distribution of observations

# Create a new logical column indicating if the site is coastal
lwa$coastal <- TRUE
#lwa$coastal[which(lwa$study == 'SEKI')] <- FALSE  # Mark 'SEKI' as non-coastal

# Initialize lists and labels for storing results
rsel <- list()  # List to hold row indices for each analysis subset
slabel <- sites  # Labels corresponding to each subset

# Populate 'rsel' with row indices for each site
for (i in 1:length(sites)) {
  rsel[[i]] <- which(lwa$Sp.Site == sites[i])
}

# # Add indices for coastal sites
# i <- i + 1
# rsel[[i]] <- which(lwa$coastal)

# Add indices for all data
i <- i + 1
#rsel[[i]] <- 1:nrow(lwa)

# Update labels accordingly
slabel <- c(slabel)

# Confirm that 'rsel' and 'slabel' are correctly set up
length(rsel)
slabel

# Initialize data structures to store statistical results
stres <- data.frame(
  study = slabel,
  Nspec = NA,
  Nobs = NA,
  BIC.no.int = NA,
  common.slope = NA,
  BIC.int = NA
)

spres <- list()  # List to hold species-specific results
scoeff <- list()  # List to hold coefficients from models
pvals <- list()  # List to hold predicted values from models

# Define parameters for model forms and factors
pform <- 'Inv'  # Model form: 'Reg' for regular, could be 'Inv' for inverse
sppFac <- 'SpeciesSite'  # Species factor, could be 'Species' or 'SpeciesSite'
slpModel <- 'SpSpecific'  # Slope model: 'Common' or 'SpSpecific'

# Initialize the loop counter
i = 31

# Loop through each subset defined in 'rsel'
for (i in 1:length(rsel)) {
  # Subset the data for the current selection
  td <- lwa[rsel[[i]], ]
  
  # Adjust species factor if necessary
  if (sppFac == 'SpeciesSite') td$Species <- td$Sp.Site
  
  # Record the number of observations and species
  stres$Nobs[i] <- nrow(td)
  spp <- sort(unique(td$Species))
  stres$Nspec[i] <- length(spp)
  
  # Prepare a dataframe to store species-specific results
  spres[[i]] <- data.frame(
    study = rep(slabel[i], length(spp)),
    species = spp,
    Nobs = NA,
    minWP = NA,
    critWP = NA,
    minLFM = NA,
    model1.int = NA,
    model1.slp = NA,
    model2.int = NA,
    model2.slp = NA
  )
  
  # Fit a model without interaction to test if species have different intercepts
  fit1 <- glm(ilfm ~ mwp, data = td)
  stres$BIC.no.int[i] <- BIC(fit1)  # Store Bayesian Information Criterion
  stres$common.slope[i] <- coefficients(fit1)[2]  # Common slope across species
  scoeff[[i]] <- coefficients(fit1)  # Store coefficients
  pvals[[i]] <- fit1$fitted.values  # Store fitted values
  
  # Extract and store intercepts for each species
  spres[[i]]$model1.int[1] <- coefficients(fit1)[1]
  spres[[i]]$model1.int[-1] <- coefficients(fit1)[1] + coefficients(fit1)[-c(1:2)]
  spres[[i]]$model1.slp <- coefficients(fit1)[2]
  
}

 s=1
  for (s in 1:length(spp))
  {
    r1 <- which(td$Species==spp[s])
    spres[[i]]$Nobs[s] <- length(r1)
    spres[[i]]$minWP[s] <- min(td$mwp[r1],na.rm=T)
    spres[[i]]$minLFM[s] <- min(td$lfm[r1],na.rm=T)
    #print(c(i,length(r1)))
    fit <- lm(ilfm[r1]~mwp[r1],data=td)
    cfit <- coefficients(fit)
    spres[[i]][s,c('model2.int','model2.slp')] <- cfit
    mm <- range(td$mwp[r1],na.rm=T)
    yy <- cfit[1] + cfit[2]*mm
    
    if (slpModel == 'SpSpecific') {
      xy <- inversePlotData(mm,cfit) 
      x0y <- inversePlotData(c(mm[2],0),cfit) 
      spres[[i]]$critWP[s] <- solveForX(cfit,yval=1/0.7)
    } else {
      cs <- c(spres[[i]]$model1.int[s],spres[[i]]$model1.slp[s])
      xy <- inversePlotData(mm,cs)
      x0y <- inversePlotData(c(mm[2],0),cs)
      spres[[i]]$critWP[s] <- solveForX(cs,yval=1/0.7)
    }
    
    if (pform=='Reg') {
      lines(LFM~MWP,data=xy,col=td$scolors[r1[1]],lwd=2) 
      lines(LFM~MWP,data=x0y,col=td$scolors[r1[1]],lwd=2,lty=3) 
    } else {
      lines(iLFM~MWP,data=xy,col=td$scolors[r1[1]],lwd=2)
      lines(iLFM~MWP,data=x0y,col=td$scolors[r1[1]],lwd=2,lty=3) 
    }
  }


# Display the statistical results
stres
spres[[1]]  # Results for the first subset
spres[[4]]  # Results for the fourth subset (i = 4)

# Combine species-specific results into one dataframe
spres.all <- spres[[1]]
for (i in 2:length(spres)) spres.all <- rbind(spres.all, spres[[i]])

# Check dimensions and content of the combined results
dim(spres.all)
table(spres.all$study)
head(spres.all)
tail(spres.all)

# Create a shortened species code for easier reference
spres.all$SpCode6 <- substr(spres.all$species, 1, 6)

spres.all <- spres.all %>% 
  separate(study, c("spp", "study"), sep = "_")
```
#---------

#Davids code: 

```{r, eval = F}
## Preliminary analysis of 2021 Live Fuel Moisture (LFM) data

#rm(list = ls())  # Remove all objects from the workspace to start fresh

library(ggplot2)  # Load ggplot2 package for advanced plotting capabilities
source(here('scripts', 'lfm_functions.R'))
# Source custom functions from external script

# Read in the combined dataset; 'as.is = TRUE' prevents strings from converting to factors
# 'row.names = 1' uses the first column as row names
lwa <- read.csv(here('data', 'all-data-combined.csv'))

# Calculate the inverse of LFM for modeling purposes
lwa$ilfm <- 1 / lwa$lfm

# Display the first few rows of the data to check if it's loaded correctly
head(lwa)

# Create a frequency table of the 'study' variable
table(lwa$study)

# Remove data from the 'SEKI' study as per analysis requirement
lwa <- lwa[-which(lwa$study == 'SEKI'),]

# Get a sorted list of unique study sites
sites <- sort(unique(lwa$study))

# Verify the number of observations per study after removal
table(lwa$study)

# Check the total number of observations
nrow(lwa)

### Plotting by Site

# Define colors for each site for consistent plotting
scolors <- c('orange', 'black', 'blue')

# Assign colors to each observation based on the study site
lwa$scolors <- scolors[match(lwa$study, sites)]

# Confirm that colors are assigned correctly
table(lwa$scolors)

# Randomly sample 1000 observations for plotting to avoid overplotting
rsamp <- sample(1:1000, 1000)

# Set up an empty plot with defined axes and limits
plot(lfm ~ mwp, data = lwa, type = 'n',
     xlab = 'Midday water potential (MPa)',
     ylab = 'Live fuel moisture',
     xlim = c(-8, 0), ylim = c(0, 3.5))

# Uncomment the line below to plot sampled points with colors based on study site
# points(lfm ~ mwp, data = lwa[rsamp, ], pch = 1, cex = 1, col = lwa$scolors)

# Plot data points for each study site with different symbols and colors
points(lfm ~ mwp, data = lwa[lwa$study == 'Sedgwick', ],
       pch = 5, cex = 1, col = lwa$scolors[lwa$study == 'Sedgwick'])

points(lfm ~ mwp, data = lwa[lwa$study == 'StuntRanch', ],
       pch = 15, cex = 1, col = lwa$scolors[lwa$study == 'StuntRanch'])

points(lfm ~ mwp, data = lwa[lwa$study == 'Pepperwood', ],
       pch = 19, cex = 1.2, col = lwa$scolors[lwa$study == 'Pepperwood'])

# Add a legend to the plot
legend(-7, 3, sites, fill = NULL, border = 'white')

# Add custom legend symbols corresponding to each site
points(rep(-6.7, 3), c(2.84, 2.64, 2.44),
       pch = c(19, 5, 15), col = scolors, cex = 2)

# Prepare for analyses by site
sites <- sort(unique(lwa$study))  # Re-affirm the list of study sites
table(lwa$study)  # Check the distribution of observations

# Create a new logical column indicating if the site is coastal
lwa$coastal <- TRUE
lwa$coastal[which(lwa$study == 'SEKI')] <- FALSE  # Mark 'SEKI' as non-coastal

# Initialize lists and labels for storing results
rsel <- list()  # List to hold row indices for each analysis subset
slabel <- sites  # Labels corresponding to each subset

# Populate 'rsel' with row indices for each site
for (i in 1:length(sites)) {
  rsel[[i]] <- which(lwa$study == sites[i])
}

# Add indices for coastal sites
i <- i + 1
rsel[[i]] <- which(lwa$coastal)

# Add indices for all data
i <- i + 1
rsel[[i]] <- 1:nrow(lwa)

# Update labels accordingly
slabel <- c(slabel, 'Coastal', 'All')

# Confirm that 'rsel' and 'slabel' are correctly set up
length(rsel)
slabel

# Initialize data structures to store statistical results
stres <- data.frame(
  study = slabel,
  Nspec = NA,
  Nobs = NA,
  BIC.no.int = NA,
  common.slope = NA,
  BIC.int = NA
)

spres <- list()  # List to hold species-specific results
scoeff <- list()  # List to hold coefficients from models
pvals <- list()  # List to hold predicted values from models

# Define parameters for model forms and factors
pform <- 'Reg'  # Model form: 'Reg' for regular, could be 'Inv' for inverse
sppFac <- 'SpeciesSite'  # Species factor, could be 'Species' or 'SpeciesSite'
slpModel <- 'SpSpecific'  # Slope model: 'Common' or 'SpSpecific'

# Initialize the loop counter
i = 4

# Loop through each subset defined in 'rsel'
# For demonstration, only running for i = 4
# Uncomment the loop below to run for all subsets
 for (i in 1:length(rsel))
#for (i in 4:4) 
  {
  # Subset the data for the current selection
  td <- lwa[rsel[[i]], ]
  
  # Adjust species factor if necessary
  if (sppFac == 'SpeciesSite') td$Species <- td$Sp.Site
  
  # Record the number of observations and species
  stres$Nobs[i] <- nrow(td)
  spp <- sort(unique(td$Species))
  stres$Nspec[i] <- length(spp)
  
  # Prepare a dataframe to store species-specific results
  spres[[i]] <- data.frame(
    study = rep(slabel[i], length(spp)),
    species = spp,
    Nobs = NA,
    minWP = NA,
    critWP = NA,
    minLFM = NA,
    model1.int = NA,
    model1.slp = NA,
    model2.int = NA,
    model2.slp = NA
  )
  
  # Fit a model without interaction to test if species have different intercepts
  fit1 <- glm(ilfm ~ mwp + Species, data = td)
  stres$BIC.no.int[i] <- BIC(fit1)  # Store Bayesian Information Criterion
  stres$common.slope[i] <- coefficients(fit1)[2]  # Common slope across species
  scoeff[[i]] <- coefficients(fit1)  # Store coefficients
  pvals[[i]] <- fit1$fitted.values  # Store fitted values
  
  # Extract and store intercepts for each species
  spres[[i]]$model1.int[1] <- coefficients(fit1)[1]
  spres[[i]]$model1.int[-1] <- coefficients(fit1)[1] + coefficients(fit1)[-c(1:2)]
  spres[[i]]$model1.slp <- coefficients(fit1)[2]
  
  # Fit a model with interaction to test if species have different slopes
  fit2 <- glm(ilfm ~ mwp * Species, data = td)
  stres$BIC.int[i] <- BIC(fit2)
```

Plot transformed and untransformed values: 
```{r, eval = F}
# Set up plotting parameters
  op = par(mar = c(5, 5, 3, 1))
  
  # Fit a simple model for plotting purposes
  fit <- glm(ilfm ~ mwp, data = td)
  mm <- range(td$mwp, na.rm = TRUE)
  summary(fit)
  
  # Generate data for plotting the inverse relationship
  xy <- inversePlotData(mm, coefficients(fit))
  
  # Plot the data and model fit
  if (pform == 'Reg') {
    # Plot regular LFM vs. MWP
    plot(lfm ~ mwp, data = td, main = slabel[i],
         xlim = c(-8, 0), ylim = c(0, 4),
         ylab = 'LFM', xlab = 'MWP')
    abline(h = 0.7, lty = 2)  # Add horizontal line at LFM = 0.7
    lines(LFM ~ MWP, data = xy, lwd = 3, col = 'red')  # Plot model fit
  } else {
    # Plot inverse LFM vs. MWP
    plot(ilfm ~ mwp, data = td, main = slabel[i],
         xlim = c(-8, 0), ylim = c(0, 2.5),
         ylab = '1/LFM', xlab = 'MWP')
    abline(h = 1 / 0.7, lty = 2)  # Threshold line at inverse LFM = 1/0.7
    lines(iLFM ~ MWP, data = xy, lwd = 3, col = 'red')  # Plot model fit
  }
  
  # Calculate mean midday water potential
  mean(td$mwp, na.rm = TRUE)
  
  # Loop through each species to analyze species-specific relationships
  s = 1
  for (s in 1:length(spp)) {
    # Select data for the current species
    r1 <- which(td$Species == spp[s])
    
    # Record the number of observations and minimum values
    spres[[i]]$Nobs[s] <- length(r1)
    spres[[i]]$minWP[s] <- min(td$mwp[r1], na.rm = TRUE)
    spres[[i]]$minLFM[s] <- min(td$lfm[r1], na.rm = TRUE)
    
    # Fit a linear model for the species
    fit <- lm(ilfm[r1] ~ mwp[r1], data = td)
    cfit <- coefficients(fit)
    spres[[i]][s, c('model2.int', 'model2.slp')] <- cfit  # Store coefficients
    
    # Determine the range of MWP for plotting
    mm <- range(td$mwp[r1], na.rm = TRUE)
    yy <- cfit[1] + cfit[2] * mm  # Calculate fitted values
    
    # Depending on slope model, calculate inverse plot data and critical WP
    if (slpModel == 'SpSpecific') {
      xy <- inversePlotData(mm, cfit)
      x0y <- inversePlotData(c(mm[2], 0), cfit)
      spres[[i]]$critWP[s] <- solveForX(cfit, yval = 1 / 0.7)
    } else {
      cs <- c(spres[[i]]$model1.int[s], spres[[i]]$model1.slp[s])
      xy <- inversePlotData(mm, cs)
      x0y <- inversePlotData(c(mm[2], 0), cs)
      spres[[i]]$critWP[s] <- solveForX(cs, yval = 1 / 0.7)
    }
    
    # Add species-specific lines to the plot
    if (pform == 'Reg') {
      lines(LFM ~ MWP, data = xy, col = td$scolors[r1[1]], lwd = 2)
      lines(LFM ~ MWP, data = x0y, col = td$scolors[r1[1]], lwd = 2, lty = 3)
    } else {
      lines(iLFM ~ MWP, data = xy, col = td$scolors[r1[1]], lwd = 2)
      lines(iLFM ~ MWP, data = x0y, col = td$scolors[r1[1]], lwd = 2, lty = 3)
    }
  }
  par(op)  # Reset plotting parameters
}

# Display the statistical results
stres
spres[[1]]  # Results for the first subset
spres[[4]]  # Results for the fourth subset (i = 4)

# Combine species-specific results into one dataframe
spres.all <- spres[[1]]
for (i in 2:length(spres)) spres.all <- rbind(spres.all, spres[[i]])

# Check dimensions and content of the combined results
dim(spres.all)
table(spres.all$study)
head(spres.all)
tail(spres.all)

# Create a shortened species code for easier reference
spres.all$SpCode6 <- substr(spres.all$species, 1, 6)
```

Correlate species traits with physiological measurements

```{r,eval = F}
# Subset the results to coastal sites
td <- spres.all[which(spres.all$study == 'Coastal'), ]
dim(td)

# Plot minimum LFM against model intercept
plot(minLFM ~ I(1 / model1.int), data = td)
abline(h = 0.7)  # Add horizontal line at LFM = 0.7

# Plot minimum LFM against minimum water potential
plot(minLFM ~ minWP, data = td)
abline(h = 0.7)

# Plot model intercept against minimum water potential
plot(I(1 / model1.int) ~ minWP, data = td)
abline(h = 0.7)

# Fit a generalized linear model
fit <- glm(minLFM ~ minWP + model1.int, data = td)
summary(fit)
plot(fit)  # Diagnostic plots

# Save the statistical summaries to CSV files
write.csv(here(stres, 'results', 'summary-results.csv'))
write.csv(here(spres.all, 'results', 'species-results.csv'))

# Load species traits data
spresc <- spres.all[which(spres.all$study == 'Coastal'), ]
spt <- read.csv(here('data', 'species-traits.csv'))
names(spt)

# Match species codes and merge trait data
s2s <- match(spresc$SpCode6, spt$SpCode)
spresc$PLC50.stem <- spt$PLC50.stem[s2s]
spresc$PSI.TLP <- spt$PSI.TLP[s2s]
spresc$LDMC <- spt$LDMC[s2s]

names(spresc)

# Plotting relationships between traits and physiological measurements
op = par(mfrow = c(1, 2))

# Plot minimum WP against stem PLC50
plot(minWP ~ PLC50.stem, data = spresc, pch = 19,
     xlab = 'PLC50 (MPa)', ylab = 'Minimum MWP (MPa)')
cor(spresc$minWP, spresc$PLC50.stem, use = 'pair')  # Correlation coefficient

# Identify and exclude outliers (e.g., certain species)
rsel <- which(spresc$SpCode6 %in% c('SALLEU', 'SALMEL'))
cor(spresc$minWP[-c(rsel)], spresc$PLC50.stem[-c(rsel)], use = 'pair')
points(minWP ~ PLC50.stem, data = spresc[rsel, ], pch = 1, cex = 2)

# Plot model intercept against osmotic potential at turgor loss point (TLP)
plot(I(1 / model1.int) ~ PSI.TLP, data = spresc, pch = 19,
     xlab = 'Osmotic potential at TLP (MPa)',
     ylab = 'LFM at MWP = 0')
cor(1 / spresc$model1.int, spresc$PSI.TLP, use = 'pair')

par(op)  # Reset plotting parameters

# Plot minimum LFM against osmotic potential at TLP
plot(minLFM ~ PSI.TLP, data = spresc, pch = 19,
     xlab = 'Osmotic potential at TLP (MPa)',
     ylab = 'LFM at MWP = 0')
cor(spresc$minLFM, spresc$PSI.TLP, use = 'pair')
cor(spresc$minLFM, spresc$PLC50.stem, use = 'pair')
```

Conceptual Model
```{r, eval = F}
# Source custom functions again if needed
source(here('scripts', 'lfm_functions.R'))

# Read species results
spres <- read.csv(here('results', 'species-results.csv'))
head(spres)

# Define a common slope for the conceptual model
slp <- -0.198

# Generate a sequence of inverse LFM saturation values
ilfm.sat.vec <- seq(0.25, 1.25, length.out = 25)

# Initialize a vector to hold critical MWP values
MWPcrit <- c()

# Calculate critical MWP for different LFM thresholds
for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], slp), 1 / 0.7)
}

# Convert inverse LFM saturation values back to LFM
lfm.sat.vec <- 1 / ilfm.sat.vec

# Plot the conceptual model curve
plot(MWPcrit, lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4),
     type = 'l', lwd = 2,
     xlab = 'Minimum MWP (MPa)', ylab = 'LFM @ MWP = 0')

# Repeat calculations for different LFM thresholds (e.g., 0.5 and 1.0)
for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], slp), 1 / 0.5)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4), lwd = 1)

for (i in 1:length(ilfm.sat.vec)) {
  MWPcrit[i] <- solveForX(c(ilfm.sat.vec[i], slp), 1 / 1)
}
lfm.sat.vec <- 1 / ilfm.sat.vec
lines(MWPcrit, lfm.sat.vec, xlim = c(-8, 0), ylim = c(0, 4), lwd = 1)

# Add species data points to the conceptual model plot
# Note: Replace 'letters' with actual labels or data as needed
# points(I(1 / model1.int) ~ minWP, data = spres[which(spres$study == 'Coastal'), ], pch = 19)
text(I(1 / model1.int) ~ minWP, data = spres[which(spres$study == 'Coastal'), ],
     labels = letters)

#### END HERE
### 'spres.all' summarizes all results by site and species

```

#-----


```{r, eval = F}
##2) Create a dataframe with species, study, or combined slopes and intercepts. 

# Load necessary libraries
library(tidyverse)
library(janitor)  # For clean_names function

# Initialize the final dataframe to store results
final_df1 <- lwa %>%
  select(Species, study, Sp.Site) %>%
  distinct()

# Function to fit model and extract slope & intercept
fit_model <- function(data, formula) {
  model <- glm(formula, data = data)
  coef(model)[1:2]  # return intercept and slope
}

# Model 1: Fit for each Sp.Site
sp_site_model <- lwa %>%
  group_by(Sp.Site) %>%
  do(model = fit_model(., ilfm ~ mwp)) %>%
  mutate(int_sppstudy = model[1],
         slope_sppstudy = model[2]) %>%
  select(Sp.Site, int_sppstudy, slope_sppstudy)

# Extract minimum mwp and lfm values
min_values <- lwa %>%
  group_by(Sp.Site) %>%
  mutate(min_mwp = min(mwp, na.rm = TRUE),
         min_lfm = min(lfm, na.rm = TRUE),
         n = n()) %>%
  select(Sp.Site, min_mwp, min_lfm, n)

# Model 2: Fit for each study
study_model <- lwa %>%
  group_by(study) %>%
  do(model = fit_model(., ilfm ~ mwp)) %>%
  mutate(int_study = model[1],
         slope_study = model[2]) %>%
  select(study, int_study, slope_study)

# Model 3: Fit for each species
species_model <- lwa %>%
  group_by(Species) %>%
  do(model = fit_model(., ilfm ~ mwp)) %>%
  mutate(int_spp = model[1],
         slope_spp = model[2]) %>%
  select(Species, int_spp, slope_spp)

# Model 4: Fit all data with different intercepts for each Species and the same slope across all species
all_data_model <- glm(ilfm ~ mwp + factor(Species), data = lwa)

# Extract intercepts and the shared slope from the model coefficients
species_intercepts <- coef(all_data_model)[grep("Species", names(coef(all_data_model)))]
baseline_intercept <- coef(all_data_model)["(Intercept)"]
shared_slope <- coef(all_data_model)["mwp"]

# Create a dataframe for species intercepts, adjusting by adding the baseline intercept
species_intercepts_df <- data.frame(
  Species = c(levels(as.factor(lwa$Species))[1], levels(as.factor(lwa$Species))[-1]),  # Include baseline species
  int_all = c(baseline_intercept, species_intercepts + baseline_intercept)
)

# Add the shared slope across all species as a single value
species_intercepts_df <- species_intercepts_df %>%
  mutate(slope_all = shared_slope)

# Model 5: Fit data filtered where group == "Coastal" with different intercepts for each Species and the same slope
coastal_data <- lwa %>%
  filter(group == "Coastal")

coastal_model <- glm(ilfm ~ mwp + factor(Species), data = coastal_data)

# Extract intercepts and the shared slope from the Coastal model coefficients
coastal_species_intercepts <- coef(coastal_model)[grep("Species", names(coef(coastal_model)))]
coastal_baseline_intercept <- coef(coastal_model)["(Intercept)"]
coastal_shared_slope <- coef(coastal_model)["mwp"]

# Create a dataframe for Coastal species intercepts, adjusting by adding the baseline intercept
coastal_intercepts_df <- data.frame(
  Species = c(levels(as.factor(coastal_data$Species))[1], levels(as.factor(coastal_data$Species))[-1]),  # Include baseline species
  int_all_coastal = c(coastal_baseline_intercept, coastal_species_intercepts + coastal_baseline_intercept)
)

# Add the shared slope across all Coastal species as a single value
coastal_intercepts_df <- coastal_intercepts_df %>%
  mutate(slope_all_coastal = coastal_shared_slope)

# Combine all results into the final dataframe
final_df <- final_df1 %>%
  left_join(sp_site_model, by = "Sp.Site") %>%
  left_join(min_values, by = "Sp.Site") %>%
  left_join(study_model, by = "study") %>%
  left_join(species_model, by = "Species") %>%
  left_join(species_intercepts_df, by = "Species") %>%
  left_join(coastal_intercepts_df, by = "Species") %>%
  clean_names() %>%
  distinct() %>%
  mutate(min_ilfm = 1 / min_lfm)

# Display the final dataframe
print(final_df)

# Plotting slope vs intercept colored by study
final_df %>%
  ggplot(aes(y = int_sppstudy, x = slope_sppstudy, color = study)) +
  geom_point()

# Another plot for visualization
final_df %>%
  ggplot(aes(y = int_sppstudy, x = slope_sppstudy, color = study)) +
  geom_point()

#Just get columns we want, and then make a nice table of the slopes and ints of individual species
mods_df <- final_df %>% 
  select(1:3, min_mwp, min_lfm, min_ilfm, n, slope_all, int_all, slope_all_coastal, int_all_coastal, slope_spp, int_spp)


```

#-----


<!-- Rewrite code so that it just gets the slope from a run using all species independantly:  -->

<!-- ```{r} -->
<!-- summary(lwa) -->
<!-- ``` -->


<!-- 1) Model running inverse LFM -->
<!-- ```{r} -->
<!-- lwa_new <- lwa  -->

<!-- # Prepare for analyses by site -->
<!-- sites <- sort(unique(lwa$study))  # Re-affirm the list of study sites -->
<!-- table(lwa$study)  # Check the distribution of observations -->

<!-- # Create a new logical column indicating if the site is coastal -->
<!-- lwa$coastal <- TRUE -->
<!-- lwa$coastal[which(lwa$study == 'SEKI')] <- FALSE  # Mark 'SEKI' as non-coastal -->

<!-- # Initialize lists and labels for storing results -->
<!-- rsel <- list()  # List to hold row indices for each analysis subset -->
<!-- slabel <- sites  # Labels corresponding to each subset -->

<!-- # Populate 'rsel' with row indices for each site -->
<!-- for (i in 1:length(sites)) { -->
<!--   rsel[[i]] <- which(lwa$study == sites[i]) -->
<!-- } -->

<!-- # Add indices for coastal sites -->
<!-- i <- i + 1 -->
<!-- rsel[[i]] <- which(lwa$coastal) -->

<!-- # Add indices for all data -->
<!-- i <- i + 1 -->
<!-- rsel[[i]] <- 1:nrow(lwa) -->

<!-- # Update labels accordingly -->
<!-- slabel <- c(slabel, 'Coastal', 'All') -->

<!-- # Confirm that 'rsel' and 'slabel' are correctly set up -->
<!-- length(rsel) -->
<!-- slabel -->

<!-- # Initialize data structures to store statistical results -->
<!-- stres <- data.frame( -->
<!--   study = slabel, -->
<!--   Nspec = NA, -->
<!--   Nobs = NA, -->
<!--   BIC.no.int = NA, -->
<!--   common.slope = NA, -->
<!--   BIC.int = NA -->
<!-- ) -->

<!-- spres <- list()  # List to hold species-specific results -->
<!-- scoeff <- list()  # List to hold coefficients from models -->
<!-- pvals <- list()  # List to hold predicted values from models -->

<!-- # Define parameters for model forms and factors -->
<!-- pform <- 'Inv'  # Model form: 'Reg' for regular, could be 'Inv' for inverse -->
<!-- sppFac <- 'Species'  # Species factor, could be 'Species' or 'SpeciesSite' -->
<!-- slpModel <- 'SpSpecific'  # Slope model: 'Common' or 'SpSpecific' -->

<!-- # Initialize the loop counter -->
<!-- i = length(spres) -->

<!-- # Loop through each subset defined in 'rsel' -->
<!-- for (i in 1:length(rsel)) { -->
<!--   # Subset the data for the current selection -->
<!--   td <- lwa[rsel[[i]], ] -->

<!--   # Adjust species factor if necessary so that if species occur at different sites they are treated differently -->
<!--   if (sppFac == 'SpeciesSite') td$species <- td$sp_site -->

<!--   # Record the number of observations and species -->
<!--   stres$Nobs[i] <- nrow(td) -->
<!--   spp <- sort(unique(td$species)) -->
<!--   stres$Nspec[i] <- length(spp) -->

<!--   # Prepare a dataframe to store species-specific results -->
<!--   spres[[i]] <- data.frame( -->
<!--     study = rep(slabel[i], length(spp)), -->
<!--     species = spp, -->
<!--     Nobs = NA, -->
<!--     minWP = NA, -->
<!--     critWP = NA, -->
<!--     minLFM = NA, -->
<!--     model1.int = NA, -->
<!--     model1.slp = NA, -->
<!--     model2.int = NA, -->
<!--     model2.slp = NA -->
<!--   ) -->

<!--   # Fit a model without interaction to test if species have different intercepts -->
<!--   fit1 <- glm(ilfm ~ mwp * species, data = td) -->
<!--   stres$BIC.no.int[i] <- BIC(fit1)  # Store Bayesian Information Criterion -->
<!--   stres$common.slope[i] <- coefficients(fit1)[2]  # Common slope across species -->
<!--   scoeff[[i]] <- coefficients(fit1)  # Store coefficients -->
<!--   pvals[[i]] <- fit1$fitted.values  # Store fitted values -->

<!-- # Extract and store intercepts for each species -->
<!--   spres[[i]]$model1.int[1] <- coefficients(fit1)[1] -->
<!--   spres[[i]]$model1.int[-1] <- coefficients(fit1)[1] + coefficients(fit1)[-c(1:2)] -->
<!--   spres[[i]]$model1.slp <- coefficients(fit1)[2] -->

<!--   # Fit a model with interaction to test if species have different slopes -->
<!--   fit2 <- glm(ilfm ~ mwp * species, data = td) -->
<!--   stres$BIC.int[i] <- BIC(fit2) -->

<!-- # Display the statistical results -->
<!-- stres -->
<!-- spres[[1]]  # Results for the first subset -->
<!-- spres[[4]]  # Results for the fourth subset (i = 4) -->

<!-- # Combine species-specific results into one dataframe -->
<!-- spres.all <- spres[[1]] -->
<!-- for (i in 2:length(spres)) spres.all <- rbind(spres.all, spres[[i]]) -->

<!-- } -->

<!-- # Check dimensions and content of the combined results -->
<!-- dim(spres.all) -->
<!-- table(spres.all$study) -->
<!-- head(spres.all) -->
<!-- tail(spres.all) -->

<!-- # Create a shortened species code for easier reference -->
<!-- spres.all$SpCode6 <- substr(spres.all$species, 1, 6) -->

<!-- #Select only the columns that we need:  -->
<!-- coef_values_df <- spres.all %>%  -->
<!--  # filter(study == "All") %>%  -->
<!--   select(study, species, model1.int, model1.slp) %>%  -->
<!--   separate(species, into = c("species", "study2"), sep = "_") %>%  -->
<!--   select(-study2) -->
<!-- ``` -->

<!-- Plots: -->

<!-- ```{r} -->
<!-- # Set up plotting parameters -->
<!--   op = par(mar = c(5, 5, 3, 1)) -->

<!--   # Fit a simple model for plotting purposes -->
<!--  fit <- glm(ilfm ~ mwp, data = td) -->
<!--  mm <- range(td$mwp, na.rm = TRUE) -->
<!--  summary(fit) -->

<!--   # Generate data for plotting the inverse relationship -->
<!--   xy <- inversePlotData(mm, coefficients(fit)) -->

<!-- pform <- "Reg" -->

<!-- # # Plot the data and model fit -->
<!--   if (pform == 'Reg') { -->
<!--     # Plot regular LFM vs. MWP -->
<!--     plot(lfm ~ mwp, data = td, main = slabel[i], -->
<!--          xlim = c(-8, 0), ylim = c(0, 4), -->
<!--          ylab = 'LFM', xlab = 'MWP') -->
<!--     abline(h = 0.7, lty = 2)  # Add horizontal line at LFM = 0.7 -->
<!--     lines(LFM ~ MWP, data = xy, lwd = 3, col = 'red')  # Add fitted line -->
<!--     points(lfm ~ mwp, data = td, pch = 19, col = 'black')  # Data points -->

<!--     # Add species-specific lines colored by site -->
<!--     for (species in spp) { -->
<!--       species_data <- td[td$species == species, ] -->
<!--       species_fit <- glm -->

<!--       # Add species-specific lines colored by site -->
<!--       for (species in spp) { -->
<!--         species_data <- td[td$species == species, ] -->
<!--         species_fit <- glm(ilfm ~ mwp, data = species_data) -->
<!--         species_xy <- inversePlotData(mm, coefficients(species_fit)) -->
<!--         lines(LFM ~ MWP, data = species_xy, col = unique(species_data$scolors), lwd = 1) -->
<!--       } -->

<!--   #     # Add the legend -->
<!--       legend('topleft', legend = unique(td$study), col = unique(td$scolors), pch = 19) -->
<!--     } -->
<!--   } -->



<!-- #Inverse:  -->

<!-- # Reset graphical parameters -->
<!-- par(op) -->

<!-- pform <- "Inv" -->

<!--   if (pform == 'Inv') { -->
<!--     # Plot regular LFM vs. MWP -->
<!--     plot(ilfm ~ mwp, data = td, main = slabel[i], -->
<!--          xlim = c(-8, 0), ylim = c(0, 4), -->
<!--          ylab = 'iLFM', xlab = 'MWP') -->
<!--     abline(h = 0.7, lty = 2)  # Add horizontal line at LFM = 0.7 -->
<!--     lines(iLFM ~ MWP, data = xy, lwd = 3, col = 'red')  # Add fitted line -->
<!--     points(ilfm ~ mwp, data = td, pch = 19, col = 'black')  # Data points -->

<!--     # Add species-specific lines colored by site -->
<!--     for (species in spp) { -->
<!--       species_data <- td[td$species == species, ] -->
<!--       species_fit <- glm -->

<!--       # Add species-specific lines colored by site -->
<!--       for (species in spp) { -->
<!--         species_data <- td[td$species == species, ] -->
<!--         species_fit <- glm(ilfm ~ mwp, data = species_data) -->
<!--         species_xy <- inversePlotData(mm, coefficients(species_fit)) -->
<!--         lines(iLFM ~ MWP, data = species_xy, col = unique(species_data$scolors), lwd = 1) -->
<!--       } -->

<!--   #     # Add the legend -->
<!--       legend('topleft', legend = unique(td$study), col = unique(td$scolors), pch = 19) -->
<!--     } -->
<!--   } -->
<!-- ``` -->

<!-- DONE -->
<!-- ```{r} -->
<!-- # Prepare for analyses by site -->
<!-- sites <- sort(unique(lwa$study))  # Re-affirm the list of study sites -->
<!-- table(lwa$study)  # Check the distribution of observations -->

<!-- # Create a new logical column indicating if the site is coastal -->
<!-- lwa$coastal <- TRUE -->
<!-- lwa$coastal[which(lwa$study == 'SEKI')] <- FALSE  # Mark 'SEKI' as non-coastal -->

<!-- # Initialize lists and labels for storing results -->
<!-- rsel <- list()  # List to hold row indices for each analysis subset -->
<!-- slabel <- sites  # Labels corresponding to each subset -->

<!-- # Populate 'rsel' with row indices for each site -->
<!-- for (i in 1:length(sites)) { -->
<!--   rsel[[i]] <- which(lwa$study == sites[i]) -->
<!-- } -->

<!-- # Add indices for coastal sites -->
<!-- i <- i + 1 -->
<!-- rsel[[i]] <- which(lwa$coastal) -->

<!-- # Add indices for all data -->
<!-- i <- i + 1 -->
<!-- rsel[[i]] <- 1:nrow(lwa) -->

<!-- # Update labels accordingly -->
<!-- slabel <- c(slabel, 'Coastal', 'All') -->

<!-- # Confirm that 'rsel' and 'slabel' are correctly set up -->
<!-- length(rsel) -->
<!-- slabel -->

<!-- # Initialize data structures to store statistical results -->
<!-- stres <- data.frame( -->
<!--   study = slabel, -->
<!--   Nspec = NA, -->
<!--   Nobs = NA, -->
<!--   BIC.no.int = NA, -->
<!--   common.slope = NA, -->
<!--   BIC.int = NA -->
<!-- ) -->

<!-- spres <- list()  # List to hold species-specific results -->
<!-- scoeff <- list()  # List to hold coefficients from models -->
<!-- pvals <- list()  # List to hold predicted values from models -->

<!-- # Define parameters for model forms and factors -->
<!-- pform <- 'Inv'  # Model form: 'Reg' for regular, could be 'Inv' for inverse -->
<!-- sppFac <- 'Species'  # Species factor, could be 'Species' or 'SpeciesSite' -->
<!-- slpModel <- 'Common'  # Slope model: 'Common' or 'SpSpecific' -->

<!-- # Initialize the loop counter -->
<!-- i = 6 -->

<!-- # Loop through each subset defined in 'rsel' -->
<!-- for (i in 1:length(rsel)) { -->
<!--   # Subset the data for the current selection -->
<!--   td <- lwa[rsel[[i]], ] -->

<!--   # Adjust species factor if necessary so that if species occur at different sites they are treated differently -->
<!--   #if (sppFac == 'SpeciesSite') td$Species <- td$Sp.Site -->

<!--   # Record the number of observations and species -->
<!--   stres$Nobs[i] <- nrow(td) -->
<!--   spp <- sort(unique(td$species)) -->
<!--   stres$Nspec[i] <- length(spp) -->

<!--   # Prepare a dataframe to store species-specific results -->
<!--   spres[[i]] <- data.frame( -->
<!--     study = rep(slabel[i], length(spp)), -->
<!--     species = spp, -->
<!--     Nobs = NA, -->
<!--     minWP = NA, -->
<!--     critWP = NA, -->
<!--     minLFM = NA, -->
<!--     model1.int = NA, -->
<!--     model1.slp = NA, -->
<!--     model2.int = NA, -->
<!--     model2.slp = NA -->
<!--   ) -->

<!--   # Fit a model without interaction to test if species have different intercepts -->
<!--   fit1 <- glm(ilfm ~ mwp * species, data = td) -->
<!--   stres$BIC.no.int[i] <- BIC(fit1)  # Store Bayesian Information Criterion -->
<!--   stres$common.slope[i] <- coefficients(fit1)[2]  # Common slope across species -->
<!--   scoeff[[i]] <- coefficients(fit1)  # Store coefficients -->
<!--   pvals[[i]] <- fit1$fitted.values  # Store fitted values -->

<!-- # Extract and store intercepts for each species -->
<!--   spres[[i]]$model1.int[1] <- coefficients(fit1)[1] -->
<!--   spres[[i]]$model1.int[-1] <- coefficients(fit1)[1] + coefficients(fit1)[-c(1:2)] -->
<!--   spres[[i]]$model1.slp <- coefficients(fit1)[2] -->

<!--   # Fit a model with interaction to test if species have different slopes -->
<!--   fit2 <- glm(ilfm ~ mwp * species, data = td) -->
<!--   stres$BIC.int[i] <- BIC(fit2) -->

<!--   # Set up plotting parameters -->
<!--   op = par(mar = c(5, 5, 3, 1)) -->

<!--   # Fit a simple model for plotting purposes -->
<!--  fit <- glm(ilfm ~ mwp, data = td) -->
<!--  mm <- range(td$mwp, na.rm = TRUE) -->
<!-- summary(fit) -->

<!--   # Generate data for plotting the inverse relationship -->
<!--  xy <- inversePlotData(mm, coefficients(fit)) -->

<!--   # # Plot the data and model fit -->
<!--   if (pform == 'Reg') { -->
<!--   #Plot regular LFM vs. MWP -->
<!--     plot(lfm ~ mwp, data = td, main = slabel[i], -->
<!--          xlim = c(-8, 0), ylim = c(0, 4), -->
<!--          ylab = 'LFM', xlab = 'MWP') -->
<!--     abline(h = 0.7, lty = 2)  # Add horizontal line at LFM = 0.7 -->
<!--     lines(LFM ~ MWP, data = xy, lwd = 3, col = 'red')  # Add fitted line -->
<!--     points(lfm ~ mwp, data = td, pch = 19, col = 'black')  # Data points -->

<!--     # Add species-specific lines colored by site -->
<!--     for (species in spp) { -->
<!--       species_data <- td[td$Species == species, ] -->
<!--       species_fit <- glm -->

<!--       # Add species-specific lines colored by site -->
<!--       for (species in spp) { -->
<!--         species_data <- td[td$species == species, ] -->
<!--         species_fit <- glm(ilfm ~ mwp, data = species_data) -->
<!--         species_xy <- inversePlotData(mm, coefficients(species_fit)) -->
<!--         lines(LFM ~ MWP, data = species_xy, col = unique(species_data$scolors), lwd = 1) -->
<!--       } -->

<!--       # Add the legend -->
<!--       legend('topleft', legend = unique(td$study), col = unique(td$scolors), pch = 19) -->
<!--     } -->
<!--   } -->

<!--   # Increment the counter -->
<!--   i <- i + 1 -->
<!-- } -->

<!-- # Reset graphical parameters -->
<!-- par(op) -->

<!-- # Display the statistical results -->
<!-- stres -->
<!-- spres[[1]]  # Results for the first subset -->
<!-- spres[[4]]  # Results for the fourth subset (i = 4) -->

<!-- # Combine species-specific results into one dataframe -->
<!-- spres.all <- spres[[1]] -->
<!-- for (i in 2:length(spres)) spres.all <- rbind(spres.all, spres[[i]]) -->

<!-- # Check dimensions and content of the combined results -->
<!-- dim(spres.all) -->
<!-- table(spres.all$study) -->
<!-- head(spres.all) -->
<!-- tail(spres.all) -->

<!-- # Create a shortened species code for easier reference -->
<!-- spres.all$SpCode6 <- substr(spres.all$species, 1, 6) -->

<!-- #Select only the columns that we need:  -->
<!-- coef_values_df_common <- spres.all %>%  -->
<!--   filter(study == "All") %>%  -->
<!--   select(study, species, model1.int, model1.slp) %>%  -->
<!--   separate(species, into = c("species", "study2"), sep = "_") %>%  -->
<!--   select(-study2) -->
<!-- ``` -->

<!-- Above chunk is the code to run get the slope and intercepts of linear relationships between Psi and 1/LFM into a dataframe (spres.all).  -->
<!-- ```{r} -->
<!-- # Prepare for analyses by site -->
<!-- sp_site <- sort(unique(lwa$sp_site))  # Re-affirm the list of study species -->
<!-- table(lwa$sp_site)  # Check the distribution of observations -->

<!-- # Create a new logical column indicating if the site is coastal -->
<!-- lwa$coastal <- TRUE -->
<!-- lwa$coastal[which(lwa$study == 'SEKI')] <- FALSE  # Mark 'SEKI' as non-coastal -->

<!-- # Initialize lists and labels for storing results -->
<!-- rsel <- list()  # List to hold row indices for each analysis subset -->
<!-- slabel <- sp_site  # Labels corresponding to each subset -->

<!-- # Populate 'rsel' with row indices for each site -->
<!-- for (i in 1:length(sp_site)) { -->
<!--   rsel[[i]] <- which(lwa$sp_site == sp_site[i]) -->
<!-- } -->

<!-- # Add indices for coastal sites -->
<!-- i <- i + 1 -->
<!-- rsel[[i]] <- which(lwa$coastal) -->

<!-- # Add indices for all data -->
<!-- i <- i + 1 -->
<!-- rsel[[i]] <- 1:nrow(lwa) -->

<!-- # Update labels accordingly -->
<!-- slabel <- c(slabel, 'Coastal', 'All') -->

<!-- # Confirm that 'rsel' and 'slabel' are correctly set up -->
<!-- length(rsel) -->
<!-- slabel -->

<!-- # Initialize data structures to store statistical results -->
<!-- stres <- data.frame( -->
<!--   study = slabel, -->
<!--   Nspec = NA, -->
<!--   Nobs = NA, -->
<!--   BIC.no.int = NA, -->
<!--   common.slope = NA, -->
<!--   BIC.int = NA -->
<!-- ) -->

<!-- spres <- list()  # List to hold species-specific results -->
<!-- scoeff <- list()  # List to hold coefficients from models -->
<!-- pvals <- list()  # List to hold predicted values from models -->

<!-- # Define parameters for model forms and factors -->
<!-- pform <- 'Inv'  # Model form: 'Reg' for regular, could be 'Inv' for inverse -->
<!-- sppFac <- 'Species'  # Species factor, could be 'Species' or 'SpeciesSite' -->
<!-- slpModel <- 'Common'  # Slope model: 'Common' or 'SpSpecific' -->

<!-- # Initialize the loop counter -->
<!-- i = length(sp_site) -->

<!-- # Loop through each subset defined in 'rsel' -->
<!-- for (i in 1:length(rsel)) { -->
<!--   # Subset the data for the current selection -->
<!--   td <- lwa[rsel[[i]], ] -->

<!--   # Adjust species factor if necessary so that if species occur at different sites they are treated differently -->
<!--   #if (sppFac == 'SpeciesSite') td$Species <- td$Sp.Site -->

<!--   # Record the number of observations and species -->
<!--   stres$Nobs[i] <- nrow(td) -->
<!--   spp <- sort(unique(td$species)) -->
<!--   stres$Nspec[i] <- length(spp) -->

<!--   # Prepare a dataframe to store species-specific results -->
<!--   spres[[i]] <- data.frame( -->
<!--     study = rep(slabel[i], length(spp)), -->
<!--     species = spp, -->
<!--     Nobs = NA, -->
<!--     minWP = NA, -->
<!--     critWP = NA, -->
<!--     minLFM = NA, -->
<!--     model1.int = NA, -->
<!--     model1.slp = NA, -->
<!--     model2.int = NA, -->
<!--     model2.slp = NA -->
<!--   ) -->

<!--   # Fit a model without interaction to test if species have different intercepts -->
<!--   fit1 <- glm(ilfm ~ mwp, data = td) -->
<!--   stres$BIC.no.int[i] <- BIC(fit1)  # Store Bayesian Information Criterion -->
<!--   stres$common.slope[i] <- coefficients(fit1)[2]  # Common slope across species -->
<!--   scoeff[[i]] <- coefficients(fit1)  # Store coefficients -->
<!--   pvals[[i]] <- fit1$fitted.values  # Store fitted values -->

<!-- # Extract and store intercepts for each species -->
<!--   spres[[i]]$model1.int[1] <- coefficients(fit1)[1] -->
<!--   spres[[i]]$model1.int[-1] <- coefficients(fit1)[1] + coefficients(fit1)[-c(1:2)] -->
<!--   spres[[i]]$model1.slp <- coefficients(fit1)[2] -->

<!--   # Fit a model with interaction to test if species have different slopes -->
<!--   fit2 <- glm(ilfm ~ mwp, data = td) -->
<!--   stres$BIC.int[i] <- BIC(fit2) -->

<!--   # Set up plotting parameters -->
<!--   op = par(mar = c(5, 5, 3, 1)) -->

<!--   # Fit a simple model for plotting purposes -->
<!--  fit <- glm(ilfm ~ mwp, data = td) -->
<!--  mm <- range(td$mwp, na.rm = TRUE) -->
<!-- summary(fit) -->

<!--   # Generate data for plotting the inverse relationship -->
<!--  xy <- inversePlotData(mm, coefficients(fit)) -->

<!--   # # Plot the data and model fit -->
<!--   if (pform == 'Reg') { -->
<!--   #Plot regular LFM vs. MWP -->
<!--     plot(lfm ~ mwp, data = td, main = slabel[i], -->
<!--          xlim = c(-8, 0), ylim = c(0, 4), -->
<!--          ylab = 'LFM', xlab = 'MWP') -->
<!--     abline(h = 0.7, lty = 2)  # Add horizontal line at LFM = 0.7 -->
<!--     lines(LFM ~ MWP, data = xy, lwd = 3, col = 'red')  # Add fitted line -->
<!--     points(lfm ~ mwp, data = td, pch = 19, col = 'black')  # Data points -->

<!--     # Add species-specific lines colored by site -->
<!--     for (species in spp) { -->
<!--       species_data <- td[td$Species == species, ] -->
<!--       species_fit <- glm -->

<!--       # Add species-specific lines colored by site -->
<!--       for (species in spp) { -->
<!--         species_data <- td[td$species == species, ] -->
<!--         species_fit <- glm(ilfm ~ mwp, data = species_data) -->
<!--         species_xy <- inversePlotData(mm, coefficients(species_fit)) -->
<!--         lines(LFM ~ MWP, data = species_xy, col = unique(species_data$scolors), lwd = 1) -->
<!--       } -->

<!--       # Add the legend -->
<!--       legend('topleft', legend = unique(td$study), col = unique(td$scolors), pch = 19) -->
<!--     } -->
<!--   } -->

<!--   # Increment the counter -->
<!--   i <- i + 1 -->
<!-- } -->

<!-- # Reset graphical parameters -->
<!-- par(op) -->

<!-- # Display the statistical results -->
<!-- stres -->
<!-- spres[[1]]  # Results for the first subset -->
<!-- spres[[4]]  # Results for the fourth subset (i = 4) -->

<!-- # Combine species-specific results into one dataframe -->
<!-- spres.all <- spres[[1]] -->
<!-- for (i in 2:length(spres)) spres.all <- rbind(spres.all, spres[[i]]) -->

<!-- # Check dimensions and content of the combined results -->
<!-- dim(spres.all) -->
<!-- table(spres.all$study) -->
<!-- head(spres.all) -->
<!-- tail(spres.all) -->

<!-- # Create a shortened species code for easier reference -->
<!-- spres.all$SpCode6 <- substr(spres.all$species, 1, 6) -->

<!-- #Select only the columns that we need:  -->
<!-- coef_values_df_common <- spres.all %>%  -->
<!--   filter(study == "All") %>%  -->
<!--   select(study, species, model1.int, model1.slp) %>%  -->
<!--   separate(species, into = c("species", "study2"), sep = "_") %>%  -->
<!--   select(-study2) -->
<!-- ``` -->
